(function () {
	function r(e, n, t) {
		function o(i, f) {
			if (!n[i]) {
				if (!e[i]) {
					var c = "function" == typeof require && require;
					if (!f && c) return c(i, !0);
					if (u) return u(i, !0);
					var a = new Error("Cannot find module '" + i + "'");
					throw ((a.code = "MODULE_NOT_FOUND"), a);
				}
				var p = (n[i] = { exports: {} });
				e[i][0].call(
					p.exports,
					function (r) {
						var n = e[i][1][r];
						return o(n || r);
					},
					p,
					p.exports,
					r,
					e,
					n,
					t
				);
			}
			return n[i].exports;
		}
		for (
			var u = "function" == typeof require && require, i = 0;
			i < t.length;
			i++
		)
			o(t[i]);
		return o;
	}
	return r;
})()(
	{
		1: [
			function (require, module, exports) {
				"use strict";
				Object.defineProperty(exports, "__esModule", { value: true });
				var w =
					typeof window !== "undefined"
						? window
						: { screen: {}, navigator: {} };
				var matchMedia = (
					w.matchMedia ||
					function () {
						return { matches: false };
					}
				).bind(w);
				var passiveOptionAccessed = false;
				var options = {
					get passive() {
						return (passiveOptionAccessed = true);
					},
				};
				var noop = function () {};
				w.addEventListener && w.addEventListener("p", noop, options);
				w.removeEventListener && w.removeEventListener("p", noop, false);
				var supportsPassiveEvents = passiveOptionAccessed;
				var supportsPointerEvents = "PointerEvent" in w;
				var onTouchStartInWindow = "ontouchstart" in w;
				var touchEventInWindow = "TouchEvent" in w;
				var supportsTouchEvents =
					onTouchStartInWindow ||
					(touchEventInWindow && matchMedia("(any-pointer: coarse)").matches);
				var hasTouch =
					(w.navigator.maxTouchPoints || 0) > 0 || supportsTouchEvents;
				var userAgent = w.navigator.userAgent || "";
				var isIPad =
					matchMedia("(pointer: coarse)").matches &&
					/iPad|Macintosh/.test(userAgent) &&
					Math.min(w.screen.width || 0, w.screen.height || 0) >= 768;
				var hasCoarsePrimaryPointer =
					(matchMedia("(pointer: coarse)").matches ||
						(!matchMedia("(pointer: fine)").matches && onTouchStartInWindow)) &&
					!/Windows.*Firefox/.test(userAgent);
				var hasAnyHoverOrAnyFinePointer =
					matchMedia("(any-pointer: fine)").matches ||
					matchMedia("(any-hover: hover)").matches ||
					isIPad ||
					!onTouchStartInWindow;
				var deviceType =
					hasTouch && (hasAnyHoverOrAnyFinePointer || !hasCoarsePrimaryPointer)
						? "hybrid"
						: hasTouch
						? "touchOnly"
						: "mouseOnly";
				var primaryInput =
					deviceType === "mouseOnly"
						? "mouse"
						: deviceType === "touchOnly"
						? "touch"
						: hasCoarsePrimaryPointer
						? "touch"
						: "mouse";
				exports.deviceType = deviceType;
				exports.primaryInput = primaryInput;
				exports.supportsPassiveEvents = supportsPassiveEvents;
				exports.supportsPointerEvents = supportsPointerEvents;
				exports.supportsTouchEvents = supportsTouchEvents;
			},
			{},
		],
		2: [
			function (require, module, exports) {
				(function (process) {
					(function () {
						"use strict";
						if (process.env.NODE_ENV === "production") {
							module.exports = require("./detect-it.cjs.production.js");
						} else {
							module.exports = require("./detect-it.cjs.development.js");
						}
					}.call(this));
				}.call(this, require("_process")));
			},
			{
				"./detect-it.cjs.development.js": 1,
				"./detect-it.cjs.production.js": 3,
				_process: 55,
			},
		],
		3: [
			function (require, module, exports) {
				"use strict";
				Object.defineProperty(exports, "__esModule", { value: !0 });
				var e =
						"undefined" != typeof window
							? window
							: { screen: {}, navigator: {} },
					t = (
						e.matchMedia ||
						function () {
							return { matches: !1 };
						}
					).bind(e),
					n = !1,
					s = {
						get passive() {
							return (n = !0);
						},
					},
					o = function () {};
				e.addEventListener && e.addEventListener("p", o, s),
					e.removeEventListener && e.removeEventListener("p", o, !1);
				var r = n,
					i = "PointerEvent" in e,
					a = "ontouchstart" in e,
					c = a || ("TouchEvent" in e && t("(any-pointer: coarse)").matches),
					p = (e.navigator.maxTouchPoints || 0) > 0 || c,
					u = e.navigator.userAgent || "",
					h =
						t("(pointer: coarse)").matches &&
						/iPad|Macintosh/.test(u) &&
						Math.min(e.screen.width || 0, e.screen.height || 0) >= 768,
					v =
						(t("(pointer: coarse)").matches ||
							(!t("(pointer: fine)").matches && a)) &&
						!/Windows.*Firefox/.test(u),
					d =
						t("(any-pointer: fine)").matches ||
						t("(any-hover: hover)").matches ||
						h ||
						!a,
					m = !p || (!d && v) ? (p ? "touchOnly" : "mouseOnly") : "hybrid",
					y =
						"mouseOnly" === m
							? "mouse"
							: "touchOnly" === m || v
							? "touch"
							: "mouse";
				(exports.deviceType = m),
					(exports.primaryInput = y),
					(exports.supportsPassiveEvents = r),
					(exports.supportsPointerEvents = i),
					(exports.supportsTouchEvents = c);
			},
			{},
		],
		4: [
			function (require, module, exports) {
				(function (global, factory) {
					typeof exports === "object" && typeof module !== "undefined"
						? factory(exports)
						: typeof define === "function" && define.amd
						? define(["exports"], factory)
						: ((global = global || self),
						  factory((global.window = global.window || {})));
				})(this, function (exports) {
					"use strict";
					var gsap,
						_coreInitted,
						_window,
						_docEl,
						_body,
						_toArray,
						_config,
						_windowExists = function _windowExists() {
							return typeof window !== "undefined";
						},
						_getGSAP = function _getGSAP() {
							return (
								gsap ||
								(_windowExists() &&
									(gsap = window.gsap) &&
									gsap.registerPlugin &&
									gsap)
							);
						},
						_isString = function _isString(value) {
							return typeof value === "string";
						},
						_isFunction = function _isFunction(value) {
							return typeof value === "function";
						},
						_max = function _max(element, axis) {
							var dim = axis === "x" ? "Width" : "Height",
								scroll = "scroll" + dim,
								client = "client" + dim;
							return element === _window ||
								element === _docEl ||
								element === _body
								? Math.max(_docEl[scroll], _body[scroll]) -
										(_window["inner" + dim] || _docEl[client] || _body[client])
								: element[scroll] - element["offset" + dim];
						},
						_buildGetter = function _buildGetter(e, axis) {
							var p = "scroll" + (axis === "x" ? "Left" : "Top");
							if (e === _window) {
								if (e.pageXOffset != null) {
									p = "page" + axis.toUpperCase() + "Offset";
								} else {
									e = _docEl[p] != null ? _docEl : _body;
								}
							}
							return function () {
								return e[p];
							};
						},
						_clean = function _clean(value, index, target, targets) {
							_isFunction(value) && (value = value(index, target, targets));
							if (typeof value !== "object") {
								return _isString(value) &&
									value !== "max" &&
									value.charAt(1) !== "="
									? { x: value, y: value }
									: { y: value };
							} else if (value.nodeType) {
								return { y: value, x: value };
							} else {
								var result = {},
									p;
								for (p in value) {
									result[p] =
										p !== "onAutoKill" && _isFunction(value[p])
											? value[p](index, target, targets)
											: value[p];
								}
								return result;
							}
						},
						_getOffset = function _getOffset(element, container) {
							element = _toArray(element)[0];
							if (!element || !element.getBoundingClientRect) {
								return (
									console.warn("scrollTo target doesn't exist. Using 0") || {
										x: 0,
										y: 0,
									}
								);
							}
							var rect = element.getBoundingClientRect(),
								isRoot =
									!container || container === _window || container === _body,
								cRect = isRoot
									? {
											top:
												_docEl.clientTop -
												(_window.pageYOffset ||
													_docEl.scrollTop ||
													_body.scrollTop ||
													0),
											left:
												_docEl.clientLeft -
												(_window.pageXOffset ||
													_docEl.scrollLeft ||
													_body.scrollLeft ||
													0),
									  }
									: container.getBoundingClientRect(),
								offsets = {
									x: rect.left - cRect.left,
									y: rect.top - cRect.top,
								};
							if (!isRoot && container) {
								offsets.x += _buildGetter(container, "x")();
								offsets.y += _buildGetter(container, "y")();
							}
							return offsets;
						},
						_parseVal = function _parseVal(
							value,
							target,
							axis,
							currentVal,
							offset
						) {
							return !isNaN(value) && typeof value !== "object"
								? parseFloat(value) - offset
								: _isString(value) && value.charAt(1) === "="
								? parseFloat(value.substr(2)) *
										(value.charAt(0) === "-" ? -1 : 1) +
								  currentVal -
								  offset
								: value === "max"
								? _max(target, axis) - offset
								: Math.min(
										_max(target, axis),
										_getOffset(value, target)[axis] - offset
								  );
						},
						_initCore = function _initCore() {
							gsap = _getGSAP();
							if (_windowExists() && gsap && document.body) {
								_window = window;
								_body = document.body;
								_docEl = document.documentElement;
								_toArray = gsap.utils.toArray;
								gsap.config({ autoKillThreshold: 7 });
								_config = gsap.config();
								_coreInitted = 1;
							}
						};
					var ScrollToPlugin = {
						version: "3.8.0",
						name: "scrollTo",
						rawVars: 1,
						register: function register(core) {
							gsap = core;
							_initCore();
						},
						init: function init(target, value, tween, index, targets) {
							_coreInitted || _initCore();
							var data = this,
								snapType = gsap.getProperty(target, "scrollSnapType");
							data.isWin = target === _window;
							data.target = target;
							data.tween = tween;
							value = _clean(value, index, target, targets);
							data.vars = value;
							data.autoKill = !!value.autoKill;
							data.getX = _buildGetter(target, "x");
							data.getY = _buildGetter(target, "y");
							data.x = data.xPrev = data.getX();
							data.y = data.yPrev = data.getY();
							if (snapType && snapType !== "none") {
								data.snap = 1;
								data.snapInline = target.style.scrollSnapType;
								target.style.scrollSnapType = "none";
							}
							if (value.x != null) {
								data.add(
									data,
									"x",
									data.x,
									_parseVal(value.x, target, "x", data.x, value.offsetX || 0),
									index,
									targets
								);
								data._props.push("scrollTo_x");
							} else {
								data.skipX = 1;
							}
							if (value.y != null) {
								data.add(
									data,
									"y",
									data.y,
									_parseVal(value.y, target, "y", data.y, value.offsetY || 0),
									index,
									targets
								);
								data._props.push("scrollTo_y");
							} else {
								data.skipY = 1;
							}
						},
						render: function render(ratio, data) {
							var pt = data._pt,
								target = data.target,
								tween = data.tween,
								autoKill = data.autoKill,
								xPrev = data.xPrev,
								yPrev = data.yPrev,
								isWin = data.isWin,
								snap = data.snap,
								snapInline = data.snapInline,
								x,
								y,
								yDif,
								xDif,
								threshold;
							while (pt) {
								pt.r(ratio, pt.d);
								pt = pt._next;
							}
							x = isWin || !data.skipX ? data.getX() : xPrev;
							y = isWin || !data.skipY ? data.getY() : yPrev;
							yDif = y - yPrev;
							xDif = x - xPrev;
							threshold = _config.autoKillThreshold;
							if (data.x < 0) {
								data.x = 0;
							}
							if (data.y < 0) {
								data.y = 0;
							}
							if (autoKill) {
								if (
									!data.skipX &&
									(xDif > threshold || xDif < -threshold) &&
									x < _max(target, "x")
								) {
									data.skipX = 1;
								}
								if (
									!data.skipY &&
									(yDif > threshold || yDif < -threshold) &&
									y < _max(target, "y")
								) {
									data.skipY = 1;
								}
								if (data.skipX && data.skipY) {
									tween.kill();
									data.vars.onAutoKill &&
										data.vars.onAutoKill.apply(
											tween,
											data.vars.onAutoKillParams || []
										);
								}
							}
							if (isWin) {
								_window.scrollTo(
									!data.skipX ? data.x : x,
									!data.skipY ? data.y : y
								);
							} else {
								data.skipY || (target.scrollTop = data.y);
								data.skipX || (target.scrollLeft = data.x);
							}
							if (snap && (ratio === 1 || ratio === 0)) {
								y = target.scrollTop;
								x = target.scrollLeft;
								snapInline
									? (target.style.scrollSnapType = snapInline)
									: target.style.removeProperty("scroll-snap-type");
								target.scrollTop = y + 1;
								target.scrollLeft = x + 1;
								target.scrollTop = y;
								target.scrollLeft = x;
							}
							data.xPrev = data.x;
							data.yPrev = data.y;
						},
						kill: function kill(property) {
							var both = property === "scrollTo";
							if (both || property === "scrollTo_x") {
								this.skipX = 1;
							}
							if (both || property === "scrollTo_y") {
								this.skipY = 1;
							}
						},
					};
					ScrollToPlugin.max = _max;
					ScrollToPlugin.getOffset = _getOffset;
					ScrollToPlugin.buildGetter = _buildGetter;
					_getGSAP() && gsap.registerPlugin(ScrollToPlugin);
					exports.ScrollToPlugin = ScrollToPlugin;
					exports.default = ScrollToPlugin;
					Object.defineProperty(exports, "__esModule", { value: true });
				});
			},
			{},
		],
		5: [
			function (require, module, exports) {
				(function (global, factory) {
					typeof exports === "object" && typeof module !== "undefined"
						? factory(exports)
						: typeof define === "function" && define.amd
						? define(["exports"], factory)
						: ((global = global || self),
						  factory((global.window = global.window || {})));
				})(this, function (exports) {
					"use strict";
					var gsap,
						_coreInitted,
						_win,
						_doc,
						_docEl,
						_body,
						_root,
						_resizeDelay,
						_raf,
						_request,
						_toArray,
						_clamp,
						_time2,
						_syncInterval,
						_refreshing,
						_pointerIsDown,
						_transformProp,
						_i,
						_prevWidth,
						_prevHeight,
						_autoRefresh,
						_sort,
						_suppressOverwrites,
						_ignoreResize,
						_limitCallbacks,
						_startup = 1,
						_proxies = [],
						_scrollers = [],
						_getTime = Date.now,
						_time1 = _getTime(),
						_lastScrollTime = 0,
						_enabled = 1,
						_passThrough = function _passThrough(v) {
							return v;
						},
						_getTarget = function _getTarget(t) {
							return (
								_toArray(t)[0] ||
								(_isString(t) ? console.warn("Element not found:", t) : null)
							);
						},
						_round = function _round(value) {
							return Math.round(value * 1e5) / 1e5 || 0;
						},
						_windowExists = function _windowExists() {
							return typeof window !== "undefined";
						},
						_getGSAP = function _getGSAP() {
							return (
								gsap ||
								(_windowExists() &&
									(gsap = window.gsap) &&
									gsap.registerPlugin &&
									gsap)
							);
						},
						_isViewport = function _isViewport(e) {
							return !!~_root.indexOf(e);
						},
						_getProxyProp = function _getProxyProp(element, property) {
							return (
								~_proxies.indexOf(element) &&
								_proxies[_proxies.indexOf(element) + 1][property]
							);
						},
						_getScrollFunc = function _getScrollFunc(element, _ref) {
							var s = _ref.s,
								sc = _ref.sc;
							var i = _scrollers.indexOf(element),
								offset = sc === _vertical.sc ? 1 : 2;
							!~i && (i = _scrollers.push(element) - 1);
							return (
								_scrollers[i + offset] ||
								(_scrollers[i + offset] =
									_getProxyProp(element, s) ||
									(_isViewport(element)
										? sc
										: function (value) {
												return arguments.length
													? (element[s] = value)
													: element[s];
										  }))
							);
						},
						_getBoundsFunc = function _getBoundsFunc(element) {
							return (
								_getProxyProp(element, "getBoundingClientRect") ||
								(_isViewport(element)
									? function () {
											_winOffsets.width = _win.innerWidth;
											_winOffsets.height = _win.innerHeight;
											return _winOffsets;
									  }
									: function () {
											return _getBounds(element);
									  })
							);
						},
						_getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref2) {
							var d = _ref2.d,
								d2 = _ref2.d2,
								a = _ref2.a;
							return (a = _getProxyProp(scroller, "getBoundingClientRect"))
								? function () {
										return a()[d];
								  }
								: function () {
										return (
											(isViewport
												? _win["inner" + d2]
												: scroller["client" + d2]) || 0
										);
								  };
						},
						_getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
							return !isViewport || ~_proxies.indexOf(element)
								? _getBoundsFunc(element)
								: function () {
										return _winOffsets;
								  };
						},
						_maxScroll = function _maxScroll(element, _ref3) {
							var s = _ref3.s,
								d2 = _ref3.d2,
								d = _ref3.d,
								a = _ref3.a;
							return (s = "scroll" + d2) && (a = _getProxyProp(element, s))
								? a() - _getBoundsFunc(element)()[d]
								: _isViewport(element)
								? (_body[s] || _docEl[s]) -
								  (_win["inner" + d2] ||
										_docEl["client" + d2] ||
										_body["client" + d2])
								: element[s] - element["offset" + d2];
						},
						_iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
							for (var i = 0; i < _autoRefresh.length; i += 3) {
								(!events || ~events.indexOf(_autoRefresh[i + 1])) &&
									func(
										_autoRefresh[i],
										_autoRefresh[i + 1],
										_autoRefresh[i + 2]
									);
							}
						},
						_isString = function _isString(value) {
							return typeof value === "string";
						},
						_isFunction = function _isFunction(value) {
							return typeof value === "function";
						},
						_isNumber = function _isNumber(value) {
							return typeof value === "number";
						},
						_isObject = function _isObject(value) {
							return typeof value === "object";
						},
						_callIfFunc = function _callIfFunc(value) {
							return _isFunction(value) && value();
						},
						_combineFunc = function _combineFunc(f1, f2) {
							return function () {
								var result1 = _callIfFunc(f1),
									result2 = _callIfFunc(f2);
								return function () {
									_callIfFunc(result1);
									_callIfFunc(result2);
								};
							};
						},
						_endAnimation = function _endAnimation(animation, reversed, pause) {
							return (
								animation &&
								animation.progress(reversed ? 0 : 1) &&
								pause &&
								animation.pause()
							);
						},
						_callback = function _callback(self, func) {
							var result = func(self);
							result && result.totalTime && (self.callbackAnimation = result);
						},
						_abs = Math.abs,
						_scrollLeft = "scrollLeft",
						_scrollTop = "scrollTop",
						_left = "left",
						_top = "top",
						_right = "right",
						_bottom = "bottom",
						_width = "width",
						_height = "height",
						_Right = "Right",
						_Left = "Left",
						_Top = "Top",
						_Bottom = "Bottom",
						_padding = "padding",
						_margin = "margin",
						_Width = "Width",
						_Height = "Height",
						_px = "px",
						_horizontal = {
							s: _scrollLeft,
							p: _left,
							p2: _Left,
							os: _right,
							os2: _Right,
							d: _width,
							d2: _Width,
							a: "x",
							sc: function sc(value) {
								return arguments.length
									? _win.scrollTo(value, _vertical.sc())
									: _win.pageXOffset ||
											_doc[_scrollLeft] ||
											_docEl[_scrollLeft] ||
											_body[_scrollLeft] ||
											0;
							},
						},
						_vertical = {
							s: _scrollTop,
							p: _top,
							p2: _Top,
							os: _bottom,
							os2: _Bottom,
							d: _height,
							d2: _Height,
							a: "y",
							op: _horizontal,
							sc: function sc(value) {
								return arguments.length
									? _win.scrollTo(_horizontal.sc(), value)
									: _win.pageYOffset ||
											_doc[_scrollTop] ||
											_docEl[_scrollTop] ||
											_body[_scrollTop] ||
											0;
							},
						},
						_getComputedStyle = function _getComputedStyle(element) {
							return _win.getComputedStyle(element);
						},
						_makePositionable = function _makePositionable(element) {
							var position = _getComputedStyle(element).position;
							element.style.position =
								position === "absolute" || position === "fixed"
									? position
									: "relative";
						},
						_setDefaults = function _setDefaults(obj, defaults) {
							for (var p in defaults) {
								p in obj || (obj[p] = defaults[p]);
							}
							return obj;
						},
						_getBounds = function _getBounds(element, withoutTransforms) {
							var tween =
									withoutTransforms &&
									_getComputedStyle(element)[_transformProp] !==
										"matrix(1, 0, 0, 1, 0, 0)" &&
									gsap
										.to(element, {
											x: 0,
											y: 0,
											xPercent: 0,
											yPercent: 0,
											rotation: 0,
											rotationX: 0,
											rotationY: 0,
											scale: 1,
											skewX: 0,
											skewY: 0,
										})
										.progress(1),
								bounds = element.getBoundingClientRect();
							tween && tween.progress(0).kill();
							return bounds;
						},
						_getSize = function _getSize(element, _ref4) {
							var d2 = _ref4.d2;
							return element["offset" + d2] || element["client" + d2] || 0;
						},
						_getLabelRatioArray = function _getLabelRatioArray(timeline) {
							var a = [],
								labels = timeline.labels,
								duration = timeline.duration(),
								p;
							for (p in labels) {
								a.push(labels[p] / duration);
							}
							return a;
						},
						_getClosestLabel = function _getClosestLabel(animation) {
							return function (value) {
								return gsap.utils.snap(_getLabelRatioArray(animation), value);
							};
						},
						_snapDirectional = function _snapDirectional(snapIncrementOrArray) {
							var snap = gsap.utils.snap(snapIncrementOrArray),
								a =
									Array.isArray(snapIncrementOrArray) &&
									snapIncrementOrArray.slice(0).sort(function (a, b) {
										return a - b;
									});
							return a
								? function (value, direction) {
										var i;
										if (!direction) {
											return snap(value);
										}
										if (direction > 0) {
											value -= 1e-4;
											for (i = 0; i < a.length; i++) {
												if (a[i] >= value) {
													return a[i];
												}
											}
											return a[i - 1];
										} else {
											i = a.length;
											value += 1e-4;
											while (i--) {
												if (a[i] <= value) {
													return a[i];
												}
											}
										}
										return a[0];
								  }
								: function (value, direction) {
										var snapped = snap(value);
										return !direction ||
											Math.abs(snapped - value) < 0.001 ||
											snapped - value < 0 === direction < 0
											? snapped
											: snap(
													direction < 0
														? value - snapIncrementOrArray
														: value + snapIncrementOrArray
											  );
								  };
						},
						_getLabelAtDirection = function _getLabelAtDirection(timeline) {
							return function (value, st) {
								return _snapDirectional(_getLabelRatioArray(timeline))(
									value,
									st.direction
								);
							};
						},
						_multiListener = function _multiListener(
							func,
							element,
							types,
							callback
						) {
							return types.split(",").forEach(function (type) {
								return func(element, type, callback);
							});
						},
						_addListener = function _addListener(element, type, func) {
							return element.addEventListener(type, func, { passive: true });
						},
						_removeListener = function _removeListener(element, type, func) {
							return element.removeEventListener(type, func);
						},
						_markerDefaults = {
							startColor: "green",
							endColor: "red",
							indent: 0,
							fontSize: "16px",
							fontWeight: "normal",
						},
						_defaults = { toggleActions: "play", anticipatePin: 0 },
						_keywords = { top: 0, left: 0, center: 0.5, bottom: 1, right: 1 },
						_offsetToPx = function _offsetToPx(value, size) {
							if (_isString(value)) {
								var eqIndex = value.indexOf("="),
									relative = ~eqIndex
										? +(value.charAt(eqIndex - 1) + 1) *
										  parseFloat(value.substr(eqIndex + 1))
										: 0;
								if (~eqIndex) {
									value.indexOf("%") > eqIndex && (relative *= size / 100);
									value = value.substr(0, eqIndex - 1);
								}
								value =
									relative +
									(value in _keywords
										? _keywords[value] * size
										: ~value.indexOf("%")
										? (parseFloat(value) * size) / 100
										: parseFloat(value) || 0);
							}
							return value;
						},
						_createMarker = function _createMarker(
							type,
							name,
							container,
							direction,
							_ref5,
							offset,
							matchWidthEl,
							containerAnimation
						) {
							var startColor = _ref5.startColor,
								endColor = _ref5.endColor,
								fontSize = _ref5.fontSize,
								indent = _ref5.indent,
								fontWeight = _ref5.fontWeight;
							var e = _doc.createElement("div"),
								useFixedPosition =
									_isViewport(container) ||
									_getProxyProp(container, "pinType") === "fixed",
								isScroller = type.indexOf("scroller") !== -1,
								parent = useFixedPosition ? _body : container,
								isStart = type.indexOf("start") !== -1,
								color = isStart ? startColor : endColor,
								css =
									"border-color:" +
									color +
									";font-size:" +
									fontSize +
									";color:" +
									color +
									";font-weight:" +
									fontWeight +
									";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
							css +=
								"position:" +
								((isScroller || containerAnimation) && useFixedPosition
									? "fixed;"
									: "absolute;");
							(isScroller || containerAnimation || !useFixedPosition) &&
								(css +=
									(direction === _vertical ? _right : _bottom) +
									":" +
									(offset + parseFloat(indent)) +
									"px;");
							matchWidthEl &&
								(css +=
									"box-sizing:border-box;text-align:left;width:" +
									matchWidthEl.offsetWidth +
									"px;");
							e._isStart = isStart;
							e.setAttribute(
								"class",
								"gsap-marker-" + type + (name ? " marker-" + name : "")
							);
							e.style.cssText = css;
							e.innerText = name || name === 0 ? type + "-" + name : type;
							parent.children[0]
								? parent.insertBefore(e, parent.children[0])
								: parent.appendChild(e);
							e._offset = e["offset" + direction.op.d2];
							_positionMarker(e, 0, direction, isStart);
							return e;
						},
						_positionMarker = function _positionMarker(
							marker,
							start,
							direction,
							flipped
						) {
							var vars = { display: "block" },
								side = direction[flipped ? "os2" : "p2"],
								oppositeSide = direction[flipped ? "p2" : "os2"];
							marker._isFlipped = flipped;
							vars[direction.a + "Percent"] = flipped ? -100 : 0;
							vars[direction.a] = flipped ? "1px" : 0;
							vars["border" + side + _Width] = 1;
							vars["border" + oppositeSide + _Width] = 0;
							vars[direction.p] = start + "px";
							gsap.set(marker, vars);
						},
						_triggers = [],
						_ids = {},
						_sync = function _sync() {
							return _getTime() - _lastScrollTime > 20 && _updateAll();
						},
						_onScroll = function _onScroll() {
							var time = _getTime();
							if (_lastScrollTime !== time) {
								_updateAll();
								_lastScrollTime || _dispatch("scrollStart");
								_lastScrollTime = time;
							} else if (!_request) {
								_request = _raf(_updateAll);
							}
						},
						_onResize = function _onResize() {
							return (
								!_refreshing &&
								!_ignoreResize &&
								!_doc.fullscreenElement &&
								_resizeDelay.restart(true)
							);
						},
						_listeners = {},
						_emptyArray = [],
						_media = [],
						_creatingMedia,
						_lastMediaTick,
						_onMediaChange = function _onMediaChange(e) {
							var tick = gsap.ticker.frame,
								matches = [],
								i = 0,
								index;
							if (_lastMediaTick !== tick || _startup) {
								_revertAll();
								for (; i < _media.length; i += 4) {
									index = _win.matchMedia(_media[i]).matches;
									if (index !== _media[i + 3]) {
										_media[i + 3] = index;
										index
											? matches.push(i)
											: _revertAll(1, _media[i]) ||
											  (_isFunction(_media[i + 2]) && _media[i + 2]());
									}
								}
								_revertRecorded();
								for (i = 0; i < matches.length; i++) {
									index = matches[i];
									_creatingMedia = _media[index];
									_media[index + 2] = _media[index + 1](e);
								}
								_creatingMedia = 0;
								_coreInitted && _refreshAll(0, 1);
								_lastMediaTick = tick;
								_dispatch("matchMedia");
							}
						},
						_softRefresh = function _softRefresh() {
							return (
								_removeListener(ScrollTrigger, "scrollEnd", _softRefresh) ||
								_refreshAll(true)
							);
						},
						_dispatch = function _dispatch(type) {
							return (
								(_listeners[type] &&
									_listeners[type].map(function (f) {
										return f();
									})) ||
								_emptyArray
							);
						},
						_savedStyles = [],
						_revertRecorded = function _revertRecorded(media) {
							for (var i = 0; i < _savedStyles.length; i += 5) {
								if (!media || _savedStyles[i + 4] === media) {
									_savedStyles[i].style.cssText = _savedStyles[i + 1];
									_savedStyles[i].getBBox &&
										_savedStyles[i].setAttribute(
											"transform",
											_savedStyles[i + 2] || ""
										);
									_savedStyles[i + 3].uncache = 1;
								}
							}
						},
						_revertAll = function _revertAll(kill, media) {
							var trigger;
							for (_i = 0; _i < _triggers.length; _i++) {
								trigger = _triggers[_i];
								if (!media || trigger.media === media) {
									if (kill) {
										trigger.kill(1);
									} else {
										trigger.revert();
									}
								}
							}
							media && _revertRecorded(media);
							media || _dispatch("revert");
						},
						_clearScrollMemory = function _clearScrollMemory() {
							return _scrollers.forEach(function (obj) {
								return typeof obj === "function" && (obj.rec = 0);
							});
						},
						_refreshingAll,
						_refreshAll = function _refreshAll(force, skipRevert) {
							if (_lastScrollTime && !force) {
								_addListener(ScrollTrigger, "scrollEnd", _softRefresh);
								return;
							}
							_refreshingAll = true;
							var refreshInits = _dispatch("refreshInit");
							_sort && ScrollTrigger.sort();
							skipRevert || _revertAll();
							_triggers.forEach(function (t) {
								return t.refresh();
							});
							refreshInits.forEach(function (result) {
								return result && result.render && result.render(-1);
							});
							_clearScrollMemory();
							_resizeDelay.pause();
							_refreshingAll = false;
							_dispatch("refresh");
						},
						_lastScroll = 0,
						_direction = 1,
						_updateAll = function _updateAll() {
							if (!_refreshingAll) {
								var l = _triggers.length,
									time = _getTime(),
									recordVelocity = time - _time1 >= 50,
									scroll = l && _triggers[0].scroll();
								_direction = _lastScroll > scroll ? -1 : 1;
								_lastScroll = scroll;
								if (recordVelocity) {
									if (
										_lastScrollTime &&
										!_pointerIsDown &&
										time - _lastScrollTime > 200
									) {
										_lastScrollTime = 0;
										_dispatch("scrollEnd");
									}
									_time2 = _time1;
									_time1 = time;
								}
								if (_direction < 0) {
									_i = l;
									while (_i-- > 0) {
										_triggers[_i] && _triggers[_i].update(0, recordVelocity);
									}
									_direction = 1;
								} else {
									for (_i = 0; _i < l; _i++) {
										_triggers[_i] && _triggers[_i].update(0, recordVelocity);
									}
								}
								_request = 0;
							}
						},
						_propNamesToCopy = [
							_left,
							_top,
							_bottom,
							_right,
							_margin + _Bottom,
							_margin + _Right,
							_margin + _Top,
							_margin + _Left,
							"display",
							"flexShrink",
							"float",
							"zIndex",
							"grid-column-start",
							"grid-column-end",
							"grid-row-start",
							"grid-row-end",
							"grid-area",
							"justify-self",
							"align-self",
							"place-self",
						],
						_stateProps = _propNamesToCopy.concat([
							_width,
							_height,
							"boxSizing",
							"max" + _Width,
							"max" + _Height,
							"position",
							_margin,
							_padding,
							_padding + _Top,
							_padding + _Right,
							_padding + _Bottom,
							_padding + _Left,
						]),
						_swapPinOut = function _swapPinOut(pin, spacer, state) {
							_setState(state);
							var cache = pin._gsap;
							if (cache.spacerIsNative) {
								_setState(cache.spacerState);
							} else if (pin.parentNode === spacer) {
								var parent = spacer.parentNode;
								if (parent) {
									parent.insertBefore(pin, spacer);
									parent.removeChild(spacer);
								}
							}
						},
						_swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
							if (pin.parentNode !== spacer) {
								var i = _propNamesToCopy.length,
									spacerStyle = spacer.style,
									pinStyle = pin.style,
									p;
								while (i--) {
									p = _propNamesToCopy[i];
									spacerStyle[p] = cs[p];
								}
								spacerStyle.position =
									cs.position === "absolute" ? "absolute" : "relative";
								cs.display === "inline" &&
									(spacerStyle.display = "inline-block");
								pinStyle[_bottom] = pinStyle[_right] = "auto";
								spacerStyle.overflow = "visible";
								spacerStyle.boxSizing = "border-box";
								spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
								spacerStyle[_height] = _getSize(pin, _vertical) + _px;
								spacerStyle[_padding] =
									pinStyle[_margin] =
									pinStyle[_top] =
									pinStyle[_left] =
										"0";
								_setState(spacerState);
								pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
								pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
								pinStyle[_padding] = cs[_padding];
								pin.parentNode.insertBefore(spacer, pin);
								spacer.appendChild(pin);
							}
						},
						_capsExp = /([A-Z])/g,
						_setState = function _setState(state) {
							if (state) {
								var style = state.t.style,
									l = state.length,
									i = 0,
									p,
									value;
								(state.t._gsap || gsap.core.getCache(state.t)).uncache = 1;
								for (; i < l; i += 2) {
									value = state[i + 1];
									p = state[i];
									if (value) {
										style[p] = value;
									} else if (style[p]) {
										style.removeProperty(
											p.replace(_capsExp, "-$1").toLowerCase()
										);
									}
								}
							}
						},
						_getState = function _getState(element) {
							var l = _stateProps.length,
								style = element.style,
								state = [],
								i = 0;
							for (; i < l; i++) {
								state.push(_stateProps[i], style[_stateProps[i]]);
							}
							state.t = element;
							return state;
						},
						_copyState = function _copyState(state, override, omitOffsets) {
							var result = [],
								l = state.length,
								i = omitOffsets ? 8 : 0,
								p;
							for (; i < l; i += 2) {
								p = state[i];
								result.push(p, p in override ? override[p] : state[i + 1]);
							}
							result.t = state.t;
							return result;
						},
						_winOffsets = { left: 0, top: 0 },
						_parsePosition = function _parsePosition(
							value,
							trigger,
							scrollerSize,
							direction,
							scroll,
							marker,
							markerScroller,
							self,
							scrollerBounds,
							borderWidth,
							useFixedPosition,
							scrollerMax,
							containerAnimation
						) {
							_isFunction(value) && (value = value(self));
							if (_isString(value) && value.substr(0, 3) === "max") {
								value =
									scrollerMax +
									(value.charAt(4) === "="
										? _offsetToPx("0" + value.substr(3), scrollerSize)
										: 0);
							}
							var time = containerAnimation ? containerAnimation.time() : 0,
								p1,
								p2,
								element;
							containerAnimation && containerAnimation.seek(0);
							if (!_isNumber(value)) {
								_isFunction(trigger) && (trigger = trigger(self));
								var offsets = value.split(" "),
									bounds,
									localOffset,
									globalOffset,
									display;
								element = _getTarget(trigger) || _body;
								bounds = _getBounds(element) || {};
								if (
									(!bounds || (!bounds.left && !bounds.top)) &&
									_getComputedStyle(element).display === "none"
								) {
									display = element.style.display;
									element.style.display = "block";
									bounds = _getBounds(element);
									display
										? (element.style.display = display)
										: element.style.removeProperty("display");
								}
								localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
								globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
								value =
									bounds[direction.p] -
									scrollerBounds[direction.p] -
									borderWidth +
									localOffset +
									scroll -
									globalOffset;
								markerScroller &&
									_positionMarker(
										markerScroller,
										globalOffset,
										direction,
										scrollerSize - globalOffset < 20 ||
											(markerScroller._isStart && globalOffset > 20)
									);
								scrollerSize -= scrollerSize - globalOffset;
							} else if (markerScroller) {
								_positionMarker(markerScroller, scrollerSize, direction, true);
							}
							if (marker) {
								var position = value + scrollerSize,
									isStart = marker._isStart;
								p1 = "scroll" + direction.d2;
								_positionMarker(
									marker,
									position,
									direction,
									(isStart && position > 20) ||
										(!isStart &&
											(useFixedPosition
												? Math.max(_body[p1], _docEl[p1])
												: marker.parentNode[p1]) <=
												position + 1)
								);
								if (useFixedPosition) {
									scrollerBounds = _getBounds(markerScroller);
									useFixedPosition &&
										(marker.style[direction.op.p] =
											scrollerBounds[direction.op.p] -
											direction.op.m -
											marker._offset +
											_px);
								}
							}
							if (containerAnimation && element) {
								p1 = _getBounds(element);
								containerAnimation.seek(scrollerMax);
								p2 = _getBounds(element);
								containerAnimation._caScrollDist =
									p1[direction.p] - p2[direction.p];
								value =
									(value / containerAnimation._caScrollDist) * scrollerMax;
							}
							containerAnimation && containerAnimation.seek(time);
							return containerAnimation ? value : Math.round(value);
						},
						_prefixExp = /(?:webkit|moz|length|cssText|inset)/i,
						_reparent = function _reparent(element, parent, top, left) {
							if (element.parentNode !== parent) {
								var style = element.style,
									p,
									cs;
								if (parent === _body) {
									element._stOrig = style.cssText;
									cs = _getComputedStyle(element);
									for (p in cs) {
										if (
											!+p &&
											!_prefixExp.test(p) &&
											cs[p] &&
											typeof style[p] === "string" &&
											p !== "0"
										) {
											style[p] = cs[p];
										}
									}
									style.top = top;
									style.left = left;
								} else {
									style.cssText = element._stOrig;
								}
								gsap.core.getCache(element).uncache = 1;
								parent.appendChild(element);
							}
						},
						_getTweenCreator = function _getTweenCreator(scroller, direction) {
							var getScroll = _getScrollFunc(scroller, direction),
								prop = "_scroll" + direction.p2,
								lastScroll1,
								lastScroll2,
								getTween = function getTween(
									scrollTo,
									vars,
									initialValue,
									change1,
									change2
								) {
									var tween = getTween.tween,
										onComplete = vars.onComplete,
										modifiers = {};
									tween && tween.kill();
									lastScroll1 = Math.round(initialValue);
									vars[prop] = scrollTo;
									vars.modifiers = modifiers;
									modifiers[prop] = function (value) {
										value = _round(getScroll());
										if (
											value !== lastScroll1 &&
											value !== lastScroll2 &&
											Math.abs(value - lastScroll1) > 2
										) {
											tween.kill();
											getTween.tween = 0;
										} else {
											value =
												initialValue +
												change1 * tween.ratio +
												change2 * tween.ratio * tween.ratio;
										}
										lastScroll2 = lastScroll1;
										return (lastScroll1 = _round(value));
									};
									vars.onComplete = function () {
										getTween.tween = 0;
										onComplete && onComplete.call(tween);
									};
									tween = getTween.tween = gsap.to(scroller, vars);
									return tween;
								};
							scroller[prop] = getScroll;
							scroller.addEventListener(
								"wheel",
								function () {
									return (
										getTween.tween &&
										getTween.tween.kill() &&
										(getTween.tween = 0)
									);
								},
								{ passive: true }
							);
							return getTween;
						};
					_horizontal.op = _vertical;
					var ScrollTrigger = (function () {
						function ScrollTrigger(vars, animation) {
							_coreInitted ||
								ScrollTrigger.register(gsap) ||
								console.warn("Please gsap.registerPlugin(ScrollTrigger)");
							this.init(vars, animation);
						}
						var _proto = ScrollTrigger.prototype;
						_proto.init = function init(vars, animation) {
							this.progress = this.start = 0;
							this.vars && this.kill(1);
							if (!_enabled) {
								this.update = this.refresh = this.kill = _passThrough;
								return;
							}
							vars = _setDefaults(
								_isString(vars) || _isNumber(vars) || vars.nodeType
									? { trigger: vars }
									: vars,
								_defaults
							);
							var _vars = vars,
								onUpdate = _vars.onUpdate,
								toggleClass = _vars.toggleClass,
								id = _vars.id,
								onToggle = _vars.onToggle,
								onRefresh = _vars.onRefresh,
								scrub = _vars.scrub,
								trigger = _vars.trigger,
								pin = _vars.pin,
								pinSpacing = _vars.pinSpacing,
								invalidateOnRefresh = _vars.invalidateOnRefresh,
								anticipatePin = _vars.anticipatePin,
								onScrubComplete = _vars.onScrubComplete,
								onSnapComplete = _vars.onSnapComplete,
								once = _vars.once,
								snap = _vars.snap,
								pinReparent = _vars.pinReparent,
								pinSpacer = _vars.pinSpacer,
								containerAnimation = _vars.containerAnimation,
								fastScrollEnd = _vars.fastScrollEnd,
								preventOverlaps = _vars.preventOverlaps,
								direction =
									vars.horizontal ||
									(vars.containerAnimation && vars.horizontal !== false)
										? _horizontal
										: _vertical,
								isToggle = !scrub && scrub !== 0,
								scroller = _getTarget(vars.scroller || _win),
								scrollerCache = gsap.core.getCache(scroller),
								isViewport = _isViewport(scroller),
								useFixedPosition =
									("pinType" in vars
										? vars.pinType
										: _getProxyProp(scroller, "pinType") ||
										  (isViewport && "fixed")) === "fixed",
								callbacks = [
									vars.onEnter,
									vars.onLeave,
									vars.onEnterBack,
									vars.onLeaveBack,
								],
								toggleActions = isToggle && vars.toggleActions.split(" "),
								markers = "markers" in vars ? vars.markers : _defaults.markers,
								borderWidth = isViewport
									? 0
									: parseFloat(
											_getComputedStyle(scroller)[
												"border" + direction.p2 + _Width
											]
									  ) || 0,
								self = this,
								onRefreshInit =
									vars.onRefreshInit &&
									function () {
										return vars.onRefreshInit(self);
									},
								getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
								getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
								lastSnap = 0,
								scrollFunc = _getScrollFunc(scroller, direction),
								tweenTo,
								pinCache,
								snapFunc,
								scroll1,
								scroll2,
								start,
								end,
								markerStart,
								markerEnd,
								markerStartTrigger,
								markerEndTrigger,
								markerVars,
								change,
								pinOriginalState,
								pinActiveState,
								pinState,
								spacer,
								offset,
								pinGetter,
								pinSetter,
								pinStart,
								pinChange,
								spacingStart,
								spacerState,
								markerStartSetter,
								markerEndSetter,
								cs,
								snap1,
								snap2,
								scrubTween,
								scrubSmooth,
								snapDurClamp,
								snapDelayedCall,
								prevProgress,
								prevScroll,
								prevAnimProgress,
								caMarkerSetter;
							self.media = _creatingMedia;
							anticipatePin *= 45;
							self.scroller = scroller;
							self.scroll = containerAnimation
								? containerAnimation.time.bind(containerAnimation)
								: scrollFunc;
							scroll1 = scrollFunc();
							self.vars = vars;
							animation = animation || vars.animation;
							"refreshPriority" in vars && (_sort = 1);
							scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
								top: _getTweenCreator(scroller, _vertical),
								left: _getTweenCreator(scroller, _horizontal),
							};
							self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];
							if (animation) {
								animation.vars.lazy = false;
								animation._initted ||
									(animation.vars.immediateRender !== false &&
										vars.immediateRender !== false &&
										animation.render(0, true, true));
								self.animation = animation.pause();
								animation.scrollTrigger = self;
								scrubSmooth = _isNumber(scrub) && scrub;
								scrubSmooth &&
									(scrubTween = gsap.to(animation, {
										ease: "power3",
										duration: scrubSmooth,
										onComplete: function onComplete() {
											return onScrubComplete && onScrubComplete(self);
										},
									}));
								snap1 = 0;
								id || (id = animation.vars.id);
							}
							_triggers.push(self);
							if (snap) {
								if (!_isObject(snap) || snap.push) {
									snap = { snapTo: snap };
								}
								"scrollBehavior" in _body.style &&
									gsap.set(isViewport ? [_body, _docEl] : scroller, {
										scrollBehavior: "auto",
									});
								snapFunc = _isFunction(snap.snapTo)
									? snap.snapTo
									: snap.snapTo === "labels"
									? _getClosestLabel(animation)
									: snap.snapTo === "labelsDirectional"
									? _getLabelAtDirection(animation)
									: snap.directional !== false
									? function (value, st) {
											return _snapDirectional(snap.snapTo)(value, st.direction);
									  }
									: gsap.utils.snap(snap.snapTo);
								snapDurClamp = snap.duration || { min: 0.1, max: 2 };
								snapDurClamp = _isObject(snapDurClamp)
									? _clamp(snapDurClamp.min, snapDurClamp.max)
									: _clamp(snapDurClamp, snapDurClamp);
								snapDelayedCall = gsap
									.delayedCall(
										snap.delay || scrubSmooth / 2 || 0.1,
										function () {
											if (
												Math.abs(self.getVelocity()) < 10 &&
												!_pointerIsDown &&
												lastSnap !== scrollFunc()
											) {
												var totalProgress =
														animation && !isToggle
															? animation.totalProgress()
															: self.progress,
													velocity =
														((totalProgress - snap2) / (_getTime() - _time2)) *
															1e3 || 0,
													change1 = gsap.utils.clamp(
														-self.progress,
														1 - self.progress,
														(_abs(velocity / 2) * velocity) / 0.185
													),
													naturalEnd =
														self.progress +
														(snap.inertia === false ? 0 : change1),
													endValue = _clamp(0, 1, snapFunc(naturalEnd, self)),
													scroll = scrollFunc(),
													endScroll = Math.round(start + endValue * change),
													_snap = snap,
													onStart = _snap.onStart,
													_onInterrupt = _snap.onInterrupt,
													_onComplete = _snap.onComplete,
													tween = tweenTo.tween;
												if (
													scroll <= end &&
													scroll >= start &&
													endScroll !== scroll
												) {
													if (
														tween &&
														!tween._initted &&
														tween.data <= _abs(endScroll - scroll)
													) {
														return;
													}
													if (snap.inertia === false) {
														change1 = endValue - self.progress;
													}
													tweenTo(
														endScroll,
														{
															duration: snapDurClamp(
																_abs(
																	(Math.max(
																		_abs(naturalEnd - totalProgress),
																		_abs(endValue - totalProgress)
																	) *
																		0.185) /
																		velocity /
																		0.05 || 0
																)
															),
															ease: snap.ease || "power3",
															data: _abs(endScroll - scroll),
															onInterrupt: function onInterrupt() {
																return (
																	snapDelayedCall.restart(true) &&
																	_onInterrupt &&
																	_onInterrupt(self)
																);
															},
															onComplete: function onComplete() {
																lastSnap = scrollFunc();
																snap1 = snap2 =
																	animation && !isToggle
																		? animation.totalProgress()
																		: self.progress;
																onSnapComplete && onSnapComplete(self);
																_onComplete && _onComplete(self);
															},
														},
														scroll,
														change1 * change,
														endScroll - scroll - change1 * change
													);
													onStart && onStart(self, tweenTo.tween);
												}
											} else if (self.isActive) {
												snapDelayedCall.restart(true);
											}
										}
									)
									.pause();
							}
							id && (_ids[id] = self);
							trigger = self.trigger = _getTarget(trigger || pin);
							pin = pin === true ? trigger : _getTarget(pin);
							_isString(toggleClass) &&
								(toggleClass = { targets: trigger, className: toggleClass });
							if (pin) {
								pinSpacing === false ||
									pinSpacing === _margin ||
									(pinSpacing =
										!pinSpacing &&
										_getComputedStyle(pin.parentNode).display === "flex"
											? false
											: _padding);
								self.pin = pin;
								vars.force3D !== false && gsap.set(pin, { force3D: true });
								pinCache = gsap.core.getCache(pin);
								if (!pinCache.spacer) {
									if (pinSpacer) {
										pinSpacer = _getTarget(pinSpacer);
										pinSpacer &&
											!pinSpacer.nodeType &&
											(pinSpacer =
												pinSpacer.current || pinSpacer.nativeElement);
										pinCache.spacerIsNative = !!pinSpacer;
										pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
									}
									pinCache.spacer = spacer =
										pinSpacer || _doc.createElement("div");
									spacer.classList.add("pin-spacer");
									id && spacer.classList.add("pin-spacer-" + id);
									pinCache.pinState = pinOriginalState = _getState(pin);
								} else {
									pinOriginalState = pinCache.pinState;
								}
								self.spacer = spacer = pinCache.spacer;
								cs = _getComputedStyle(pin);
								spacingStart = cs[pinSpacing + direction.os2];
								pinGetter = gsap.getProperty(pin);
								pinSetter = gsap.quickSetter(pin, direction.a, _px);
								_swapPinIn(pin, spacer, cs);
								pinState = _getState(pin);
							}
							if (markers) {
								markerVars = _isObject(markers)
									? _setDefaults(markers, _markerDefaults)
									: _markerDefaults;
								markerStartTrigger = _createMarker(
									"scroller-start",
									id,
									scroller,
									direction,
									markerVars,
									0
								);
								markerEndTrigger = _createMarker(
									"scroller-end",
									id,
									scroller,
									direction,
									markerVars,
									0,
									markerStartTrigger
								);
								offset = markerStartTrigger["offset" + direction.op.d2];
								markerStart = _createMarker(
									"start",
									id,
									scroller,
									direction,
									markerVars,
									offset,
									0,
									containerAnimation
								);
								markerEnd = _createMarker(
									"end",
									id,
									scroller,
									direction,
									markerVars,
									offset,
									0,
									containerAnimation
								);
								containerAnimation &&
									(caMarkerSetter = gsap.quickSetter(
										[markerStart, markerEnd],
										direction.a,
										_px
									));
								if (
									!useFixedPosition &&
									!(
										_proxies.length &&
										_getProxyProp(scroller, "fixedMarkers") === true
									)
								) {
									_makePositionable(isViewport ? _body : scroller);
									gsap.set([markerStartTrigger, markerEndTrigger], {
										force3D: true,
									});
									markerStartSetter = gsap.quickSetter(
										markerStartTrigger,
										direction.a,
										_px
									);
									markerEndSetter = gsap.quickSetter(
										markerEndTrigger,
										direction.a,
										_px
									);
								}
							}
							if (containerAnimation) {
								var oldOnUpdate = containerAnimation.vars.onUpdate,
									oldParams = containerAnimation.vars.onUpdateParams;
								containerAnimation.eventCallback("onUpdate", function () {
									self.update(0, 0, 1);
									oldOnUpdate && oldOnUpdate.apply(oldParams || []);
								});
							}
							self.previous = function () {
								return _triggers[_triggers.indexOf(self) - 1];
							};
							self.next = function () {
								return _triggers[_triggers.indexOf(self) + 1];
							};
							self.revert = function (revert) {
								var r = revert !== false || !self.enabled,
									prevRefreshing = _refreshing;
								if (r !== self.isReverted) {
									if (r) {
										self.scroll.rec || (self.scroll.rec = scrollFunc());
										prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0);
										prevProgress = self.progress;
										prevAnimProgress = animation && animation.progress();
									}
									markerStart &&
										[
											markerStart,
											markerEnd,
											markerStartTrigger,
											markerEndTrigger,
										].forEach(function (m) {
											return (m.style.display = r ? "none" : "block");
										});
									r && (_refreshing = 1);
									self.update(r);
									_refreshing = prevRefreshing;
									pin &&
										(r
											? _swapPinOut(pin, spacer, pinOriginalState)
											: (!pinReparent || !self.isActive) &&
											  _swapPinIn(
													pin,
													spacer,
													_getComputedStyle(pin),
													spacerState
											  ));
									self.isReverted = r;
								}
							};
							self.refresh = function (soft, force) {
								if ((_refreshing || !self.enabled) && !force) {
									return;
								}
								if (pin && soft && _lastScrollTime) {
									_addListener(ScrollTrigger, "scrollEnd", _softRefresh);
									return;
								}
								_refreshing = 1;
								scrubTween && scrubTween.pause();
								invalidateOnRefresh &&
									animation &&
									animation.progress(0).invalidate();
								self.isReverted || self.revert();
								var size = getScrollerSize(),
									scrollerBounds = getScrollerOffsets(),
									max = containerAnimation
										? containerAnimation.duration()
										: _maxScroll(scroller, direction),
									offset = 0,
									otherPinOffset = 0,
									parsedEnd = vars.end,
									parsedEndTrigger = vars.endTrigger || trigger,
									parsedStart =
										vars.start ||
										(vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"),
									pinnedContainer =
										vars.pinnedContainer && _getTarget(vars.pinnedContainer),
									triggerIndex =
										(trigger && Math.max(0, _triggers.indexOf(self))) || 0,
									i = triggerIndex,
									cs,
									bounds,
									scroll,
									isVertical,
									override,
									curTrigger,
									curPin,
									oppositeScroll,
									initted,
									revertedPins;
								while (i--) {
									curTrigger = _triggers[i];
									curTrigger.end ||
										curTrigger.refresh(0, 1) ||
										(_refreshing = 1);
									curPin = curTrigger.pin;
									if (
										curPin &&
										(curPin === trigger || curPin === pin) &&
										!curTrigger.isReverted
									) {
										revertedPins || (revertedPins = []);
										revertedPins.unshift(curTrigger);
										curTrigger.revert();
									}
								}
								_isFunction(parsedStart) && (parsedStart = parsedStart(self));
								start =
									_parsePosition(
										parsedStart,
										trigger,
										size,
										direction,
										scrollFunc(),
										markerStart,
										markerStartTrigger,
										self,
										scrollerBounds,
										borderWidth,
										useFixedPosition,
										max,
										containerAnimation
									) || (pin ? -0.001 : 0);
								_isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));
								if (_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {
									if (~parsedEnd.indexOf(" ")) {
										parsedEnd =
											(_isString(parsedStart)
												? parsedStart.split(" ")[0]
												: "") + parsedEnd;
									} else {
										offset = _offsetToPx(parsedEnd.substr(2), size);
										parsedEnd = _isString(parsedStart)
											? parsedStart
											: start + offset;
										parsedEndTrigger = trigger;
									}
								}
								end =
									Math.max(
										start,
										_parsePosition(
											parsedEnd || (parsedEndTrigger ? "100% 0" : max),
											parsedEndTrigger,
											size,
											direction,
											scrollFunc() + offset,
											markerEnd,
											markerEndTrigger,
											self,
											scrollerBounds,
											borderWidth,
											useFixedPosition,
											max,
											containerAnimation
										)
									) || -0.001;
								change = end - start || ((start -= 0.01) && 0.001);
								offset = 0;
								i = triggerIndex;
								while (i--) {
									curTrigger = _triggers[i];
									curPin = curTrigger.pin;
									if (
										curPin &&
										curTrigger.start - curTrigger._pinPush < start &&
										!containerAnimation
									) {
										cs = curTrigger.end - curTrigger.start;
										(curPin === trigger || curPin === pinnedContainer) &&
											!_isNumber(parsedStart) &&
											(offset += cs);
										curPin === pin && (otherPinOffset += cs);
									}
								}
								start += offset;
								end += offset;
								self._pinPush = otherPinOffset;
								if (markerStart && offset) {
									cs = {};
									cs[direction.a] = "+=" + offset;
									pinnedContainer && (cs[direction.p] = "-=" + scrollFunc());
									gsap.set([markerStart, markerEnd], cs);
								}
								if (pin) {
									cs = _getComputedStyle(pin);
									isVertical = direction === _vertical;
									scroll = scrollFunc();
									pinStart =
										parseFloat(pinGetter(direction.a)) + otherPinOffset;
									!max &&
										end > 1 &&
										((isViewport ? _body : scroller).style[
											"overflow-" + direction.a
										] = "scroll");
									_swapPinIn(pin, spacer, cs);
									pinState = _getState(pin);
									bounds = _getBounds(pin, true);
									oppositeScroll =
										useFixedPosition &&
										_getScrollFunc(
											scroller,
											isVertical ? _horizontal : _vertical
										)();
									if (pinSpacing) {
										spacerState = [
											pinSpacing + direction.os2,
											change + otherPinOffset + _px,
										];
										spacerState.t = spacer;
										i =
											pinSpacing === _padding
												? _getSize(pin, direction) + change + otherPinOffset
												: 0;
										i && spacerState.push(direction.d, i + _px);
										_setState(spacerState);
										useFixedPosition && scrollFunc(prevScroll);
									}
									if (useFixedPosition) {
										override = {
											top:
												bounds.top +
												(isVertical ? scroll - start : oppositeScroll) +
												_px,
											left:
												bounds.left +
												(isVertical ? oppositeScroll : scroll - start) +
												_px,
											boxSizing: "border-box",
											position: "fixed",
										};
										override[_width] = override["max" + _Width] =
											Math.ceil(bounds.width) + _px;
										override[_height] = override["max" + _Height] =
											Math.ceil(bounds.height) + _px;
										override[_margin] =
											override[_margin + _Top] =
											override[_margin + _Right] =
											override[_margin + _Bottom] =
											override[_margin + _Left] =
												"0";
										override[_padding] = cs[_padding];
										override[_padding + _Top] = cs[_padding + _Top];
										override[_padding + _Right] = cs[_padding + _Right];
										override[_padding + _Bottom] = cs[_padding + _Bottom];
										override[_padding + _Left] = cs[_padding + _Left];
										pinActiveState = _copyState(
											pinOriginalState,
											override,
											pinReparent
										);
									}
									if (animation) {
										initted = animation._initted;
										_suppressOverwrites(1);
										animation.render(animation.duration(), true, true);
										pinChange =
											pinGetter(direction.a) -
											pinStart +
											change +
											otherPinOffset;
										change !== pinChange &&
											pinActiveState.splice(pinActiveState.length - 2, 2);
										animation.render(0, true, true);
										initted || animation.invalidate();
										_suppressOverwrites(0);
									} else {
										pinChange = change;
									}
								} else if (trigger && scrollFunc() && !containerAnimation) {
									bounds = trigger.parentNode;
									while (bounds && bounds !== _body) {
										if (bounds._pinOffset) {
											start -= bounds._pinOffset;
											end -= bounds._pinOffset;
										}
										bounds = bounds.parentNode;
									}
								}
								revertedPins &&
									revertedPins.forEach(function (t) {
										return t.revert(false);
									});
								self.start = start;
								self.end = end;
								scroll1 = scroll2 = scrollFunc();
								if (!containerAnimation) {
									scroll1 < prevScroll && scrollFunc(prevScroll);
									self.scroll.rec = 0;
								}
								self.revert(false);
								_refreshing = 0;
								animation &&
									isToggle &&
									animation._initted &&
									animation.progress() !== prevAnimProgress &&
									animation
										.progress(prevAnimProgress, true)
										.render(animation.time(), true, true);
								if (prevProgress !== self.progress) {
									animation &&
										!isToggle &&
										animation.totalProgress(prevProgress, true);
									self.progress = prevProgress;
									self.update(0, 0, 1);
								}
								pin &&
									pinSpacing &&
									(spacer._pinOffset = Math.round(self.progress * pinChange));
								onRefresh && onRefresh(self);
							};
							self.getVelocity = function () {
								return (
									((scrollFunc() - scroll2) / (_getTime() - _time2)) * 1e3 || 0
								);
							};
							self.endAnimation = function () {
								_endAnimation(self.callbackAnimation);
								if (animation) {
									scrubTween
										? scrubTween.progress(1)
										: !animation.paused()
										? _endAnimation(animation, animation.reversed())
										: isToggle ||
										  _endAnimation(animation, self.direction < 0, 1);
								}
							};
							self.getTrailing = function (name) {
								var i = _triggers.indexOf(self),
									a =
										self.direction > 0
											? _triggers.slice(0, i).reverse()
											: _triggers.slice(i + 1);
								return _isString(name)
									? a.filter(function (t) {
											return t.vars.preventOverlaps === name;
									  })
									: a;
							};
							self.update = function (reset, recordVelocity, forceFake) {
								if (containerAnimation && !forceFake && !reset) {
									return;
								}
								var scroll = self.scroll(),
									p = reset ? 0 : (scroll - start) / change,
									clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
									prevProgress = self.progress,
									isActive,
									wasActive,
									toggleState,
									action,
									stateChanged,
									toggled,
									isAtMax,
									isTakingAction;
								if (recordVelocity) {
									scroll2 = scroll1;
									scroll1 = containerAnimation ? scrollFunc() : scroll;
									if (snap) {
										snap2 = snap1;
										snap1 =
											animation && !isToggle
												? animation.totalProgress()
												: clipped;
									}
								}
								anticipatePin &&
									!clipped &&
									pin &&
									!_refreshing &&
									!_startup &&
									_lastScrollTime &&
									start <
										scroll +
											((scroll - scroll2) / (_getTime() - _time2)) *
												anticipatePin &&
									(clipped = 1e-4);
								if (clipped !== prevProgress && self.enabled) {
									isActive = self.isActive = !!clipped && clipped < 1;
									wasActive = !!prevProgress && prevProgress < 1;
									toggled = isActive !== wasActive;
									stateChanged = toggled || !!clipped !== !!prevProgress;
									self.direction = clipped > prevProgress ? 1 : -1;
									self.progress = clipped;
									if (stateChanged && !_refreshing) {
										toggleState =
											clipped && !prevProgress
												? 0
												: clipped === 1
												? 1
												: prevProgress === 1
												? 2
												: 3;
										if (isToggle) {
											action =
												(!toggled &&
													toggleActions[toggleState + 1] !== "none" &&
													toggleActions[toggleState + 1]) ||
												toggleActions[toggleState];
											isTakingAction =
												animation &&
												(action === "complete" ||
													action === "reset" ||
													action in animation);
										}
									}
									preventOverlaps &&
										toggled &&
										(isTakingAction || scrub || !animation) &&
										(_isFunction(preventOverlaps)
											? preventOverlaps(self)
											: self.getTrailing(preventOverlaps).forEach(function (t) {
													return t.endAnimation();
											  }));
									if (!isToggle) {
										if (scrubTween && !_refreshing && !_startup) {
											scrubTween.vars.totalProgress = clipped;
											scrubTween.invalidate().restart();
										} else if (animation) {
											animation.totalProgress(clipped, !!_refreshing);
										}
									}
									if (pin) {
										reset &&
											pinSpacing &&
											(spacer.style[pinSpacing + direction.os2] = spacingStart);
										if (!useFixedPosition) {
											pinSetter(pinStart + pinChange * clipped);
										} else if (stateChanged) {
											isAtMax =
												!reset &&
												clipped > prevProgress &&
												end + 1 > scroll &&
												scroll + 1 >= _maxScroll(scroller, direction);
											if (pinReparent) {
												if (!reset && (isActive || isAtMax)) {
													var bounds = _getBounds(pin, true),
														_offset = scroll - start;
													_reparent(
														pin,
														_body,
														bounds.top +
															(direction === _vertical ? _offset : 0) +
															_px,
														bounds.left +
															(direction === _vertical ? 0 : _offset) +
															_px
													);
												} else {
													_reparent(pin, spacer);
												}
											}
											_setState(
												isActive || isAtMax ? pinActiveState : pinState
											);
											(pinChange !== change && clipped < 1 && isActive) ||
												pinSetter(
													pinStart + (clipped === 1 && !isAtMax ? pinChange : 0)
												);
										}
									}
									snap &&
										!tweenTo.tween &&
										!_refreshing &&
										!_startup &&
										snapDelayedCall.restart(true);
									toggleClass &&
										(toggled ||
											(once && clipped && (clipped < 1 || !_limitCallbacks))) &&
										_toArray(toggleClass.targets).forEach(function (el) {
											return el.classList[isActive || once ? "add" : "remove"](
												toggleClass.className
											);
										});
									onUpdate && !isToggle && !reset && onUpdate(self);
									if (stateChanged && !_refreshing) {
										if (isToggle) {
											if (isTakingAction) {
												if (action === "complete") {
													animation.pause().totalProgress(1);
												} else if (action === "reset") {
													animation.restart(true).pause();
												} else if (action === "restart") {
													animation.restart(true);
												} else {
													animation[action]();
												}
											}
											onUpdate && onUpdate(self);
										}
										if (toggled || !_limitCallbacks) {
											onToggle && toggled && _callback(self, onToggle);
											callbacks[toggleState] &&
												_callback(self, callbacks[toggleState]);
											once &&
												(clipped === 1
													? self.kill(false, 1)
													: (callbacks[toggleState] = 0));
											if (!toggled) {
												toggleState = clipped === 1 ? 1 : 3;
												callbacks[toggleState] &&
													_callback(self, callbacks[toggleState]);
											}
										}
										if (
											fastScrollEnd &&
											!isActive &&
											Math.abs(self.getVelocity()) >
												(_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)
										) {
											_endAnimation(self.callbackAnimation);
											scrubTween
												? scrubTween.progress(1)
												: _endAnimation(animation, !clipped, 1);
										}
									} else if (isToggle && onUpdate && !_refreshing) {
										onUpdate(self);
									}
								}
								if (markerEndSetter) {
									var n = containerAnimation
										? (scroll / containerAnimation.duration()) *
										  (containerAnimation._caScrollDist || 0)
										: scroll;
									markerStartSetter(
										n + (markerStartTrigger._isFlipped ? 1 : 0)
									);
									markerEndSetter(n);
								}
								caMarkerSetter &&
									caMarkerSetter(
										(-scroll / containerAnimation.duration()) *
											(containerAnimation._caScrollDist || 0)
									);
							};
							self.enable = function (reset, refresh) {
								if (!self.enabled) {
									self.enabled = true;
									_addListener(scroller, "resize", _onResize);
									_addListener(scroller, "scroll", _onScroll);
									onRefreshInit &&
										_addListener(ScrollTrigger, "refreshInit", onRefreshInit);
									if (reset !== false) {
										self.progress = prevProgress = 0;
										scroll1 = scroll2 = lastSnap = scrollFunc();
									}
									refresh !== false && self.refresh();
								}
							};
							self.getTween = function (snap) {
								return snap && tweenTo ? tweenTo.tween : scrubTween;
							};
							self.disable = function (reset, allowAnimation) {
								if (self.enabled) {
									reset !== false && self.revert();
									self.enabled = self.isActive = false;
									allowAnimation || (scrubTween && scrubTween.pause());
									prevScroll = 0;
									pinCache && (pinCache.uncache = 1);
									onRefreshInit &&
										_removeListener(
											ScrollTrigger,
											"refreshInit",
											onRefreshInit
										);
									if (snapDelayedCall) {
										snapDelayedCall.pause();
										tweenTo.tween &&
											tweenTo.tween.kill() &&
											(tweenTo.tween = 0);
									}
									if (!isViewport) {
										var i = _triggers.length;
										while (i--) {
											if (
												_triggers[i].scroller === scroller &&
												_triggers[i] !== self
											) {
												return;
											}
										}
										_removeListener(scroller, "resize", _onResize);
										_removeListener(scroller, "scroll", _onScroll);
									}
								}
							};
							self.kill = function (revert, allowAnimation) {
								self.disable(revert, allowAnimation);
								scrubTween && scrubTween.kill();
								id && delete _ids[id];
								var i = _triggers.indexOf(self);
								_triggers.splice(i, 1);
								i === _i && _direction > 0 && _i--;
								i = 0;
								_triggers.forEach(function (t) {
									return t.scroller === self.scroller && (i = 1);
								});
								i || (self.scroll.rec = 0);
								if (animation) {
									animation.scrollTrigger = null;
									revert && animation.render(-1);
									allowAnimation || animation.kill();
								}
								markerStart &&
									[
										markerStart,
										markerEnd,
										markerStartTrigger,
										markerEndTrigger,
									].forEach(function (m) {
										return m.parentNode && m.parentNode.removeChild(m);
									});
								if (pin) {
									pinCache && (pinCache.uncache = 1);
									i = 0;
									_triggers.forEach(function (t) {
										return t.pin === pin && i++;
									});
									i || (pinCache.spacer = 0);
								}
							};
							self.enable(false, false);
							!animation || !animation.add || change
								? self.refresh()
								: gsap.delayedCall(0.01, function () {
										return start || end || self.refresh();
								  }) &&
								  (change = 0.01) &&
								  (start = end = 0);
						};
						ScrollTrigger.register = function register(core) {
							if (!_coreInitted) {
								gsap = core || _getGSAP();
								if (_windowExists() && window.document) {
									_win = window;
									_doc = document;
									_docEl = _doc.documentElement;
									_body = _doc.body;
								}
								if (gsap) {
									_toArray = gsap.utils.toArray;
									_clamp = gsap.utils.clamp;
									_suppressOverwrites =
										gsap.core.suppressOverwrites || _passThrough;
									gsap.core.globals("ScrollTrigger", ScrollTrigger);
									if (_body) {
										_raf =
											_win.requestAnimationFrame ||
											function (f) {
												return setTimeout(f, 16);
											};
										_addListener(_win, "wheel", _onScroll);
										_root = [_win, _doc, _docEl, _body];
										_addListener(_doc, "scroll", _onScroll);
										var bodyStyle = _body.style,
											border = bodyStyle.borderTopStyle,
											bounds;
										bodyStyle.borderTopStyle = "solid";
										bounds = _getBounds(_body);
										_vertical.m = Math.round(bounds.top + _vertical.sc()) || 0;
										_horizontal.m =
											Math.round(bounds.left + _horizontal.sc()) || 0;
										border
											? (bodyStyle.borderTopStyle = border)
											: bodyStyle.removeProperty("border-top-style");
										_syncInterval = setInterval(_sync, 200);
										gsap.delayedCall(0.5, function () {
											return (_startup = 0);
										});
										_addListener(_doc, "touchcancel", _passThrough);
										_addListener(_body, "touchstart", _passThrough);
										_multiListener(
											_addListener,
											_doc,
											"pointerdown,touchstart,mousedown",
											function () {
												return (_pointerIsDown = 1);
											}
										);
										_multiListener(
											_addListener,
											_doc,
											"pointerup,touchend,mouseup",
											function () {
												return (_pointerIsDown = 0);
											}
										);
										_transformProp = gsap.utils.checkPrefix("transform");
										_stateProps.push(_transformProp);
										_coreInitted = _getTime();
										_resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();
										_autoRefresh = [
											_doc,
											"visibilitychange",
											function () {
												var w = _win.innerWidth,
													h = _win.innerHeight;
												if (_doc.hidden) {
													_prevWidth = w;
													_prevHeight = h;
												} else if (_prevWidth !== w || _prevHeight !== h) {
													_onResize();
												}
											},
											_doc,
											"DOMContentLoaded",
											_refreshAll,
											_win,
											"load",
											function () {
												return _lastScrollTime || _refreshAll();
											},
											_win,
											"resize",
											_onResize,
										];
										_iterateAutoRefresh(_addListener);
									}
								}
							}
							return _coreInitted;
						};
						ScrollTrigger.defaults = function defaults(config) {
							for (var p in config) {
								_defaults[p] = config[p];
							}
						};
						ScrollTrigger.kill = function kill() {
							_enabled = 0;
							_triggers.slice(0).forEach(function (trigger) {
								return trigger.kill(1);
							});
						};
						ScrollTrigger.config = function config(vars) {
							"limitCallbacks" in vars &&
								(_limitCallbacks = !!vars.limitCallbacks);
							var ms = vars.syncInterval;
							(ms && clearInterval(_syncInterval)) ||
								((_syncInterval = ms) && setInterval(_sync, ms));
							if ("autoRefreshEvents" in vars) {
								_iterateAutoRefresh(_removeListener) ||
									_iterateAutoRefresh(
										_addListener,
										vars.autoRefreshEvents || "none"
									);
								_ignoreResize =
									(vars.autoRefreshEvents + "").indexOf("resize") === -1;
							}
						};
						ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
							var t = _getTarget(target),
								i = _scrollers.indexOf(t),
								isViewport = _isViewport(t);
							if (~i) {
								_scrollers.splice(i, isViewport ? 6 : 2);
							}
							isViewport
								? _proxies.unshift(_win, vars, _body, vars, _docEl, vars)
								: _proxies.unshift(t, vars);
						};
						ScrollTrigger.matchMedia = function matchMedia(vars) {
							var mq, p, i, func, result;
							for (p in vars) {
								i = _media.indexOf(p);
								func = vars[p];
								_creatingMedia = p;
								if (p === "all") {
									func();
								} else {
									mq = _win.matchMedia(p);
									if (mq) {
										mq.matches && (result = func());
										if (~i) {
											_media[i + 1] = _combineFunc(_media[i + 1], func);
											_media[i + 2] = _combineFunc(_media[i + 2], result);
										} else {
											i = _media.length;
											_media.push(p, func, result);
											mq.addListener
												? mq.addListener(_onMediaChange)
												: mq.addEventListener("change", _onMediaChange);
										}
										_media[i + 3] = mq.matches;
									}
								}
								_creatingMedia = 0;
							}
							return _media;
						};
						ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
							query || (_media.length = 0);
							query = _media.indexOf(query);
							query >= 0 && _media.splice(query, 4);
						};
						ScrollTrigger.isInViewport = function isInViewport(
							element,
							ratio,
							horizontal
						) {
							var bounds = (
									_isString(element) ? _getTarget(element) : element
								).getBoundingClientRect(),
								offset = bounds[horizontal ? _width : _height] * ratio || 0;
							return horizontal
								? bounds.right - offset > 0 &&
										bounds.left + offset < _win.innerWidth
								: bounds.bottom - offset > 0 &&
										bounds.top + offset < _win.innerHeight;
						};
						ScrollTrigger.positionInViewport = function positionInViewport(
							element,
							referencePoint,
							horizontal
						) {
							_isString(element) && (element = _getTarget(element));
							var bounds = element.getBoundingClientRect(),
								size = bounds[horizontal ? _width : _height],
								offset =
									referencePoint == null
										? size / 2
										: referencePoint in _keywords
										? _keywords[referencePoint] * size
										: ~referencePoint.indexOf("%")
										? (parseFloat(referencePoint) * size) / 100
										: parseFloat(referencePoint) || 0;
							return horizontal
								? (bounds.left + offset) / _win.innerWidth
								: (bounds.top + offset) / _win.innerHeight;
						};
						return ScrollTrigger;
					})();
					ScrollTrigger.version = "3.8.0";
					ScrollTrigger.saveStyles = function (targets) {
						return targets
							? _toArray(targets).forEach(function (target) {
									if (target && target.style) {
										var i = _savedStyles.indexOf(target);
										i >= 0 && _savedStyles.splice(i, 5);
										_savedStyles.push(
											target,
											target.style.cssText,
											target.getBBox && target.getAttribute("transform"),
											gsap.core.getCache(target),
											_creatingMedia
										);
									}
							  })
							: _savedStyles;
					};
					ScrollTrigger.revert = function (soft, media) {
						return _revertAll(!soft, media);
					};
					ScrollTrigger.create = function (vars, animation) {
						return new ScrollTrigger(vars, animation);
					};
					ScrollTrigger.refresh = function (safe) {
						return safe
							? _onResize()
							: (_coreInitted || ScrollTrigger.register()) && _refreshAll(true);
					};
					ScrollTrigger.update = _updateAll;
					ScrollTrigger.clearScrollMemory = _clearScrollMemory;
					ScrollTrigger.maxScroll = function (element, horizontal) {
						return _maxScroll(element, horizontal ? _horizontal : _vertical);
					};
					ScrollTrigger.getScrollFunc = function (element, horizontal) {
						return _getScrollFunc(
							_getTarget(element),
							horizontal ? _horizontal : _vertical
						);
					};
					ScrollTrigger.getById = function (id) {
						return _ids[id];
					};
					ScrollTrigger.getAll = function () {
						return _triggers.slice(0);
					};
					ScrollTrigger.isScrolling = function () {
						return !!_lastScrollTime;
					};
					ScrollTrigger.snapDirectional = _snapDirectional;
					ScrollTrigger.addEventListener = function (type, callback) {
						var a = _listeners[type] || (_listeners[type] = []);
						~a.indexOf(callback) || a.push(callback);
					};
					ScrollTrigger.removeEventListener = function (type, callback) {
						var a = _listeners[type],
							i = a && a.indexOf(callback);
						i >= 0 && a.splice(i, 1);
					};
					ScrollTrigger.batch = function (targets, vars) {
						var result = [],
							varsCopy = {},
							interval = vars.interval || 0.016,
							batchMax = vars.batchMax || 1e9,
							proxyCallback = function proxyCallback(type, callback) {
								var elements = [],
									triggers = [],
									delay = gsap
										.delayedCall(interval, function () {
											callback(elements, triggers);
											elements = [];
											triggers = [];
										})
										.pause();
								return function (self) {
									elements.length || delay.restart(true);
									elements.push(self.trigger);
									triggers.push(self);
									batchMax <= elements.length && delay.progress(1);
								};
							},
							p;
						for (p in vars) {
							varsCopy[p] =
								p.substr(0, 2) === "on" &&
								_isFunction(vars[p]) &&
								p !== "onRefreshInit"
									? proxyCallback(p, vars[p])
									: vars[p];
						}
						if (_isFunction(batchMax)) {
							batchMax = batchMax();
							_addListener(ScrollTrigger, "refresh", function () {
								return (batchMax = vars.batchMax());
							});
						}
						_toArray(targets).forEach(function (target) {
							var config = {};
							for (p in varsCopy) {
								config[p] = varsCopy[p];
							}
							config.trigger = target;
							result.push(ScrollTrigger.create(config));
						});
						return result;
					};
					ScrollTrigger.sort = function (func) {
						return _triggers.sort(
							func ||
								function (a, b) {
									return (
										(a.vars.refreshPriority || 0) * -1e6 +
										a.start -
										(b.start + (b.vars.refreshPriority || 0) * -1e6)
									);
								}
						);
					};
					_getGSAP() && gsap.registerPlugin(ScrollTrigger);
					exports.ScrollTrigger = ScrollTrigger;
					exports.default = ScrollTrigger;
					Object.defineProperty(exports, "__esModule", { value: true });
				});
			},
			{},
		],
		6: [
			function (require, module, exports) {
				(function (global, factory) {
					typeof exports === "object" && typeof module !== "undefined"
						? factory(exports)
						: typeof define === "function" && define.amd
						? define(["exports"], factory)
						: ((global = global || self),
						  factory((global.window = global.window || {})));
				})(this, function (exports) {
					"use strict";
					var _trimExp = /(^\s+|\s+$)/g;
					var emojiExp =
						/([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
					function getText(e) {
						var type = e.nodeType,
							result = "";
						if (type === 1 || type === 9 || type === 11) {
							if (typeof e.textContent === "string") {
								return e.textContent;
							} else {
								for (e = e.firstChild; e; e = e.nextSibling) {
									result += getText(e);
								}
							}
						} else if (type === 3 || type === 4) {
							return e.nodeValue;
						}
						return result;
					}
					function splitInnerHTML(element, delimiter, trim, preserveSpaces) {
						var node = element.firstChild,
							result = [],
							s;
						while (node) {
							if (node.nodeType === 3) {
								s = (node.nodeValue + "").replace(/^\n+/g, "");
								if (!preserveSpaces) {
									s = s.replace(/\s+/g, " ");
								}
								result.push.apply(
									result,
									emojiSafeSplit(s, delimiter, trim, preserveSpaces)
								);
							} else if ((node.nodeName + "").toLowerCase() === "br") {
								result[result.length - 1] += "<br>";
							} else {
								result.push(node.outerHTML);
							}
							node = node.nextSibling;
						}
						return result;
					}
					function emojiSafeSplit(text, delimiter, trim, preserveSpaces) {
						text += "";
						if (trim) {
							text = text.replace(_trimExp, "");
						}
						if (delimiter && delimiter !== "") {
							return text
								.replace(/>/g, "&gt;")
								.replace(/</g, "&lt;")
								.split(delimiter);
						}
						var result = [],
							l = text.length,
							i = 0,
							j,
							character;
						for (; i < l; i++) {
							character = text.charAt(i);
							if (
								(character.charCodeAt(0) >= 55296 &&
									character.charCodeAt(0) <= 56319) ||
								(text.charCodeAt(i + 1) >= 65024 &&
									text.charCodeAt(i + 1) <= 65039)
							) {
								j =
									((text.substr(i, 12).split(emojiExp) || [])[1] || "")
										.length || 2;
								character = text.substr(i, j);
								result.emoji = 1;
								i += j - 1;
							}
							result.push(
								character === ">"
									? "&gt;"
									: character === "<"
									? "&lt;"
									: preserveSpaces &&
									  character === " " &&
									  (text.charAt(i - 1) === " " || text.charAt(i + 1) === " ")
									? "&nbsp;"
									: character
							);
						}
						return result;
					}
					var gsap,
						_tempDiv,
						_getGSAP = function _getGSAP() {
							return (
								gsap ||
								(typeof window !== "undefined" &&
									(gsap = window.gsap) &&
									gsap.registerPlugin &&
									gsap)
							);
						};
					var TextPlugin = {
						version: "3.8.0",
						name: "text",
						init: function init(target, value, tween) {
							var i = target.nodeName.toUpperCase(),
								data = this,
								_short,
								text,
								original,
								j,
								condensedText,
								condensedOriginal,
								aggregate,
								s;
							data.svg = target.getBBox && (i === "TEXT" || i === "TSPAN");
							if (!("innerHTML" in target) && !data.svg) {
								return false;
							}
							data.target = target;
							if (typeof value !== "object") {
								value = { value: value };
							}
							if (!("value" in value)) {
								data.text = data.original = [""];
								return;
							}
							data.delimiter = value.delimiter || "";
							original = splitInnerHTML(
								target,
								data.delimiter,
								false,
								value.preserveSpaces
							);
							if (!_tempDiv) {
								_tempDiv = document.createElement("div");
							}
							_tempDiv.innerHTML = value.value;
							text = splitInnerHTML(_tempDiv, data.delimiter);
							data.from = tween._from;
							if (data.from) {
								i = original;
								original = text;
								text = i;
							}
							data.hasClass = !!(value.newClass || value.oldClass);
							data.newClass = value.newClass;
							data.oldClass = value.oldClass;
							i = original.length - text.length;
							_short = i < 0 ? original : text;
							data.fillChar =
								value.fillChar || (value.padSpace ? "&nbsp;" : "");
							if (i < 0) {
								i = -i;
							}
							while (--i > -1) {
								_short.push(data.fillChar);
							}
							if (value.type === "diff") {
								j = 0;
								condensedText = [];
								condensedOriginal = [];
								aggregate = "";
								for (i = 0; i < text.length; i++) {
									s = text[i];
									if (s === original[i]) {
										aggregate += s;
									} else {
										condensedText[j] = aggregate + s;
										condensedOriginal[j++] = aggregate + original[i];
										aggregate = "";
									}
								}
								text = condensedText;
								original = condensedOriginal;
								if (aggregate) {
									text.push(aggregate);
									original.push(aggregate);
								}
							}
							if (value.speed) {
								tween.duration(
									Math.min(
										(0.05 / value.speed) * _short.length,
										value.maxDuration || 9999
									)
								);
							}
							this.original = original;
							this.text = text;
							this._props.push("text");
						},
						render: function render(ratio, data) {
							if (ratio > 1) {
								ratio = 1;
							} else if (ratio < 0) {
								ratio = 0;
							}
							if (data.from) {
								ratio = 1 - ratio;
							}
							var text = data.text,
								hasClass = data.hasClass,
								newClass = data.newClass,
								oldClass = data.oldClass,
								delimiter = data.delimiter,
								target = data.target,
								fillChar = data.fillChar,
								original = data.original,
								l = text.length,
								i = (ratio * l + 0.5) | 0,
								applyNew,
								applyOld,
								str;
							if (hasClass) {
								applyNew = newClass && i;
								applyOld = oldClass && i !== l;
								str =
									(applyNew ? "<span class='" + newClass + "'>" : "") +
									text.slice(0, i).join(delimiter) +
									(applyNew ? "</span>" : "") +
									(applyOld ? "<span class='" + oldClass + "'>" : "") +
									delimiter +
									original.slice(i).join(delimiter) +
									(applyOld ? "</span>" : "");
							} else {
								str =
									text.slice(0, i).join(delimiter) +
									delimiter +
									original.slice(i).join(delimiter);
							}
							if (data.svg) {
								target.textContent = str;
							} else {
								target.innerHTML =
									fillChar === "&nbsp;" && ~str.indexOf("  ")
										? str.split("  ").join("&nbsp;&nbsp;")
										: str;
							}
						},
					};
					TextPlugin.splitInnerHTML = splitInnerHTML;
					TextPlugin.emojiSafeSplit = emojiSafeSplit;
					TextPlugin.getText = getText;
					_getGSAP() && gsap.registerPlugin(TextPlugin);
					exports.TextPlugin = TextPlugin;
					exports.default = TextPlugin;
					Object.defineProperty(exports, "__esModule", { value: true });
				});
			},
			{},
		],
		7: [
			function (require, module, exports) {
				(function (global, factory) {
					typeof exports === "object" && typeof module !== "undefined"
						? factory(exports)
						: typeof define === "function" && define.amd
						? define(["exports"], factory)
						: ((global = global || self),
						  factory((global.window = global.window || {})));
				})(this, function (exports) {
					"use strict";
					function _inheritsLoose(subClass, superClass) {
						subClass.prototype = Object.create(superClass.prototype);
						subClass.prototype.constructor = subClass;
						subClass.__proto__ = superClass;
					}
					function _assertThisInitialized(self) {
						if (self === void 0) {
							throw new ReferenceError(
								"this hasn't been initialised - super() hasn't been called"
							);
						}
						return self;
					}
					var _config = {
							autoSleep: 120,
							force3D: "auto",
							nullTargetWarn: 1,
							units: { lineHeight: "" },
						},
						_defaults = { duration: 0.5, overwrite: false, delay: 0 },
						_suppressOverwrites,
						_bigNum = 1e8,
						_tinyNum = 1 / _bigNum,
						_2PI = Math.PI * 2,
						_HALF_PI = _2PI / 4,
						_gsID = 0,
						_sqrt = Math.sqrt,
						_cos = Math.cos,
						_sin = Math.sin,
						_isString = function _isString(value) {
							return typeof value === "string";
						},
						_isFunction = function _isFunction(value) {
							return typeof value === "function";
						},
						_isNumber = function _isNumber(value) {
							return typeof value === "number";
						},
						_isUndefined = function _isUndefined(value) {
							return typeof value === "undefined";
						},
						_isObject = function _isObject(value) {
							return typeof value === "object";
						},
						_isNotFalse = function _isNotFalse(value) {
							return value !== false;
						},
						_windowExists = function _windowExists() {
							return typeof window !== "undefined";
						},
						_isFuncOrString = function _isFuncOrString(value) {
							return _isFunction(value) || _isString(value);
						},
						_isTypedArray =
							(typeof ArrayBuffer === "function" && ArrayBuffer.isView) ||
							function () {},
						_isArray = Array.isArray,
						_strictNumExp = /(?:-?\.?\d|\.)+/gi,
						_numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
						_numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
						_complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
						_relExp = /[+-]=-?[.\d]+/,
						_delimitedValueExp = /[^,'"\[\]\s]+/gi,
						_unitExp = /[\d.+\-=]+(?:e[-+]\d*)*/i,
						_globalTimeline,
						_win,
						_coreInitted,
						_doc,
						_globals = {},
						_installScope = {},
						_coreReady,
						_install = function _install(scope) {
							return (_installScope = _merge(scope, _globals)) && gsap;
						},
						_missingPlugin = function _missingPlugin(property, value) {
							return console.warn(
								"Invalid property",
								property,
								"set to",
								value,
								"Missing plugin? gsap.registerPlugin()"
							);
						},
						_warn = function _warn(message, suppress) {
							return !suppress && console.warn(message);
						},
						_addGlobal = function _addGlobal(name, obj) {
							return (
								(name &&
									(_globals[name] = obj) &&
									_installScope &&
									(_installScope[name] = obj)) ||
								_globals
							);
						},
						_emptyFunc = function _emptyFunc() {
							return 0;
						},
						_reservedProps = {},
						_lazyTweens = [],
						_lazyLookup = {},
						_lastRenderedFrame,
						_plugins = {},
						_effects = {},
						_nextGCFrame = 30,
						_harnessPlugins = [],
						_callbackNames = "",
						_harness = function _harness(targets) {
							var target = targets[0],
								harnessPlugin,
								i;
							_isObject(target) || _isFunction(target) || (targets = [targets]);
							if (!(harnessPlugin = (target._gsap || {}).harness)) {
								i = _harnessPlugins.length;
								while (i-- && !_harnessPlugins[i].targetTest(target)) {}
								harnessPlugin = _harnessPlugins[i];
							}
							i = targets.length;
							while (i--) {
								(targets[i] &&
									(targets[i]._gsap ||
										(targets[i]._gsap = new GSCache(
											targets[i],
											harnessPlugin
										)))) ||
									targets.splice(i, 1);
							}
							return targets;
						},
						_getCache = function _getCache(target) {
							return target._gsap || _harness(toArray(target))[0]._gsap;
						},
						_getProperty = function _getProperty(target, property, v) {
							return (v = target[property]) && _isFunction(v)
								? target[property]()
								: (_isUndefined(v) &&
										target.getAttribute &&
										target.getAttribute(property)) ||
										v;
						},
						_forEachName = function _forEachName(names, func) {
							return (names = names.split(",")).forEach(func) || names;
						},
						_round = function _round(value) {
							return Math.round(value * 1e5) / 1e5 || 0;
						},
						_roundPrecise = function _roundPrecise(value) {
							return Math.round(value * 1e7) / 1e7 || 0;
						},
						_arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
							var l = toFind.length,
								i = 0;
							for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l; ) {}
							return i < l;
						},
						_lazyRender = function _lazyRender() {
							var l = _lazyTweens.length,
								a = _lazyTweens.slice(0),
								i,
								tween;
							_lazyLookup = {};
							_lazyTweens.length = 0;
							for (i = 0; i < l; i++) {
								tween = a[i];
								tween &&
									tween._lazy &&
									(tween.render(
										tween._lazy[0],
										tween._lazy[1],
										true
									)._lazy = 0);
							}
						},
						_lazySafeRender = function _lazySafeRender(
							animation,
							time,
							suppressEvents,
							force
						) {
							_lazyTweens.length && _lazyRender();
							animation.render(time, suppressEvents, force);
							_lazyTweens.length && _lazyRender();
						},
						_numericIfPossible = function _numericIfPossible(value) {
							var n = parseFloat(value);
							return (n || n === 0) &&
								(value + "").match(_delimitedValueExp).length < 2
								? n
								: _isString(value)
								? value.trim()
								: value;
						},
						_passThrough = function _passThrough(p) {
							return p;
						},
						_setDefaults = function _setDefaults(obj, defaults) {
							for (var p in defaults) {
								p in obj || (obj[p] = defaults[p]);
							}
							return obj;
						},
						_setKeyframeDefaults = function _setKeyframeDefaults(
							obj,
							defaults
						) {
							for (var p in defaults) {
								p in obj ||
									p === "duration" ||
									p === "ease" ||
									(obj[p] = defaults[p]);
							}
						},
						_merge = function _merge(base, toMerge) {
							for (var p in toMerge) {
								base[p] = toMerge[p];
							}
							return base;
						},
						_mergeDeep = function _mergeDeep(base, toMerge) {
							for (var p in toMerge) {
								p !== "__proto__" &&
									p !== "constructor" &&
									p !== "prototype" &&
									(base[p] = _isObject(toMerge[p])
										? _mergeDeep(base[p] || (base[p] = {}), toMerge[p])
										: toMerge[p]);
							}
							return base;
						},
						_copyExcluding = function _copyExcluding(obj, excluding) {
							var copy = {},
								p;
							for (p in obj) {
								p in excluding || (copy[p] = obj[p]);
							}
							return copy;
						},
						_inheritDefaults = function _inheritDefaults(vars) {
							var parent = vars.parent || _globalTimeline,
								func = vars.keyframes ? _setKeyframeDefaults : _setDefaults;
							if (_isNotFalse(vars.inherit)) {
								while (parent) {
									func(vars, parent.vars.defaults);
									parent = parent.parent || parent._dp;
								}
							}
							return vars;
						},
						_arraysMatch = function _arraysMatch(a1, a2) {
							var i = a1.length,
								match = i === a2.length;
							while (match && i-- && a1[i] === a2[i]) {}
							return i < 0;
						},
						_addLinkedListItem = function _addLinkedListItem(
							parent,
							child,
							firstProp,
							lastProp,
							sortBy
						) {
							if (firstProp === void 0) {
								firstProp = "_first";
							}
							if (lastProp === void 0) {
								lastProp = "_last";
							}
							var prev = parent[lastProp],
								t;
							if (sortBy) {
								t = child[sortBy];
								while (prev && prev[sortBy] > t) {
									prev = prev._prev;
								}
							}
							if (prev) {
								child._next = prev._next;
								prev._next = child;
							} else {
								child._next = parent[firstProp];
								parent[firstProp] = child;
							}
							if (child._next) {
								child._next._prev = child;
							} else {
								parent[lastProp] = child;
							}
							child._prev = prev;
							child.parent = child._dp = parent;
							return child;
						},
						_removeLinkedListItem = function _removeLinkedListItem(
							parent,
							child,
							firstProp,
							lastProp
						) {
							if (firstProp === void 0) {
								firstProp = "_first";
							}
							if (lastProp === void 0) {
								lastProp = "_last";
							}
							var prev = child._prev,
								next = child._next;
							if (prev) {
								prev._next = next;
							} else if (parent[firstProp] === child) {
								parent[firstProp] = next;
							}
							if (next) {
								next._prev = prev;
							} else if (parent[lastProp] === child) {
								parent[lastProp] = prev;
							}
							child._next = child._prev = child.parent = null;
						},
						_removeFromParent = function _removeFromParent(
							child,
							onlyIfParentHasAutoRemove
						) {
							child.parent &&
								(!onlyIfParentHasAutoRemove ||
									child.parent.autoRemoveChildren) &&
								child.parent.remove(child);
							child._act = 0;
						},
						_uncache = function _uncache(animation, child) {
							if (
								animation &&
								(!child || child._end > animation._dur || child._start < 0)
							) {
								var a = animation;
								while (a) {
									a._dirty = 1;
									a = a.parent;
								}
							}
							return animation;
						},
						_recacheAncestors = function _recacheAncestors(animation) {
							var parent = animation.parent;
							while (parent && parent.parent) {
								parent._dirty = 1;
								parent.totalDuration();
								parent = parent.parent;
							}
							return animation;
						},
						_hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
							return (
								!animation ||
								(animation._ts && _hasNoPausedAncestors(animation.parent))
							);
						},
						_elapsedCycleDuration = function _elapsedCycleDuration(animation) {
							return animation._repeat
								? _animationCycle(
										animation._tTime,
										(animation = animation.duration() + animation._rDelay)
								  ) * animation
								: 0;
						},
						_animationCycle = function _animationCycle(tTime, cycleDuration) {
							var whole = Math.floor((tTime /= cycleDuration));
							return tTime && whole === tTime ? whole - 1 : whole;
						},
						_parentToChildTotalTime = function _parentToChildTotalTime(
							parentTime,
							child
						) {
							return (
								(parentTime - child._start) * child._ts +
								(child._ts >= 0
									? 0
									: child._dirty
									? child.totalDuration()
									: child._tDur)
							);
						},
						_setEnd = function _setEnd(animation) {
							return (animation._end = _roundPrecise(
								animation._start +
									(animation._tDur /
										Math.abs(animation._ts || animation._rts || _tinyNum) || 0)
							));
						},
						_alignPlayhead = function _alignPlayhead(animation, totalTime) {
							var parent = animation._dp;
							if (parent && parent.smoothChildTiming && animation._ts) {
								animation._start = _roundPrecise(
									parent._time -
										(animation._ts > 0
											? totalTime / animation._ts
											: ((animation._dirty
													? animation.totalDuration()
													: animation._tDur) -
													totalTime) /
											  -animation._ts)
								);
								_setEnd(animation);
								parent._dirty || _uncache(parent, animation);
							}
							return animation;
						},
						_postAddChecks = function _postAddChecks(timeline, child) {
							var t;
							if (child._time || (child._initted && !child._dur)) {
								t = _parentToChildTotalTime(timeline.rawTime(), child);
								if (
									!child._dur ||
									_clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum
								) {
									child.render(t, true);
								}
							}
							if (
								_uncache(timeline, child)._dp &&
								timeline._initted &&
								timeline._time >= timeline._dur &&
								timeline._ts
							) {
								if (timeline._dur < timeline.duration()) {
									t = timeline;
									while (t._dp) {
										t.rawTime() >= 0 && t.totalTime(t._tTime);
										t = t._dp;
									}
								}
								timeline._zTime = -_tinyNum;
							}
						},
						_addToTimeline = function _addToTimeline(
							timeline,
							child,
							position,
							skipChecks
						) {
							child.parent && _removeFromParent(child);
							child._start = _roundPrecise(
								(_isNumber(position)
									? position
									: position || timeline !== _globalTimeline
									? _parsePosition(timeline, position, child)
									: timeline._time) + child._delay
							);
							child._end = _roundPrecise(
								child._start +
									(child.totalDuration() / Math.abs(child.timeScale()) || 0)
							);
							_addLinkedListItem(
								timeline,
								child,
								"_first",
								"_last",
								timeline._sort ? "_start" : 0
							);
							_isFromOrFromStart(child) || (timeline._recent = child);
							skipChecks || _postAddChecks(timeline, child);
							return timeline;
						},
						_scrollTrigger = function _scrollTrigger(animation, trigger) {
							return (
								(_globals.ScrollTrigger ||
									_missingPlugin("scrollTrigger", trigger)) &&
								_globals.ScrollTrigger.create(trigger, animation)
							);
						},
						_attemptInitTween = function _attemptInitTween(
							tween,
							totalTime,
							force,
							suppressEvents
						) {
							_initTween(tween, totalTime);
							if (!tween._initted) {
								return 1;
							}
							if (
								!force &&
								tween._pt &&
								((tween._dur && tween.vars.lazy !== false) ||
									(!tween._dur && tween.vars.lazy)) &&
								_lastRenderedFrame !== _ticker.frame
							) {
								_lazyTweens.push(tween);
								tween._lazy = [totalTime, suppressEvents];
								return 1;
							}
						},
						_parentPlayheadIsBeforeStart =
							function _parentPlayheadIsBeforeStart(_ref) {
								var parent = _ref.parent;
								return (
									parent &&
									parent._ts &&
									parent._initted &&
									!parent._lock &&
									(parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent))
								);
							},
						_isFromOrFromStart = function _isFromOrFromStart(_ref2) {
							var data = _ref2.data;
							return data === "isFromStart" || data === "isStart";
						},
						_renderZeroDurationTween = function _renderZeroDurationTween(
							tween,
							totalTime,
							suppressEvents,
							force
						) {
							var prevRatio = tween.ratio,
								ratio =
									totalTime < 0 ||
									(!totalTime &&
										((!tween._start &&
											_parentPlayheadIsBeforeStart(tween) &&
											!(!tween._initted && _isFromOrFromStart(tween))) ||
											((tween._ts < 0 || tween._dp._ts < 0) &&
												!_isFromOrFromStart(tween))))
										? 0
										: 1,
								repeatDelay = tween._rDelay,
								tTime = 0,
								pt,
								iteration,
								prevIteration;
							if (repeatDelay && tween._repeat) {
								tTime = _clamp(0, tween._tDur, totalTime);
								iteration = _animationCycle(tTime, repeatDelay);
								prevIteration = _animationCycle(tween._tTime, repeatDelay);
								tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
								if (iteration !== prevIteration) {
									prevRatio = 1 - ratio;
									tween.vars.repeatRefresh &&
										tween._initted &&
										tween.invalidate();
								}
							}
							if (
								ratio !== prevRatio ||
								force ||
								tween._zTime === _tinyNum ||
								(!totalTime && tween._zTime)
							) {
								if (
									!tween._initted &&
									_attemptInitTween(tween, totalTime, force, suppressEvents)
								) {
									return;
								}
								prevIteration = tween._zTime;
								tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
								suppressEvents ||
									(suppressEvents = totalTime && !prevIteration);
								tween.ratio = ratio;
								tween._from && (ratio = 1 - ratio);
								tween._time = 0;
								tween._tTime = tTime;
								pt = tween._pt;
								while (pt) {
									pt.r(ratio, pt.d);
									pt = pt._next;
								}
								tween._startAt &&
									totalTime < 0 &&
									tween._startAt.render(totalTime, true, true);
								tween._onUpdate &&
									!suppressEvents &&
									_callback(tween, "onUpdate");
								tTime &&
									tween._repeat &&
									!suppressEvents &&
									tween.parent &&
									_callback(tween, "onRepeat");
								if (
									(totalTime >= tween._tDur || totalTime < 0) &&
									tween.ratio === ratio
								) {
									ratio && _removeFromParent(tween, 1);
									if (!suppressEvents) {
										_callback(
											tween,
											ratio ? "onComplete" : "onReverseComplete",
											true
										);
										tween._prom && tween._prom();
									}
								}
							} else if (!tween._zTime) {
								tween._zTime = totalTime;
							}
						},
						_findNextPauseTween = function _findNextPauseTween(
							animation,
							prevTime,
							time
						) {
							var child;
							if (time > prevTime) {
								child = animation._first;
								while (child && child._start <= time) {
									if (
										!child._dur &&
										child.data === "isPause" &&
										child._start > prevTime
									) {
										return child;
									}
									child = child._next;
								}
							} else {
								child = animation._last;
								while (child && child._start >= time) {
									if (
										!child._dur &&
										child.data === "isPause" &&
										child._start < prevTime
									) {
										return child;
									}
									child = child._prev;
								}
							}
						},
						_setDuration = function _setDuration(
							animation,
							duration,
							skipUncache,
							leavePlayhead
						) {
							var repeat = animation._repeat,
								dur = _roundPrecise(duration) || 0,
								totalProgress = animation._tTime / animation._tDur;
							totalProgress &&
								!leavePlayhead &&
								(animation._time *= dur / animation._dur);
							animation._dur = dur;
							animation._tDur = !repeat
								? dur
								: repeat < 0
								? 1e10
								: _roundPrecise(
										dur * (repeat + 1) + animation._rDelay * repeat
								  );
							totalProgress && !leavePlayhead
								? _alignPlayhead(
										animation,
										(animation._tTime = animation._tDur * totalProgress)
								  )
								: animation.parent && _setEnd(animation);
							skipUncache || _uncache(animation.parent, animation);
							return animation;
						},
						_onUpdateTotalDuration = function _onUpdateTotalDuration(
							animation
						) {
							return animation instanceof Timeline
								? _uncache(animation)
								: _setDuration(animation, animation._dur);
						},
						_zeroPosition = {
							_start: 0,
							endTime: _emptyFunc,
							totalDuration: _emptyFunc,
						},
						_parsePosition = function _parsePosition(
							animation,
							position,
							percentAnimation
						) {
							var labels = animation.labels,
								recent = animation._recent || _zeroPosition,
								clippedDuration =
									animation.duration() >= _bigNum
										? recent.endTime(false)
										: animation._dur,
								i,
								offset,
								isPercent;
							if (
								_isString(position) &&
								(isNaN(position) || position in labels)
							) {
								offset = position.charAt(0);
								isPercent = position.substr(-1) === "%";
								i = position.indexOf("=");
								if (offset === "<" || offset === ">") {
									i >= 0 && (position = position.replace(/=/, ""));
									return (
										(offset === "<"
											? recent._start
											: recent.endTime(recent._repeat >= 0)) +
										(parseFloat(position.substr(1)) || 0) *
											(isPercent
												? (i < 0 ? recent : percentAnimation).totalDuration() /
												  100
												: 1)
									);
								}
								if (i < 0) {
									position in labels || (labels[position] = clippedDuration);
									return labels[position];
								}
								offset = parseFloat(
									position.charAt(i - 1) + position.substr(i + 1)
								);
								if (isPercent && percentAnimation) {
									offset =
										(offset / 100) *
										(_isArray(percentAnimation)
											? percentAnimation[0]
											: percentAnimation
										).totalDuration();
								}
								return i > 1
									? _parsePosition(
											animation,
											position.substr(0, i - 1),
											percentAnimation
									  ) + offset
									: clippedDuration + offset;
							}
							return position == null ? clippedDuration : +position;
						},
						_createTweenType = function _createTweenType(
							type,
							params,
							timeline
						) {
							var isLegacy = _isNumber(params[1]),
								varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
								vars = params[varsIndex],
								irVars,
								parent;
							isLegacy && (vars.duration = params[1]);
							vars.parent = timeline;
							if (type) {
								irVars = vars;
								parent = timeline;
								while (parent && !("immediateRender" in irVars)) {
									irVars = parent.vars.defaults || {};
									parent = _isNotFalse(parent.vars.inherit) && parent.parent;
								}
								vars.immediateRender = _isNotFalse(irVars.immediateRender);
								type < 2
									? (vars.runBackwards = 1)
									: (vars.startAt = params[varsIndex - 1]);
							}
							return new Tween(params[0], vars, params[varsIndex + 1]);
						},
						_conditionalReturn = function _conditionalReturn(value, func) {
							return value || value === 0 ? func(value) : func;
						},
						_clamp = function _clamp(min, max, value) {
							return value < min ? min : value > max ? max : value;
						},
						getUnit = function getUnit(value) {
							if (typeof value !== "string") {
								return "";
							}
							var v = _unitExp.exec(value);
							return v ? value.substr(v.index + v[0].length) : "";
						},
						clamp = function clamp(min, max, value) {
							return _conditionalReturn(value, function (v) {
								return _clamp(min, max, v);
							});
						},
						_slice = [].slice,
						_isArrayLike = function _isArrayLike(value, nonEmpty) {
							return (
								value &&
								_isObject(value) &&
								"length" in value &&
								((!nonEmpty && !value.length) ||
									(value.length - 1 in value && _isObject(value[0]))) &&
								!value.nodeType &&
								value !== _win
							);
						},
						_flatten = function _flatten(ar, leaveStrings, accumulator) {
							if (accumulator === void 0) {
								accumulator = [];
							}
							return (
								ar.forEach(function (value) {
									var _accumulator;
									return (_isString(value) && !leaveStrings) ||
										_isArrayLike(value, 1)
										? (_accumulator = accumulator).push.apply(
												_accumulator,
												toArray(value)
										  )
										: accumulator.push(value);
								}) || accumulator
							);
						},
						toArray = function toArray(value, scope, leaveStrings) {
							return _isString(value) &&
								!leaveStrings &&
								(_coreInitted || !_wake())
								? _slice.call((scope || _doc).querySelectorAll(value), 0)
								: _isArray(value)
								? _flatten(value, leaveStrings)
								: _isArrayLike(value)
								? _slice.call(value, 0)
								: value
								? [value]
								: [];
						},
						selector = function selector(value) {
							value = toArray(value)[0] || _warn("Invalid scope") || {};
							return function (v) {
								var el = value.current || value.nativeElement || value;
								return toArray(
									v,
									el.querySelectorAll
										? el
										: el === value
										? _warn("Invalid scope") || _doc.createElement("div")
										: value
								);
							};
						},
						shuffle = function shuffle(a) {
							return a.sort(function () {
								return 0.5 - Math.random();
							});
						},
						distribute = function distribute(v) {
							if (_isFunction(v)) {
								return v;
							}
							var vars = _isObject(v) ? v : { each: v },
								ease = _parseEase(vars.ease),
								from = vars.from || 0,
								base = parseFloat(vars.base) || 0,
								cache = {},
								isDecimal = from > 0 && from < 1,
								ratios = isNaN(from) || isDecimal,
								axis = vars.axis,
								ratioX = from,
								ratioY = from;
							if (_isString(from)) {
								ratioX = ratioY =
									{ center: 0.5, edges: 0.5, end: 1 }[from] || 0;
							} else if (!isDecimal && ratios) {
								ratioX = from[0];
								ratioY = from[1];
							}
							return function (i, target, a) {
								var l = (a || vars).length,
									distances = cache[l],
									originX,
									originY,
									x,
									y,
									d,
									j,
									max,
									min,
									wrapAt;
								if (!distances) {
									wrapAt =
										vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
									if (!wrapAt) {
										max = -_bigNum;
										while (
											max < (max = a[wrapAt++].getBoundingClientRect().left) &&
											wrapAt < l
										) {}
										wrapAt--;
									}
									distances = cache[l] = [];
									originX = ratios
										? Math.min(wrapAt, l) * ratioX - 0.5
										: from % wrapAt;
									originY = ratios
										? (l * ratioY) / wrapAt - 0.5
										: (from / wrapAt) | 0;
									max = 0;
									min = _bigNum;
									for (j = 0; j < l; j++) {
										x = (j % wrapAt) - originX;
										y = originY - ((j / wrapAt) | 0);
										distances[j] = d = !axis
											? _sqrt(x * x + y * y)
											: Math.abs(axis === "y" ? y : x);
										d > max && (max = d);
										d < min && (min = d);
									}
									from === "random" && shuffle(distances);
									distances.max = max - min;
									distances.min = min;
									distances.v = l =
										(parseFloat(vars.amount) ||
											parseFloat(vars.each) *
												(wrapAt > l
													? l - 1
													: !axis
													? Math.max(wrapAt, l / wrapAt)
													: axis === "y"
													? l / wrapAt
													: wrapAt) ||
											0) * (from === "edges" ? -1 : 1);
									distances.b = l < 0 ? base - l : base;
									distances.u = getUnit(vars.amount || vars.each) || 0;
									ease = ease && l < 0 ? _invertEase(ease) : ease;
								}
								l = (distances[i] - distances.min) / distances.max || 0;
								return (
									_roundPrecise(
										distances.b + (ease ? ease(l) : l) * distances.v
									) + distances.u
								);
							};
						},
						_roundModifier = function _roundModifier(v) {
							var p = Math.pow(10, ((v + "").split(".")[1] || "").length);
							return function (raw) {
								var n = Math.round(parseFloat(raw) / v) * v * p;
								return (n - (n % 1)) / p + (_isNumber(raw) ? 0 : getUnit(raw));
							};
						},
						snap = function snap(snapTo, value) {
							var isArray = _isArray(snapTo),
								radius,
								is2D;
							if (!isArray && _isObject(snapTo)) {
								radius = isArray = snapTo.radius || _bigNum;
								if (snapTo.values) {
									snapTo = toArray(snapTo.values);
									if ((is2D = !_isNumber(snapTo[0]))) {
										radius *= radius;
									}
								} else {
									snapTo = _roundModifier(snapTo.increment);
								}
							}
							return _conditionalReturn(
								value,
								!isArray
									? _roundModifier(snapTo)
									: _isFunction(snapTo)
									? function (raw) {
											is2D = snapTo(raw);
											return Math.abs(is2D - raw) <= radius ? is2D : raw;
									  }
									: function (raw) {
											var x = parseFloat(is2D ? raw.x : raw),
												y = parseFloat(is2D ? raw.y : 0),
												min = _bigNum,
												closest = 0,
												i = snapTo.length,
												dx,
												dy;
											while (i--) {
												if (is2D) {
													dx = snapTo[i].x - x;
													dy = snapTo[i].y - y;
													dx = dx * dx + dy * dy;
												} else {
													dx = Math.abs(snapTo[i] - x);
												}
												if (dx < min) {
													min = dx;
													closest = i;
												}
											}
											closest =
												!radius || min <= radius ? snapTo[closest] : raw;
											return is2D || closest === raw || _isNumber(raw)
												? closest
												: closest + getUnit(raw);
									  }
							);
						},
						random = function random(
							min,
							max,
							roundingIncrement,
							returnFunction
						) {
							return _conditionalReturn(
								_isArray(min)
									? !max
									: roundingIncrement === true
									? !!(roundingIncrement = 0)
									: !returnFunction,
								function () {
									return _isArray(min)
										? min[~~(Math.random() * min.length)]
										: (roundingIncrement = roundingIncrement || 1e-5) &&
												(returnFunction =
													roundingIncrement < 1
														? Math.pow(10, (roundingIncrement + "").length - 2)
														: 1) &&
												Math.floor(
													Math.round(
														(min -
															roundingIncrement / 2 +
															Math.random() *
																(max - min + roundingIncrement * 0.99)) /
															roundingIncrement
													) *
														roundingIncrement *
														returnFunction
												) / returnFunction;
								}
							);
						},
						pipe = function pipe() {
							for (
								var _len = arguments.length,
									functions = new Array(_len),
									_key = 0;
								_key < _len;
								_key++
							) {
								functions[_key] = arguments[_key];
							}
							return function (value) {
								return functions.reduce(function (v, f) {
									return f(v);
								}, value);
							};
						},
						unitize = function unitize(func, unit) {
							return function (value) {
								return func(parseFloat(value)) + (unit || getUnit(value));
							};
						},
						normalize = function normalize(min, max, value) {
							return mapRange(min, max, 0, 1, value);
						},
						_wrapArray = function _wrapArray(a, wrapper, value) {
							return _conditionalReturn(value, function (index) {
								return a[~~wrapper(index)];
							});
						},
						wrap = function wrap(min, max, value) {
							var range = max - min;
							return _isArray(min)
								? _wrapArray(min, wrap(0, min.length), max)
								: _conditionalReturn(value, function (value) {
										return ((range + ((value - min) % range)) % range) + min;
								  });
						},
						wrapYoyo = function wrapYoyo(min, max, value) {
							var range = max - min,
								total = range * 2;
							return _isArray(min)
								? _wrapArray(min, wrapYoyo(0, min.length - 1), max)
								: _conditionalReturn(value, function (value) {
										value = (total + ((value - min) % total)) % total || 0;
										return min + (value > range ? total - value : value);
								  });
						},
						_replaceRandom = function _replaceRandom(value) {
							var prev = 0,
								s = "",
								i,
								nums,
								end,
								isArray;
							while (~(i = value.indexOf("random(", prev))) {
								end = value.indexOf(")", i);
								isArray = value.charAt(i + 7) === "[";
								nums = value
									.substr(i + 7, end - i - 7)
									.match(isArray ? _delimitedValueExp : _strictNumExp);
								s +=
									value.substr(prev, i - prev) +
									random(
										isArray ? nums : +nums[0],
										isArray ? 0 : +nums[1],
										+nums[2] || 1e-5
									);
								prev = end + 1;
							}
							return s + value.substr(prev, value.length - prev);
						},
						mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
							var inRange = inMax - inMin,
								outRange = outMax - outMin;
							return _conditionalReturn(value, function (value) {
								return outMin + (((value - inMin) / inRange) * outRange || 0);
							});
						},
						interpolate = function interpolate(start, end, progress, mutate) {
							var func = isNaN(start + end)
								? 0
								: function (p) {
										return (1 - p) * start + p * end;
								  };
							if (!func) {
								var isString = _isString(start),
									master = {},
									p,
									i,
									interpolators,
									l,
									il;
								progress === true && (mutate = 1) && (progress = null);
								if (isString) {
									start = { p: start };
									end = { p: end };
								} else if (_isArray(start) && !_isArray(end)) {
									interpolators = [];
									l = start.length;
									il = l - 2;
									for (i = 1; i < l; i++) {
										interpolators.push(interpolate(start[i - 1], start[i]));
									}
									l--;
									func = function func(p) {
										p *= l;
										var i = Math.min(il, ~~p);
										return interpolators[i](p - i);
									};
									progress = end;
								} else if (!mutate) {
									start = _merge(_isArray(start) ? [] : {}, start);
								}
								if (!interpolators) {
									for (p in end) {
										_addPropTween.call(master, start, p, "get", end[p]);
									}
									func = function func(p) {
										return (
											_renderPropTweens(p, master) ||
											(isString ? start.p : start)
										);
									};
								}
							}
							return _conditionalReturn(progress, func);
						},
						_getLabelInDirection = function _getLabelInDirection(
							timeline,
							fromTime,
							backward
						) {
							var labels = timeline.labels,
								min = _bigNum,
								p,
								distance,
								label;
							for (p in labels) {
								distance = labels[p] - fromTime;
								if (
									distance < 0 === !!backward &&
									distance &&
									min > (distance = Math.abs(distance))
								) {
									label = p;
									min = distance;
								}
							}
							return label;
						},
						_callback = function _callback(animation, type, executeLazyFirst) {
							var v = animation.vars,
								callback = v[type],
								params,
								scope;
							if (!callback) {
								return;
							}
							params = v[type + "Params"];
							scope = v.callbackScope || animation;
							executeLazyFirst && _lazyTweens.length && _lazyRender();
							return params
								? callback.apply(scope, params)
								: callback.call(scope);
						},
						_interrupt = function _interrupt(animation) {
							_removeFromParent(animation);
							animation.scrollTrigger && animation.scrollTrigger.kill(false);
							animation.progress() < 1 && _callback(animation, "onInterrupt");
							return animation;
						},
						_quickTween,
						_createPlugin = function _createPlugin(config) {
							config = (!config.name && config["default"]) || config;
							var name = config.name,
								isFunc = _isFunction(config),
								Plugin =
									name && !isFunc && config.init
										? function () {
												this._props = [];
										  }
										: config,
								instanceDefaults = {
									init: _emptyFunc,
									render: _renderPropTweens,
									add: _addPropTween,
									kill: _killPropTweensOf,
									modifier: _addPluginModifier,
									rawVars: 0,
								},
								statics = {
									targetTest: 0,
									get: 0,
									getSetter: _getSetter,
									aliases: {},
									register: 0,
								};
							_wake();
							if (config !== Plugin) {
								if (_plugins[name]) {
									return;
								}
								_setDefaults(
									Plugin,
									_setDefaults(
										_copyExcluding(config, instanceDefaults),
										statics
									)
								);
								_merge(
									Plugin.prototype,
									_merge(instanceDefaults, _copyExcluding(config, statics))
								);
								_plugins[(Plugin.prop = name)] = Plugin;
								if (config.targetTest) {
									_harnessPlugins.push(Plugin);
									_reservedProps[name] = 1;
								}
								name =
									(name === "css"
										? "CSS"
										: name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
							}
							_addGlobal(name, Plugin);
							config.register && config.register(gsap, Plugin, PropTween);
						},
						_255 = 255,
						_colorLookup = {
							aqua: [0, _255, _255],
							lime: [0, _255, 0],
							silver: [192, 192, 192],
							black: [0, 0, 0],
							maroon: [128, 0, 0],
							teal: [0, 128, 128],
							blue: [0, 0, _255],
							navy: [0, 0, 128],
							white: [_255, _255, _255],
							olive: [128, 128, 0],
							yellow: [_255, _255, 0],
							orange: [_255, 165, 0],
							gray: [128, 128, 128],
							purple: [128, 0, 128],
							green: [0, 128, 0],
							red: [_255, 0, 0],
							pink: [_255, 192, 203],
							cyan: [0, _255, _255],
							transparent: [_255, _255, _255, 0],
						},
						_hue = function _hue(h, m1, m2) {
							h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
							return (
								((h * 6 < 1
									? m1 + (m2 - m1) * h * 6
									: h < 0.5
									? m2
									: h * 3 < 2
									? m1 + (m2 - m1) * (2 / 3 - h) * 6
									: m1) *
									_255 +
									0.5) |
								0
							);
						},
						splitColor = function splitColor(v, toHSL, forceAlpha) {
							var a = !v
									? _colorLookup.black
									: _isNumber(v)
									? [v >> 16, (v >> 8) & _255, v & _255]
									: 0,
								r,
								g,
								b,
								h,
								s,
								l,
								max,
								min,
								d,
								wasHSL;
							if (!a) {
								if (v.substr(-1) === ",") {
									v = v.substr(0, v.length - 1);
								}
								if (_colorLookup[v]) {
									a = _colorLookup[v];
								} else if (v.charAt(0) === "#") {
									if (v.length < 6) {
										r = v.charAt(1);
										g = v.charAt(2);
										b = v.charAt(3);
										v =
											"#" +
											r +
											r +
											g +
											g +
											b +
											b +
											(v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
									}
									if (v.length === 9) {
										a = parseInt(v.substr(1, 6), 16);
										return [
											a >> 16,
											(a >> 8) & _255,
											a & _255,
											parseInt(v.substr(7), 16) / 255,
										];
									}
									v = parseInt(v.substr(1), 16);
									a = [v >> 16, (v >> 8) & _255, v & _255];
								} else if (v.substr(0, 3) === "hsl") {
									a = wasHSL = v.match(_strictNumExp);
									if (!toHSL) {
										h = (+a[0] % 360) / 360;
										s = +a[1] / 100;
										l = +a[2] / 100;
										g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
										r = l * 2 - g;
										a.length > 3 && (a[3] *= 1);
										a[0] = _hue(h + 1 / 3, r, g);
										a[1] = _hue(h, r, g);
										a[2] = _hue(h - 1 / 3, r, g);
									} else if (~v.indexOf("=")) {
										a = v.match(_numExp);
										forceAlpha && a.length < 4 && (a[3] = 1);
										return a;
									}
								} else {
									a = v.match(_strictNumExp) || _colorLookup.transparent;
								}
								a = a.map(Number);
							}
							if (toHSL && !wasHSL) {
								r = a[0] / _255;
								g = a[1] / _255;
								b = a[2] / _255;
								max = Math.max(r, g, b);
								min = Math.min(r, g, b);
								l = (max + min) / 2;
								if (max === min) {
									h = s = 0;
								} else {
									d = max - min;
									s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
									h =
										max === r
											? (g - b) / d + (g < b ? 6 : 0)
											: max === g
											? (b - r) / d + 2
											: (r - g) / d + 4;
									h *= 60;
								}
								a[0] = ~~(h + 0.5);
								a[1] = ~~(s * 100 + 0.5);
								a[2] = ~~(l * 100 + 0.5);
							}
							forceAlpha && a.length < 4 && (a[3] = 1);
							return a;
						},
						_colorOrderData = function _colorOrderData(v) {
							var values = [],
								c = [],
								i = -1;
							v.split(_colorExp).forEach(function (v) {
								var a = v.match(_numWithUnitExp) || [];
								values.push.apply(values, a);
								c.push((i += a.length + 1));
							});
							values.c = c;
							return values;
						},
						_formatColors = function _formatColors(s, toHSL, orderMatchData) {
							var result = "",
								colors = (s + result).match(_colorExp),
								type = toHSL ? "hsla(" : "rgba(",
								i = 0,
								c,
								shell,
								d,
								l;
							if (!colors) {
								return s;
							}
							colors = colors.map(function (color) {
								return (
									(color = splitColor(color, toHSL, 1)) &&
									type +
										(toHSL
											? color[0] +
											  "," +
											  color[1] +
											  "%," +
											  color[2] +
											  "%," +
											  color[3]
											: color.join(",")) +
										")"
								);
							});
							if (orderMatchData) {
								d = _colorOrderData(s);
								c = orderMatchData.c;
								if (c.join(result) !== d.c.join(result)) {
									shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
									l = shell.length - 1;
									for (; i < l; i++) {
										result +=
											shell[i] +
											(~c.indexOf(i)
												? colors.shift() || type + "0,0,0,0)"
												: (d.length
														? d
														: colors.length
														? colors
														: orderMatchData
												  ).shift());
									}
								}
							}
							if (!shell) {
								shell = s.split(_colorExp);
								l = shell.length - 1;
								for (; i < l; i++) {
									result += shell[i] + colors[i];
								}
							}
							return result + shell[l];
						},
						_colorExp = (function () {
							var s =
									"(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
								p;
							for (p in _colorLookup) {
								s += "|" + p + "\\b";
							}
							return new RegExp(s + ")", "gi");
						})(),
						_hslExp = /hsl[a]?\(/,
						_colorStringFilter = function _colorStringFilter(a) {
							var combined = a.join(" "),
								toHSL;
							_colorExp.lastIndex = 0;
							if (_colorExp.test(combined)) {
								toHSL = _hslExp.test(combined);
								a[1] = _formatColors(a[1], toHSL);
								a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
								return true;
							}
						},
						_tickerActive,
						_ticker = (function () {
							var _getTime = Date.now,
								_lagThreshold = 500,
								_adjustedLag = 33,
								_startTime = _getTime(),
								_lastUpdate = _startTime,
								_gap = 1e3 / 240,
								_nextTime = _gap,
								_listeners = [],
								_id,
								_req,
								_raf,
								_self,
								_delta,
								_i,
								_tick = function _tick(v) {
									var elapsed = _getTime() - _lastUpdate,
										manual = v === true,
										overlap,
										dispatch,
										time,
										frame;
									elapsed > _lagThreshold &&
										(_startTime += elapsed - _adjustedLag);
									_lastUpdate += elapsed;
									time = _lastUpdate - _startTime;
									overlap = time - _nextTime;
									if (overlap > 0 || manual) {
										frame = ++_self.frame;
										_delta = time - _self.time * 1e3;
										_self.time = time = time / 1e3;
										_nextTime +=
											overlap + (overlap >= _gap ? 4 : _gap - overlap);
										dispatch = 1;
									}
									manual || (_id = _req(_tick));
									if (dispatch) {
										for (_i = 0; _i < _listeners.length; _i++) {
											_listeners[_i](time, _delta, frame, v);
										}
									}
								};
							_self = {
								time: 0,
								frame: 0,
								tick: function tick() {
									_tick(true);
								},
								deltaRatio: function deltaRatio(fps) {
									return _delta / (1e3 / (fps || 60));
								},
								wake: function wake() {
									if (_coreReady) {
										if (!_coreInitted && _windowExists()) {
											_win = _coreInitted = window;
											_doc = _win.document || {};
											_globals.gsap = gsap;
											(_win.gsapVersions || (_win.gsapVersions = [])).push(
												gsap.version
											);
											_install(
												_installScope ||
													_win.GreenSockGlobals ||
													(!_win.gsap && _win) ||
													{}
											);
											_raf = _win.requestAnimationFrame;
										}
										_id && _self.sleep();
										_req =
											_raf ||
											function (f) {
												return setTimeout(
													f,
													(_nextTime - _self.time * 1e3 + 1) | 0
												);
											};
										_tickerActive = 1;
										_tick(2);
									}
								},
								sleep: function sleep() {
									(_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
									_tickerActive = 0;
									_req = _emptyFunc;
								},
								lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
									_lagThreshold = threshold || 1 / _tinyNum;
									_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
								},
								fps: function fps(_fps) {
									_gap = 1e3 / (_fps || 240);
									_nextTime = _self.time * 1e3 + _gap;
								},
								add: function add(callback) {
									_listeners.indexOf(callback) < 0 && _listeners.push(callback);
									_wake();
								},
								remove: function remove(callback) {
									var i;
									~(i = _listeners.indexOf(callback)) &&
										_listeners.splice(i, 1) &&
										_i >= i &&
										_i--;
								},
								_listeners: _listeners,
							};
							return _self;
						})(),
						_wake = function _wake() {
							return !_tickerActive && _ticker.wake();
						},
						_easeMap = {},
						_customEaseExp = /^[\d.\-M][\d.\-,\s]/,
						_quotesExp = /["']/g,
						_parseObjectInString = function _parseObjectInString(value) {
							var obj = {},
								split = value.substr(1, value.length - 3).split(":"),
								key = split[0],
								i = 1,
								l = split.length,
								index,
								val,
								parsedVal;
							for (; i < l; i++) {
								val = split[i];
								index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
								parsedVal = val.substr(0, index);
								obj[key] = isNaN(parsedVal)
									? parsedVal.replace(_quotesExp, "").trim()
									: +parsedVal;
								key = val.substr(index + 1).trim();
							}
							return obj;
						},
						_valueInParentheses = function _valueInParentheses(value) {
							var open = value.indexOf("(") + 1,
								close = value.indexOf(")"),
								nested = value.indexOf("(", open);
							return value.substring(
								open,
								~nested && nested < close
									? value.indexOf(")", close + 1)
									: close
							);
						},
						_configEaseFromString = function _configEaseFromString(name) {
							var split = (name + "").split("("),
								ease = _easeMap[split[0]];
							return ease && split.length > 1 && ease.config
								? ease.config.apply(
										null,
										~name.indexOf("{")
											? [_parseObjectInString(split[1])]
											: _valueInParentheses(name)
													.split(",")
													.map(_numericIfPossible)
								  )
								: _easeMap._CE && _customEaseExp.test(name)
								? _easeMap._CE("", name)
								: ease;
						},
						_invertEase = function _invertEase(ease) {
							return function (p) {
								return 1 - ease(1 - p);
							};
						},
						_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
							var child = timeline._first,
								ease;
							while (child) {
								if (child instanceof Timeline) {
									_propagateYoyoEase(child, isYoyo);
								} else if (
									child.vars.yoyoEase &&
									(!child._yoyo || !child._repeat) &&
									child._yoyo !== isYoyo
								) {
									if (child.timeline) {
										_propagateYoyoEase(child.timeline, isYoyo);
									} else {
										ease = child._ease;
										child._ease = child._yEase;
										child._yEase = ease;
										child._yoyo = isYoyo;
									}
								}
								child = child._next;
							}
						},
						_parseEase = function _parseEase(ease, defaultEase) {
							return !ease
								? defaultEase
								: (_isFunction(ease)
										? ease
										: _easeMap[ease] || _configEaseFromString(ease)) ||
										defaultEase;
						},
						_insertEase = function _insertEase(
							names,
							easeIn,
							easeOut,
							easeInOut
						) {
							if (easeOut === void 0) {
								easeOut = function easeOut(p) {
									return 1 - easeIn(1 - p);
								};
							}
							if (easeInOut === void 0) {
								easeInOut = function easeInOut(p) {
									return p < 0.5
										? easeIn(p * 2) / 2
										: 1 - easeIn((1 - p) * 2) / 2;
								};
							}
							var ease = {
									easeIn: easeIn,
									easeOut: easeOut,
									easeInOut: easeInOut,
								},
								lowercaseName;
							_forEachName(names, function (name) {
								_easeMap[name] = _globals[name] = ease;
								_easeMap[(lowercaseName = name.toLowerCase())] = easeOut;
								for (var p in ease) {
									_easeMap[
										lowercaseName +
											(p === "easeIn"
												? ".in"
												: p === "easeOut"
												? ".out"
												: ".inOut")
									] = _easeMap[name + "." + p] = ease[p];
								}
							});
							return ease;
						},
						_easeInOutFromOut = function _easeInOutFromOut(easeOut) {
							return function (p) {
								return p < 0.5
									? (1 - easeOut(1 - p * 2)) / 2
									: 0.5 + easeOut((p - 0.5) * 2) / 2;
							};
						},
						_configElastic = function _configElastic(type, amplitude, period) {
							var p1 = amplitude >= 1 ? amplitude : 1,
								p2 =
									(period || (type ? 0.3 : 0.45)) /
									(amplitude < 1 ? amplitude : 1),
								p3 = (p2 / _2PI) * (Math.asin(1 / p1) || 0),
								easeOut = function easeOut(p) {
									return p === 1
										? 1
										: p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
								},
								ease =
									type === "out"
										? easeOut
										: type === "in"
										? function (p) {
												return 1 - easeOut(1 - p);
										  }
										: _easeInOutFromOut(easeOut);
							p2 = _2PI / p2;
							ease.config = function (amplitude, period) {
								return _configElastic(type, amplitude, period);
							};
							return ease;
						},
						_configBack = function _configBack(type, overshoot) {
							if (overshoot === void 0) {
								overshoot = 1.70158;
							}
							var easeOut = function easeOut(p) {
									return p
										? --p * p * ((overshoot + 1) * p + overshoot) + 1
										: 0;
								},
								ease =
									type === "out"
										? easeOut
										: type === "in"
										? function (p) {
												return 1 - easeOut(1 - p);
										  }
										: _easeInOutFromOut(easeOut);
							ease.config = function (overshoot) {
								return _configBack(type, overshoot);
							};
							return ease;
						};
					_forEachName(
						"Linear,Quad,Cubic,Quart,Quint,Strong",
						function (name, i) {
							var power = i < 5 ? i + 1 : i;
							_insertEase(
								name + ",Power" + (power - 1),
								i
									? function (p) {
											return Math.pow(p, power);
									  }
									: function (p) {
											return p;
									  },
								function (p) {
									return 1 - Math.pow(1 - p, power);
								},
								function (p) {
									return p < 0.5
										? Math.pow(p * 2, power) / 2
										: 1 - Math.pow((1 - p) * 2, power) / 2;
								}
							);
						}
					);
					_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
					_insertEase(
						"Elastic",
						_configElastic("in"),
						_configElastic("out"),
						_configElastic()
					);
					(function (n, c) {
						var n1 = 1 / c,
							n2 = 2 * n1,
							n3 = 2.5 * n1,
							easeOut = function easeOut(p) {
								return p < n1
									? n * p * p
									: p < n2
									? n * Math.pow(p - 1.5 / c, 2) + 0.75
									: p < n3
									? n * (p -= 2.25 / c) * p + 0.9375
									: n * Math.pow(p - 2.625 / c, 2) + 0.984375;
							};
						_insertEase(
							"Bounce",
							function (p) {
								return 1 - easeOut(1 - p);
							},
							easeOut
						);
					})(7.5625, 2.75);
					_insertEase("Expo", function (p) {
						return p ? Math.pow(2, 10 * (p - 1)) : 0;
					});
					_insertEase("Circ", function (p) {
						return -(_sqrt(1 - p * p) - 1);
					});
					_insertEase("Sine", function (p) {
						return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
					});
					_insertEase(
						"Back",
						_configBack("in"),
						_configBack("out"),
						_configBack()
					);
					_easeMap.SteppedEase =
						_easeMap.steps =
						_globals.SteppedEase =
							{
								config: function config(steps, immediateStart) {
									if (steps === void 0) {
										steps = 1;
									}
									var p1 = 1 / steps,
										p2 = steps + (immediateStart ? 0 : 1),
										p3 = immediateStart ? 1 : 0,
										max = 1 - _tinyNum;
									return function (p) {
										return (((p2 * _clamp(0, max, p)) | 0) + p3) * p1;
									};
								},
							};
					_defaults.ease = _easeMap["quad.out"];
					_forEachName(
						"onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
						function (name) {
							return (_callbackNames += name + "," + name + "Params,");
						}
					);
					var GSCache = function GSCache(target, harness) {
						this.id = _gsID++;
						target._gsap = this;
						this.target = target;
						this.harness = harness;
						this.get = harness ? harness.get : _getProperty;
						this.set = harness ? harness.getSetter : _getSetter;
					};
					var Animation = (function () {
						function Animation(vars) {
							this.vars = vars;
							this._delay = +vars.delay || 0;
							if (
								(this._repeat =
									vars.repeat === Infinity ? -2 : vars.repeat || 0)
							) {
								this._rDelay = vars.repeatDelay || 0;
								this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
							}
							this._ts = 1;
							_setDuration(this, +vars.duration, 1, 1);
							this.data = vars.data;
							_tickerActive || _ticker.wake();
						}
						var _proto = Animation.prototype;
						_proto.delay = function delay(value) {
							if (value || value === 0) {
								this.parent &&
									this.parent.smoothChildTiming &&
									this.startTime(this._start + value - this._delay);
								this._delay = value;
								return this;
							}
							return this._delay;
						};
						_proto.duration = function duration(value) {
							return arguments.length
								? this.totalDuration(
										this._repeat > 0
											? value + (value + this._rDelay) * this._repeat
											: value
								  )
								: this.totalDuration() && this._dur;
						};
						_proto.totalDuration = function totalDuration(value) {
							if (!arguments.length) {
								return this._tDur;
							}
							this._dirty = 0;
							return _setDuration(
								this,
								this._repeat < 0
									? value
									: (value - this._repeat * this._rDelay) / (this._repeat + 1)
							);
						};
						_proto.totalTime = function totalTime(_totalTime, suppressEvents) {
							_wake();
							if (!arguments.length) {
								return this._tTime;
							}
							var parent = this._dp;
							if (parent && parent.smoothChildTiming && this._ts) {
								_alignPlayhead(this, _totalTime);
								!parent._dp || parent.parent || _postAddChecks(parent, this);
								while (parent && parent.parent) {
									if (
										parent.parent._time !==
										parent._start +
											(parent._ts >= 0
												? parent._tTime / parent._ts
												: (parent.totalDuration() - parent._tTime) /
												  -parent._ts)
									) {
										parent.totalTime(parent._tTime, true);
									}
									parent = parent.parent;
								}
								if (
									!this.parent &&
									this._dp.autoRemoveChildren &&
									((this._ts > 0 && _totalTime < this._tDur) ||
										(this._ts < 0 && _totalTime > 0) ||
										(!this._tDur && !_totalTime))
								) {
									_addToTimeline(this._dp, this, this._start - this._delay);
								}
							}
							if (
								this._tTime !== _totalTime ||
								(!this._dur && !suppressEvents) ||
								(this._initted && Math.abs(this._zTime) === _tinyNum) ||
								(!_totalTime && !this._initted && (this.add || this._ptLookup))
							) {
								this._ts || (this._pTime = _totalTime);
								_lazySafeRender(this, _totalTime, suppressEvents);
							}
							return this;
						};
						_proto.time = function time(value, suppressEvents) {
							return arguments.length
								? this.totalTime(
										Math.min(
											this.totalDuration(),
											value + _elapsedCycleDuration(this)
										) %
											(this._dur + this._rDelay) || (value ? this._dur : 0),
										suppressEvents
								  )
								: this._time;
						};
						_proto.totalProgress = function totalProgress(
							value,
							suppressEvents
						) {
							return arguments.length
								? this.totalTime(this.totalDuration() * value, suppressEvents)
								: this.totalDuration()
								? Math.min(1, this._tTime / this._tDur)
								: this.ratio;
						};
						_proto.progress = function progress(value, suppressEvents) {
							return arguments.length
								? this.totalTime(
										this.duration() *
											(this._yoyo && !(this.iteration() & 1)
												? 1 - value
												: value) +
											_elapsedCycleDuration(this),
										suppressEvents
								  )
								: this.duration()
								? Math.min(1, this._time / this._dur)
								: this.ratio;
						};
						_proto.iteration = function iteration(value, suppressEvents) {
							var cycleDuration = this.duration() + this._rDelay;
							return arguments.length
								? this.totalTime(
										this._time + (value - 1) * cycleDuration,
										suppressEvents
								  )
								: this._repeat
								? _animationCycle(this._tTime, cycleDuration) + 1
								: 1;
						};
						_proto.timeScale = function timeScale(value) {
							if (!arguments.length) {
								return this._rts === -_tinyNum ? 0 : this._rts;
							}
							if (this._rts === value) {
								return this;
							}
							var tTime =
								this.parent && this._ts
									? _parentToChildTotalTime(this.parent._time, this)
									: this._tTime;
							this._rts = +value || 0;
							this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
							_recacheAncestors(
								this.totalTime(_clamp(-this._delay, this._tDur, tTime), true)
							);
							_setEnd(this);
							return this;
						};
						_proto.paused = function paused(value) {
							if (!arguments.length) {
								return this._ps;
							}
							if (this._ps !== value) {
								this._ps = value;
								if (value) {
									this._pTime =
										this._tTime || Math.max(-this._delay, this.rawTime());
									this._ts = this._act = 0;
								} else {
									_wake();
									this._ts = this._rts;
									this.totalTime(
										this.parent && !this.parent.smoothChildTiming
											? this.rawTime()
											: this._tTime || this._pTime,
										this.progress() === 1 &&
											Math.abs(this._zTime) !== _tinyNum &&
											(this._tTime -= _tinyNum)
									);
								}
							}
							return this;
						};
						_proto.startTime = function startTime(value) {
							if (arguments.length) {
								this._start = value;
								var parent = this.parent || this._dp;
								parent &&
									(parent._sort || !this.parent) &&
									_addToTimeline(parent, this, value - this._delay);
								return this;
							}
							return this._start;
						};
						_proto.endTime = function endTime(includeRepeats) {
							return (
								this._start +
								(_isNotFalse(includeRepeats)
									? this.totalDuration()
									: this.duration()) /
									Math.abs(this._ts || 1)
							);
						};
						_proto.rawTime = function rawTime(wrapRepeats) {
							var parent = this.parent || this._dp;
							return !parent
								? this._tTime
								: wrapRepeats &&
								  (!this._ts ||
										(this._repeat && this._time && this.totalProgress() < 1))
								? this._tTime % (this._dur + this._rDelay)
								: !this._ts
								? this._tTime
								: _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
						};
						_proto.globalTime = function globalTime(rawTime) {
							var animation = this,
								time = arguments.length ? rawTime : animation.rawTime();
							while (animation) {
								time = animation._start + time / (animation._ts || 1);
								animation = animation._dp;
							}
							return time;
						};
						_proto.repeat = function repeat(value) {
							if (arguments.length) {
								this._repeat = value === Infinity ? -2 : value;
								return _onUpdateTotalDuration(this);
							}
							return this._repeat === -2 ? Infinity : this._repeat;
						};
						_proto.repeatDelay = function repeatDelay(value) {
							if (arguments.length) {
								var time = this._time;
								this._rDelay = value;
								_onUpdateTotalDuration(this);
								return time ? this.time(time) : this;
							}
							return this._rDelay;
						};
						_proto.yoyo = function yoyo(value) {
							if (arguments.length) {
								this._yoyo = value;
								return this;
							}
							return this._yoyo;
						};
						_proto.seek = function seek(position, suppressEvents) {
							return this.totalTime(
								_parsePosition(this, position),
								_isNotFalse(suppressEvents)
							);
						};
						_proto.restart = function restart(includeDelay, suppressEvents) {
							return this.play().totalTime(
								includeDelay ? -this._delay : 0,
								_isNotFalse(suppressEvents)
							);
						};
						_proto.play = function play(from, suppressEvents) {
							from != null && this.seek(from, suppressEvents);
							return this.reversed(false).paused(false);
						};
						_proto.reverse = function reverse(from, suppressEvents) {
							from != null &&
								this.seek(from || this.totalDuration(), suppressEvents);
							return this.reversed(true).paused(false);
						};
						_proto.pause = function pause(atTime, suppressEvents) {
							atTime != null && this.seek(atTime, suppressEvents);
							return this.paused(true);
						};
						_proto.resume = function resume() {
							return this.paused(false);
						};
						_proto.reversed = function reversed(value) {
							if (arguments.length) {
								!!value !== this.reversed() &&
									this.timeScale(-this._rts || (value ? -_tinyNum : 0));
								return this;
							}
							return this._rts < 0;
						};
						_proto.invalidate = function invalidate() {
							this._initted = this._act = 0;
							this._zTime = -_tinyNum;
							return this;
						};
						_proto.isActive = function isActive() {
							var parent = this.parent || this._dp,
								start = this._start,
								rawTime;
							return !!(
								!parent ||
								(this._ts &&
									this._initted &&
									parent.isActive() &&
									(rawTime = parent.rawTime(true)) >= start &&
									rawTime < this.endTime(true) - _tinyNum)
							);
						};
						_proto.eventCallback = function eventCallback(
							type,
							callback,
							params
						) {
							var vars = this.vars;
							if (arguments.length > 1) {
								if (!callback) {
									delete vars[type];
								} else {
									vars[type] = callback;
									params && (vars[type + "Params"] = params);
									type === "onUpdate" && (this._onUpdate = callback);
								}
								return this;
							}
							return vars[type];
						};
						_proto.then = function then(onFulfilled) {
							var self = this;
							return new Promise(function (resolve) {
								var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
									_resolve = function _resolve() {
										var _then = self.then;
										self.then = null;
										_isFunction(f) &&
											(f = f(self)) &&
											(f.then || f === self) &&
											(self.then = _then);
										resolve(f);
										self.then = _then;
									};
								if (
									(self._initted &&
										self.totalProgress() === 1 &&
										self._ts >= 0) ||
									(!self._tTime && self._ts < 0)
								) {
									_resolve();
								} else {
									self._prom = _resolve;
								}
							});
						};
						_proto.kill = function kill() {
							_interrupt(this);
						};
						return Animation;
					})();
					_setDefaults(Animation.prototype, {
						_time: 0,
						_start: 0,
						_end: 0,
						_tTime: 0,
						_tDur: 0,
						_dirty: 0,
						_repeat: 0,
						_yoyo: false,
						parent: null,
						_initted: false,
						_rDelay: 0,
						_ts: 1,
						_dp: 0,
						ratio: 0,
						_zTime: -_tinyNum,
						_prom: 0,
						_ps: false,
						_rts: 1,
					});
					var Timeline = (function (_Animation) {
						_inheritsLoose(Timeline, _Animation);
						function Timeline(vars, position) {
							var _this;
							if (vars === void 0) {
								vars = {};
							}
							_this = _Animation.call(this, vars) || this;
							_this.labels = {};
							_this.smoothChildTiming = !!vars.smoothChildTiming;
							_this.autoRemoveChildren = !!vars.autoRemoveChildren;
							_this._sort = _isNotFalse(vars.sortChildren);
							_globalTimeline &&
								_addToTimeline(
									vars.parent || _globalTimeline,
									_assertThisInitialized(_this),
									position
								);
							vars.reversed && _this.reverse();
							vars.paused && _this.paused(true);
							vars.scrollTrigger &&
								_scrollTrigger(
									_assertThisInitialized(_this),
									vars.scrollTrigger
								);
							return _this;
						}
						var _proto2 = Timeline.prototype;
						_proto2.to = function to(targets, vars, position) {
							_createTweenType(0, arguments, this);
							return this;
						};
						_proto2.from = function from(targets, vars, position) {
							_createTweenType(1, arguments, this);
							return this;
						};
						_proto2.fromTo = function fromTo(
							targets,
							fromVars,
							toVars,
							position
						) {
							_createTweenType(2, arguments, this);
							return this;
						};
						_proto2.set = function set(targets, vars, position) {
							vars.duration = 0;
							vars.parent = this;
							_inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
							vars.immediateRender = !!vars.immediateRender;
							new Tween(targets, vars, _parsePosition(this, position), 1);
							return this;
						};
						_proto2.call = function call(callback, params, position) {
							return _addToTimeline(
								this,
								Tween.delayedCall(0, callback, params),
								position
							);
						};
						_proto2.staggerTo = function staggerTo(
							targets,
							duration,
							vars,
							stagger,
							position,
							onCompleteAll,
							onCompleteAllParams
						) {
							vars.duration = duration;
							vars.stagger = vars.stagger || stagger;
							vars.onComplete = onCompleteAll;
							vars.onCompleteParams = onCompleteAllParams;
							vars.parent = this;
							new Tween(targets, vars, _parsePosition(this, position));
							return this;
						};
						_proto2.staggerFrom = function staggerFrom(
							targets,
							duration,
							vars,
							stagger,
							position,
							onCompleteAll,
							onCompleteAllParams
						) {
							vars.runBackwards = 1;
							_inheritDefaults(vars).immediateRender = _isNotFalse(
								vars.immediateRender
							);
							return this.staggerTo(
								targets,
								duration,
								vars,
								stagger,
								position,
								onCompleteAll,
								onCompleteAllParams
							);
						};
						_proto2.staggerFromTo = function staggerFromTo(
							targets,
							duration,
							fromVars,
							toVars,
							stagger,
							position,
							onCompleteAll,
							onCompleteAllParams
						) {
							toVars.startAt = fromVars;
							_inheritDefaults(toVars).immediateRender = _isNotFalse(
								toVars.immediateRender
							);
							return this.staggerTo(
								targets,
								duration,
								toVars,
								stagger,
								position,
								onCompleteAll,
								onCompleteAllParams
							);
						};
						_proto2.render = function render(totalTime, suppressEvents, force) {
							var prevTime = this._time,
								tDur = this._dirty ? this.totalDuration() : this._tDur,
								dur = this._dur,
								tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
								crossingStart =
									this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
								time,
								child,
								next,
								iteration,
								cycleDuration,
								prevPaused,
								pauseTween,
								timeScale,
								prevStart,
								prevIteration,
								yoyo,
								isYoyo;
							this !== _globalTimeline &&
								tTime > tDur &&
								totalTime >= 0 &&
								(tTime = tDur);
							if (tTime !== this._tTime || force || crossingStart) {
								if (prevTime !== this._time && dur) {
									tTime += this._time - prevTime;
									totalTime += this._time - prevTime;
								}
								time = tTime;
								prevStart = this._start;
								timeScale = this._ts;
								prevPaused = !timeScale;
								if (crossingStart) {
									dur || (prevTime = this._zTime);
									(totalTime || !suppressEvents) && (this._zTime = totalTime);
								}
								if (this._repeat) {
									yoyo = this._yoyo;
									cycleDuration = dur + this._rDelay;
									if (this._repeat < -1 && totalTime < 0) {
										return this.totalTime(
											cycleDuration * 100 + totalTime,
											suppressEvents,
											force
										);
									}
									time = _roundPrecise(tTime % cycleDuration);
									if (tTime === tDur) {
										iteration = this._repeat;
										time = dur;
									} else {
										iteration = ~~(tTime / cycleDuration);
										if (iteration && iteration === tTime / cycleDuration) {
											time = dur;
											iteration--;
										}
										time > dur && (time = dur);
									}
									prevIteration = _animationCycle(this._tTime, cycleDuration);
									!prevTime &&
										this._tTime &&
										prevIteration !== iteration &&
										(prevIteration = iteration);
									if (yoyo && iteration & 1) {
										time = dur - time;
										isYoyo = 1;
									}
									if (iteration !== prevIteration && !this._lock) {
										var rewinding = yoyo && prevIteration & 1,
											doesWrap = rewinding === (yoyo && iteration & 1);
										iteration < prevIteration && (rewinding = !rewinding);
										prevTime = rewinding ? 0 : dur;
										this._lock = 1;
										this.render(
											prevTime ||
												(isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)),
											suppressEvents,
											!dur
										)._lock = 0;
										this._tTime = tTime;
										!suppressEvents &&
											this.parent &&
											_callback(this, "onRepeat");
										this.vars.repeatRefresh &&
											!isYoyo &&
											(this.invalidate()._lock = 1);
										if (
											(prevTime && prevTime !== this._time) ||
											prevPaused !== !this._ts ||
											(this.vars.onRepeat && !this.parent && !this._act)
										) {
											return this;
										}
										dur = this._dur;
										tDur = this._tDur;
										if (doesWrap) {
											this._lock = 2;
											prevTime = rewinding ? dur : -1e-4;
											this.render(prevTime, true);
											this.vars.repeatRefresh && !isYoyo && this.invalidate();
										}
										this._lock = 0;
										if (!this._ts && !prevPaused) {
											return this;
										}
										_propagateYoyoEase(this, isYoyo);
									}
								}
								if (this._hasPause && !this._forcing && this._lock < 2) {
									pauseTween = _findNextPauseTween(
										this,
										_roundPrecise(prevTime),
										_roundPrecise(time)
									);
									if (pauseTween) {
										tTime -= time - (time = pauseTween._start);
									}
								}
								this._tTime = tTime;
								this._time = time;
								this._act = !timeScale;
								if (!this._initted) {
									this._onUpdate = this.vars.onUpdate;
									this._initted = 1;
									this._zTime = totalTime;
									prevTime = 0;
								}
								if (!prevTime && time && !suppressEvents) {
									_callback(this, "onStart");
									if (this._tTime !== tTime) {
										return this;
									}
								}
								if (time >= prevTime && totalTime >= 0) {
									child = this._first;
									while (child) {
										next = child._next;
										if (
											(child._act || time >= child._start) &&
											child._ts &&
											pauseTween !== child
										) {
											if (child.parent !== this) {
												return this.render(totalTime, suppressEvents, force);
											}
											child.render(
												child._ts > 0
													? (time - child._start) * child._ts
													: (child._dirty
															? child.totalDuration()
															: child._tDur) +
															(time - child._start) * child._ts,
												suppressEvents,
												force
											);
											if (time !== this._time || (!this._ts && !prevPaused)) {
												pauseTween = 0;
												next && (tTime += this._zTime = -_tinyNum);
												break;
											}
										}
										child = next;
									}
								} else {
									child = this._last;
									var adjustedTime = totalTime < 0 ? totalTime : time;
									while (child) {
										next = child._prev;
										if (
											(child._act || adjustedTime <= child._end) &&
											child._ts &&
											pauseTween !== child
										) {
											if (child.parent !== this) {
												return this.render(totalTime, suppressEvents, force);
											}
											child.render(
												child._ts > 0
													? (adjustedTime - child._start) * child._ts
													: (child._dirty
															? child.totalDuration()
															: child._tDur) +
															(adjustedTime - child._start) * child._ts,
												suppressEvents,
												force
											);
											if (time !== this._time || (!this._ts && !prevPaused)) {
												pauseTween = 0;
												next &&
													(tTime += this._zTime =
														adjustedTime ? -_tinyNum : _tinyNum);
												break;
											}
										}
										child = next;
									}
								}
								if (pauseTween && !suppressEvents) {
									this.pause();
									pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime =
										time >= prevTime ? 1 : -1;
									if (this._ts) {
										this._start = prevStart;
										_setEnd(this);
										return this.render(totalTime, suppressEvents, force);
									}
								}
								this._onUpdate &&
									!suppressEvents &&
									_callback(this, "onUpdate", true);
								if (
									(tTime === tDur && tDur >= this.totalDuration()) ||
									(!tTime && prevTime)
								)
									if (
										prevStart === this._start ||
										Math.abs(timeScale) !== Math.abs(this._ts)
									)
										if (!this._lock) {
											(totalTime || !dur) &&
												((tTime === tDur && this._ts > 0) ||
													(!tTime && this._ts < 0)) &&
												_removeFromParent(this, 1);
											if (
												!suppressEvents &&
												!(totalTime < 0 && !prevTime) &&
												(tTime || prevTime || !tDur)
											) {
												_callback(
													this,
													tTime === tDur && totalTime >= 0
														? "onComplete"
														: "onReverseComplete",
													true
												);
												this._prom &&
													!(tTime < tDur && this.timeScale() > 0) &&
													this._prom();
											}
										}
							}
							return this;
						};
						_proto2.add = function add(child, position) {
							var _this2 = this;
							_isNumber(position) ||
								(position = _parsePosition(this, position, child));
							if (!(child instanceof Animation)) {
								if (_isArray(child)) {
									child.forEach(function (obj) {
										return _this2.add(obj, position);
									});
									return this;
								}
								if (_isString(child)) {
									return this.addLabel(child, position);
								}
								if (_isFunction(child)) {
									child = Tween.delayedCall(0, child);
								} else {
									return this;
								}
							}
							return this !== child
								? _addToTimeline(this, child, position)
								: this;
						};
						_proto2.getChildren = function getChildren(
							nested,
							tweens,
							timelines,
							ignoreBeforeTime
						) {
							if (nested === void 0) {
								nested = true;
							}
							if (tweens === void 0) {
								tweens = true;
							}
							if (timelines === void 0) {
								timelines = true;
							}
							if (ignoreBeforeTime === void 0) {
								ignoreBeforeTime = -_bigNum;
							}
							var a = [],
								child = this._first;
							while (child) {
								if (child._start >= ignoreBeforeTime) {
									if (child instanceof Tween) {
										tweens && a.push(child);
									} else {
										timelines && a.push(child);
										nested &&
											a.push.apply(
												a,
												child.getChildren(true, tweens, timelines)
											);
									}
								}
								child = child._next;
							}
							return a;
						};
						_proto2.getById = function getById(id) {
							var animations = this.getChildren(1, 1, 1),
								i = animations.length;
							while (i--) {
								if (animations[i].vars.id === id) {
									return animations[i];
								}
							}
						};
						_proto2.remove = function remove(child) {
							if (_isString(child)) {
								return this.removeLabel(child);
							}
							if (_isFunction(child)) {
								return this.killTweensOf(child);
							}
							_removeLinkedListItem(this, child);
							if (child === this._recent) {
								this._recent = this._last;
							}
							return _uncache(this);
						};
						_proto2.totalTime = function totalTime(
							_totalTime2,
							suppressEvents
						) {
							if (!arguments.length) {
								return this._tTime;
							}
							this._forcing = 1;
							if (!this._dp && this._ts) {
								this._start = _roundPrecise(
									_ticker.time -
										(this._ts > 0
											? _totalTime2 / this._ts
											: (this.totalDuration() - _totalTime2) / -this._ts)
								);
							}
							_Animation.prototype.totalTime.call(
								this,
								_totalTime2,
								suppressEvents
							);
							this._forcing = 0;
							return this;
						};
						_proto2.addLabel = function addLabel(label, position) {
							this.labels[label] = _parsePosition(this, position);
							return this;
						};
						_proto2.removeLabel = function removeLabel(label) {
							delete this.labels[label];
							return this;
						};
						_proto2.addPause = function addPause(position, callback, params) {
							var t = Tween.delayedCall(0, callback || _emptyFunc, params);
							t.data = "isPause";
							this._hasPause = 1;
							return _addToTimeline(this, t, _parsePosition(this, position));
						};
						_proto2.removePause = function removePause(position) {
							var child = this._first;
							position = _parsePosition(this, position);
							while (child) {
								if (child._start === position && child.data === "isPause") {
									_removeFromParent(child);
								}
								child = child._next;
							}
						};
						_proto2.killTweensOf = function killTweensOf(
							targets,
							props,
							onlyActive
						) {
							var tweens = this.getTweensOf(targets, onlyActive),
								i = tweens.length;
							while (i--) {
								_overwritingTween !== tweens[i] &&
									tweens[i].kill(targets, props);
							}
							return this;
						};
						_proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
							var a = [],
								parsedTargets = toArray(targets),
								child = this._first,
								isGlobalTime = _isNumber(onlyActive),
								children;
							while (child) {
								if (child instanceof Tween) {
									if (
										_arrayContainsAny(child._targets, parsedTargets) &&
										(isGlobalTime
											? (!_overwritingTween || (child._initted && child._ts)) &&
											  child.globalTime(0) <= onlyActive &&
											  child.globalTime(child.totalDuration()) > onlyActive
											: !onlyActive || child.isActive())
									) {
										a.push(child);
									}
								} else if (
									(children = child.getTweensOf(parsedTargets, onlyActive))
										.length
								) {
									a.push.apply(a, children);
								}
								child = child._next;
							}
							return a;
						};
						_proto2.tweenTo = function tweenTo(position, vars) {
							vars = vars || {};
							var tl = this,
								endTime = _parsePosition(tl, position),
								_vars = vars,
								startAt = _vars.startAt,
								_onStart = _vars.onStart,
								onStartParams = _vars.onStartParams,
								immediateRender = _vars.immediateRender,
								initted,
								tween = Tween.to(
									tl,
									_setDefaults(
										{
											ease: vars.ease || "none",
											lazy: false,
											immediateRender: false,
											time: endTime,
											overwrite: "auto",
											duration:
												vars.duration ||
												Math.abs(
													(endTime -
														(startAt && "time" in startAt
															? startAt.time
															: tl._time)) /
														tl.timeScale()
												) ||
												_tinyNum,
											onStart: function onStart() {
												tl.pause();
												if (!initted) {
													var duration =
														vars.duration ||
														Math.abs(
															(endTime -
																(startAt && "time" in startAt
																	? startAt.time
																	: tl._time)) /
																tl.timeScale()
														);
													tween._dur !== duration &&
														_setDuration(tween, duration, 0, 1).render(
															tween._time,
															true,
															true
														);
													initted = 1;
												}
												_onStart && _onStart.apply(tween, onStartParams || []);
											},
										},
										vars
									)
								);
							return immediateRender ? tween.render(0) : tween;
						};
						_proto2.tweenFromTo = function tweenFromTo(
							fromPosition,
							toPosition,
							vars
						) {
							return this.tweenTo(
								toPosition,
								_setDefaults(
									{ startAt: { time: _parsePosition(this, fromPosition) } },
									vars
								)
							);
						};
						_proto2.recent = function recent() {
							return this._recent;
						};
						_proto2.nextLabel = function nextLabel(afterTime) {
							if (afterTime === void 0) {
								afterTime = this._time;
							}
							return _getLabelInDirection(
								this,
								_parsePosition(this, afterTime)
							);
						};
						_proto2.previousLabel = function previousLabel(beforeTime) {
							if (beforeTime === void 0) {
								beforeTime = this._time;
							}
							return _getLabelInDirection(
								this,
								_parsePosition(this, beforeTime),
								1
							);
						};
						_proto2.currentLabel = function currentLabel(value) {
							return arguments.length
								? this.seek(value, true)
								: this.previousLabel(this._time + _tinyNum);
						};
						_proto2.shiftChildren = function shiftChildren(
							amount,
							adjustLabels,
							ignoreBeforeTime
						) {
							if (ignoreBeforeTime === void 0) {
								ignoreBeforeTime = 0;
							}
							var child = this._first,
								labels = this.labels,
								p;
							while (child) {
								if (child._start >= ignoreBeforeTime) {
									child._start += amount;
									child._end += amount;
								}
								child = child._next;
							}
							if (adjustLabels) {
								for (p in labels) {
									if (labels[p] >= ignoreBeforeTime) {
										labels[p] += amount;
									}
								}
							}
							return _uncache(this);
						};
						_proto2.invalidate = function invalidate() {
							var child = this._first;
							this._lock = 0;
							while (child) {
								child.invalidate();
								child = child._next;
							}
							return _Animation.prototype.invalidate.call(this);
						};
						_proto2.clear = function clear(includeLabels) {
							if (includeLabels === void 0) {
								includeLabels = true;
							}
							var child = this._first,
								next;
							while (child) {
								next = child._next;
								this.remove(child);
								child = next;
							}
							this._dp && (this._time = this._tTime = this._pTime = 0);
							includeLabels && (this.labels = {});
							return _uncache(this);
						};
						_proto2.totalDuration = function totalDuration(value) {
							var max = 0,
								self = this,
								child = self._last,
								prevStart = _bigNum,
								prev,
								start,
								parent;
							if (arguments.length) {
								return self.timeScale(
									(self._repeat < 0 ? self.duration() : self.totalDuration()) /
										(self.reversed() ? -value : value)
								);
							}
							if (self._dirty) {
								parent = self.parent;
								while (child) {
									prev = child._prev;
									child._dirty && child.totalDuration();
									start = child._start;
									if (
										start > prevStart &&
										self._sort &&
										child._ts &&
										!self._lock
									) {
										self._lock = 1;
										_addToTimeline(
											self,
											child,
											start - child._delay,
											1
										)._lock = 0;
									} else {
										prevStart = start;
									}
									if (start < 0 && child._ts) {
										max -= start;
										if (
											(!parent && !self._dp) ||
											(parent && parent.smoothChildTiming)
										) {
											self._start += start / self._ts;
											self._time -= start;
											self._tTime -= start;
										}
										self.shiftChildren(-start, false, -Infinity);
										prevStart = 0;
									}
									child._end > max && child._ts && (max = child._end);
									child = prev;
								}
								_setDuration(
									self,
									self === _globalTimeline && self._time > max
										? self._time
										: max,
									1,
									1
								);
								self._dirty = 0;
							}
							return self._tDur;
						};
						Timeline.updateRoot = function updateRoot(time) {
							if (_globalTimeline._ts) {
								_lazySafeRender(
									_globalTimeline,
									_parentToChildTotalTime(time, _globalTimeline)
								);
								_lastRenderedFrame = _ticker.frame;
							}
							if (_ticker.frame >= _nextGCFrame) {
								_nextGCFrame += _config.autoSleep || 120;
								var child = _globalTimeline._first;
								if (!child || !child._ts)
									if (_config.autoSleep && _ticker._listeners.length < 2) {
										while (child && !child._ts) {
											child = child._next;
										}
										child || _ticker.sleep();
									}
							}
						};
						return Timeline;
					})(Animation);
					_setDefaults(Timeline.prototype, {
						_lock: 0,
						_hasPause: 0,
						_forcing: 0,
					});
					var _addComplexStringPropTween = function _addComplexStringPropTween(
							target,
							prop,
							start,
							end,
							setter,
							stringFilter,
							funcParam
						) {
							var pt = new PropTween(
									this._pt,
									target,
									prop,
									0,
									1,
									_renderComplexString,
									null,
									setter
								),
								index = 0,
								matchIndex = 0,
								result,
								startNums,
								color,
								endNum,
								chunk,
								startNum,
								hasRandom,
								a;
							pt.b = start;
							pt.e = end;
							start += "";
							end += "";
							if ((hasRandom = ~end.indexOf("random("))) {
								end = _replaceRandom(end);
							}
							if (stringFilter) {
								a = [start, end];
								stringFilter(a, target, prop);
								start = a[0];
								end = a[1];
							}
							startNums = start.match(_complexStringNumExp) || [];
							while ((result = _complexStringNumExp.exec(end))) {
								endNum = result[0];
								chunk = end.substring(index, result.index);
								if (color) {
									color = (color + 1) % 5;
								} else if (chunk.substr(-5) === "rgba(") {
									color = 1;
								}
								if (endNum !== startNums[matchIndex++]) {
									startNum = parseFloat(startNums[matchIndex - 1]) || 0;
									pt._pt = {
										_next: pt._pt,
										p: chunk || matchIndex === 1 ? chunk : ",",
										s: startNum,
										c:
											endNum.charAt(1) === "="
												? parseFloat(endNum.substr(2)) *
												  (endNum.charAt(0) === "-" ? -1 : 1)
												: parseFloat(endNum) - startNum,
										m: color && color < 4 ? Math.round : 0,
									};
									index = _complexStringNumExp.lastIndex;
								}
							}
							pt.c = index < end.length ? end.substring(index, end.length) : "";
							pt.fp = funcParam;
							if (_relExp.test(end) || hasRandom) {
								pt.e = 0;
							}
							this._pt = pt;
							return pt;
						},
						_addPropTween = function _addPropTween(
							target,
							prop,
							start,
							end,
							index,
							targets,
							modifier,
							stringFilter,
							funcParam
						) {
							_isFunction(end) && (end = end(index || 0, target, targets));
							var currentValue = target[prop],
								parsedStart =
									start !== "get"
										? start
										: !_isFunction(currentValue)
										? currentValue
										: funcParam
										? target[
												prop.indexOf("set") ||
												!_isFunction(target["get" + prop.substr(3)])
													? prop
													: "get" + prop.substr(3)
										  ](funcParam)
										: target[prop](),
								setter = !_isFunction(currentValue)
									? _setterPlain
									: funcParam
									? _setterFuncWithParam
									: _setterFunc,
								pt;
							if (_isString(end)) {
								if (~end.indexOf("random(")) {
									end = _replaceRandom(end);
								}
								if (end.charAt(1) === "=") {
									pt =
										parseFloat(parsedStart) +
										parseFloat(end.substr(2)) *
											(end.charAt(0) === "-" ? -1 : 1) +
										(getUnit(parsedStart) || 0);
									if (pt || pt === 0) {
										end = pt;
									}
								}
							}
							if (parsedStart !== end) {
								if (!isNaN(parsedStart * end) && end !== "") {
									pt = new PropTween(
										this._pt,
										target,
										prop,
										+parsedStart || 0,
										end - (parsedStart || 0),
										typeof currentValue === "boolean"
											? _renderBoolean
											: _renderPlain,
										0,
										setter
									);
									funcParam && (pt.fp = funcParam);
									modifier && pt.modifier(modifier, this, target);
									return (this._pt = pt);
								}
								!currentValue && !(prop in target) && _missingPlugin(prop, end);
								return _addComplexStringPropTween.call(
									this,
									target,
									prop,
									parsedStart,
									end,
									setter,
									stringFilter || _config.stringFilter,
									funcParam
								);
							}
						},
						_processVars = function _processVars(
							vars,
							index,
							target,
							targets,
							tween
						) {
							_isFunction(vars) &&
								(vars = _parseFuncOrString(
									vars,
									tween,
									index,
									target,
									targets
								));
							if (
								!_isObject(vars) ||
								(vars.style && vars.nodeType) ||
								_isArray(vars) ||
								_isTypedArray(vars)
							) {
								return _isString(vars)
									? _parseFuncOrString(vars, tween, index, target, targets)
									: vars;
							}
							var copy = {},
								p;
							for (p in vars) {
								copy[p] = _parseFuncOrString(
									vars[p],
									tween,
									index,
									target,
									targets
								);
							}
							return copy;
						},
						_checkPlugin = function _checkPlugin(
							property,
							vars,
							tween,
							index,
							target,
							targets
						) {
							var plugin, pt, ptLookup, i;
							if (
								_plugins[property] &&
								(plugin = new _plugins[property]()).init(
									target,
									plugin.rawVars
										? vars[property]
										: _processVars(
												vars[property],
												index,
												target,
												targets,
												tween
										  ),
									tween,
									index,
									targets
								) !== false
							) {
								tween._pt = pt = new PropTween(
									tween._pt,
									target,
									property,
									0,
									1,
									plugin.render,
									plugin,
									0,
									plugin.priority
								);
								if (tween !== _quickTween) {
									ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
									i = plugin._props.length;
									while (i--) {
										ptLookup[plugin._props[i]] = pt;
									}
								}
							}
							return plugin;
						},
						_overwritingTween,
						_initTween = function _initTween(tween, time) {
							var vars = tween.vars,
								ease = vars.ease,
								startAt = vars.startAt,
								immediateRender = vars.immediateRender,
								lazy = vars.lazy,
								onUpdate = vars.onUpdate,
								onUpdateParams = vars.onUpdateParams,
								callbackScope = vars.callbackScope,
								runBackwards = vars.runBackwards,
								yoyoEase = vars.yoyoEase,
								keyframes = vars.keyframes,
								autoRevert = vars.autoRevert,
								dur = tween._dur,
								prevStartAt = tween._startAt,
								targets = tween._targets,
								parent = tween.parent,
								fullTargets =
									parent && parent.data === "nested"
										? parent.parent._targets
										: targets,
								autoOverwrite =
									tween._overwrite === "auto" && !_suppressOverwrites,
								tl = tween.timeline,
								cleanVars,
								i,
								p,
								pt,
								target,
								hasPriority,
								gsData,
								harness,
								plugin,
								ptLookup,
								index,
								harnessVars,
								overwritten;
							tl && (!keyframes || !ease) && (ease = "none");
							tween._ease = _parseEase(ease, _defaults.ease);
							tween._yEase = yoyoEase
								? _invertEase(
										_parseEase(
											yoyoEase === true ? ease : yoyoEase,
											_defaults.ease
										)
								  )
								: 0;
							if (yoyoEase && tween._yoyo && !tween._repeat) {
								yoyoEase = tween._yEase;
								tween._yEase = tween._ease;
								tween._ease = yoyoEase;
							}
							tween._from = !tl && !!vars.runBackwards;
							if (!tl) {
								harness = targets[0] ? _getCache(targets[0]).harness : 0;
								harnessVars = harness && vars[harness.prop];
								cleanVars = _copyExcluding(vars, _reservedProps);
								prevStartAt && prevStartAt.render(-1, true).kill();
								if (startAt) {
									_removeFromParent(
										(tween._startAt = Tween.set(
											targets,
											_setDefaults(
												{
													data: "isStart",
													overwrite: false,
													parent: parent,
													immediateRender: true,
													lazy: _isNotFalse(lazy),
													startAt: null,
													delay: 0,
													onUpdate: onUpdate,
													onUpdateParams: onUpdateParams,
													callbackScope: callbackScope,
													stagger: 0,
												},
												startAt
											)
										))
									);
									time < 0 &&
										!immediateRender &&
										!autoRevert &&
										tween._startAt.render(-1, true);
									if (immediateRender) {
										time > 0 && !autoRevert && (tween._startAt = 0);
										if (dur && time <= 0) {
											time && (tween._zTime = time);
											return;
										}
									} else if (autoRevert === false) {
										tween._startAt = 0;
									}
								} else if (runBackwards && dur) {
									if (prevStartAt) {
										!autoRevert && (tween._startAt = 0);
									} else {
										time && (immediateRender = false);
										p = _setDefaults(
											{
												overwrite: false,
												data: "isFromStart",
												lazy: immediateRender && _isNotFalse(lazy),
												immediateRender: immediateRender,
												stagger: 0,
												parent: parent,
											},
											cleanVars
										);
										harnessVars && (p[harness.prop] = harnessVars);
										_removeFromParent((tween._startAt = Tween.set(targets, p)));
										time < 0 && tween._startAt.render(-1, true);
										if (!immediateRender) {
											_initTween(tween._startAt, _tinyNum);
										} else if (!time) {
											return;
										}
									}
								}
								tween._pt = 0;
								lazy = (dur && _isNotFalse(lazy)) || (lazy && !dur);
								for (i = 0; i < targets.length; i++) {
									target = targets[i];
									gsData = target._gsap || _harness(targets)[i]._gsap;
									tween._ptLookup[i] = ptLookup = {};
									_lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
									index =
										fullTargets === targets ? i : fullTargets.indexOf(target);
									if (
										harness &&
										(plugin = new harness()).init(
											target,
											harnessVars || cleanVars,
											tween,
											index,
											fullTargets
										) !== false
									) {
										tween._pt = pt = new PropTween(
											tween._pt,
											target,
											plugin.name,
											0,
											1,
											plugin.render,
											plugin,
											0,
											plugin.priority
										);
										plugin._props.forEach(function (name) {
											ptLookup[name] = pt;
										});
										plugin.priority && (hasPriority = 1);
									}
									if (!harness || harnessVars) {
										for (p in cleanVars) {
											if (
												_plugins[p] &&
												(plugin = _checkPlugin(
													p,
													cleanVars,
													tween,
													index,
													target,
													fullTargets
												))
											) {
												plugin.priority && (hasPriority = 1);
											} else {
												ptLookup[p] = pt = _addPropTween.call(
													tween,
													target,
													p,
													"get",
													cleanVars[p],
													index,
													fullTargets,
													0,
													vars.stringFilter
												);
											}
										}
									}
									tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
									if (autoOverwrite && tween._pt) {
										_overwritingTween = tween;
										_globalTimeline.killTweensOf(
											target,
											ptLookup,
											tween.globalTime(time)
										);
										overwritten = !tween.parent;
										_overwritingTween = 0;
									}
									tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
								}
								hasPriority && _sortPropTweensByPriority(tween);
								tween._onInit && tween._onInit(tween);
							}
							tween._onUpdate = onUpdate;
							tween._initted = (!tween._op || tween._pt) && !overwritten;
						},
						_addAliasesToVars = function _addAliasesToVars(targets, vars) {
							var harness = targets[0] ? _getCache(targets[0]).harness : 0,
								propertyAliases = harness && harness.aliases,
								copy,
								p,
								i,
								aliases;
							if (!propertyAliases) {
								return vars;
							}
							copy = _merge({}, vars);
							for (p in propertyAliases) {
								if (p in copy) {
									aliases = propertyAliases[p].split(",");
									i = aliases.length;
									while (i--) {
										copy[aliases[i]] = copy[p];
									}
								}
							}
							return copy;
						},
						_parseFuncOrString = function _parseFuncOrString(
							value,
							tween,
							i,
							target,
							targets
						) {
							return _isFunction(value)
								? value.call(tween, i, target, targets)
								: _isString(value) && ~value.indexOf("random(")
								? _replaceRandom(value)
								: value;
						},
						_staggerTweenProps =
							_callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
						_staggerPropsToSkip = (
							_staggerTweenProps +
							",id,stagger,delay,duration,paused,scrollTrigger"
						).split(",");
					var Tween = (function (_Animation2) {
						_inheritsLoose(Tween, _Animation2);
						function Tween(targets, vars, position, skipInherit) {
							var _this3;
							if (typeof vars === "number") {
								position.duration = vars;
								vars = position;
								position = null;
							}
							_this3 =
								_Animation2.call(
									this,
									skipInherit ? vars : _inheritDefaults(vars)
								) || this;
							var _this3$vars = _this3.vars,
								duration = _this3$vars.duration,
								delay = _this3$vars.delay,
								immediateRender = _this3$vars.immediateRender,
								stagger = _this3$vars.stagger,
								overwrite = _this3$vars.overwrite,
								keyframes = _this3$vars.keyframes,
								defaults = _this3$vars.defaults,
								scrollTrigger = _this3$vars.scrollTrigger,
								yoyoEase = _this3$vars.yoyoEase,
								parent = vars.parent || _globalTimeline,
								parsedTargets = (
									_isArray(targets) || _isTypedArray(targets)
										? _isNumber(targets[0])
										: "length" in vars
								)
									? [targets]
									: toArray(targets),
								tl,
								i,
								copy,
								l,
								p,
								curTarget,
								staggerFunc,
								staggerVarsToMerge;
							_this3._targets = parsedTargets.length
								? _harness(parsedTargets)
								: _warn(
										"GSAP target " +
											targets +
											" not found. https://greensock.com",
										!_config.nullTargetWarn
								  ) || [];
							_this3._ptLookup = [];
							_this3._overwrite = overwrite;
							if (
								keyframes ||
								stagger ||
								_isFuncOrString(duration) ||
								_isFuncOrString(delay)
							) {
								vars = _this3.vars;
								tl = _this3.timeline = new Timeline({
									data: "nested",
									defaults: defaults || {},
								});
								tl.kill();
								tl.parent = tl._dp = _assertThisInitialized(_this3);
								tl._start = 0;
								if (keyframes) {
									_inheritDefaults(
										_setDefaults(tl.vars.defaults, { ease: "none" })
									);
									stagger
										? parsedTargets.forEach(function (t, i) {
												return keyframes.forEach(function (frame, j) {
													return tl.to(t, frame, j ? ">" : i * stagger);
												});
										  })
										: keyframes.forEach(function (frame) {
												return tl.to(parsedTargets, frame, ">");
										  });
								} else {
									l = parsedTargets.length;
									staggerFunc = stagger ? distribute(stagger) : _emptyFunc;
									if (_isObject(stagger)) {
										for (p in stagger) {
											if (~_staggerTweenProps.indexOf(p)) {
												staggerVarsToMerge || (staggerVarsToMerge = {});
												staggerVarsToMerge[p] = stagger[p];
											}
										}
									}
									for (i = 0; i < l; i++) {
										copy = {};
										for (p in vars) {
											if (_staggerPropsToSkip.indexOf(p) < 0) {
												copy[p] = vars[p];
											}
										}
										copy.stagger = 0;
										yoyoEase && (copy.yoyoEase = yoyoEase);
										staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
										curTarget = parsedTargets[i];
										copy.duration = +_parseFuncOrString(
											duration,
											_assertThisInitialized(_this3),
											i,
											curTarget,
											parsedTargets
										);
										copy.delay =
											(+_parseFuncOrString(
												delay,
												_assertThisInitialized(_this3),
												i,
												curTarget,
												parsedTargets
											) || 0) - _this3._delay;
										if (!stagger && l === 1 && copy.delay) {
											_this3._delay = delay = copy.delay;
											_this3._start += delay;
											copy.delay = 0;
										}
										tl.to(
											curTarget,
											copy,
											staggerFunc(i, curTarget, parsedTargets)
										);
									}
									tl.duration()
										? (duration = delay = 0)
										: (_this3.timeline = 0);
								}
								duration || _this3.duration((duration = tl.duration()));
							} else {
								_this3.timeline = 0;
							}
							if (overwrite === true && !_suppressOverwrites) {
								_overwritingTween = _assertThisInitialized(_this3);
								_globalTimeline.killTweensOf(parsedTargets);
								_overwritingTween = 0;
							}
							_addToTimeline(parent, _assertThisInitialized(_this3), position);
							vars.reversed && _this3.reverse();
							vars.paused && _this3.paused(true);
							if (
								immediateRender ||
								(!duration &&
									!keyframes &&
									_this3._start === _roundPrecise(parent._time) &&
									_isNotFalse(immediateRender) &&
									_hasNoPausedAncestors(_assertThisInitialized(_this3)) &&
									parent.data !== "nested")
							) {
								_this3._tTime = -_tinyNum;
								_this3.render(Math.max(0, -delay));
							}
							scrollTrigger &&
								_scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
							return _this3;
						}
						var _proto3 = Tween.prototype;
						_proto3.render = function render(totalTime, suppressEvents, force) {
							var prevTime = this._time,
								tDur = this._tDur,
								dur = this._dur,
								tTime =
									totalTime > tDur - _tinyNum && totalTime >= 0
										? tDur
										: totalTime < _tinyNum
										? 0
										: totalTime,
								time,
								pt,
								iteration,
								cycleDuration,
								prevIteration,
								isYoyo,
								ratio,
								timeline,
								yoyoEase;
							if (!dur) {
								_renderZeroDurationTween(
									this,
									totalTime,
									suppressEvents,
									force
								);
							} else if (
								tTime !== this._tTime ||
								!totalTime ||
								force ||
								(!this._initted && this._tTime) ||
								(this._startAt && this._zTime < 0 !== totalTime < 0)
							) {
								time = tTime;
								timeline = this.timeline;
								if (this._repeat) {
									cycleDuration = dur + this._rDelay;
									if (this._repeat < -1 && totalTime < 0) {
										return this.totalTime(
											cycleDuration * 100 + totalTime,
											suppressEvents,
											force
										);
									}
									time = _roundPrecise(tTime % cycleDuration);
									if (tTime === tDur) {
										iteration = this._repeat;
										time = dur;
									} else {
										iteration = ~~(tTime / cycleDuration);
										if (iteration && iteration === tTime / cycleDuration) {
											time = dur;
											iteration--;
										}
										time > dur && (time = dur);
									}
									isYoyo = this._yoyo && iteration & 1;
									if (isYoyo) {
										yoyoEase = this._yEase;
										time = dur - time;
									}
									prevIteration = _animationCycle(this._tTime, cycleDuration);
									if (time === prevTime && !force && this._initted) {
										return this;
									}
									if (iteration !== prevIteration) {
										timeline &&
											this._yEase &&
											_propagateYoyoEase(timeline, isYoyo);
										if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
											this._lock = force = 1;
											this.render(
												_roundPrecise(cycleDuration * iteration),
												true
											).invalidate()._lock = 0;
										}
									}
								}
								if (!this._initted) {
									if (
										_attemptInitTween(
											this,
											totalTime < 0 ? totalTime : time,
											force,
											suppressEvents
										)
									) {
										this._tTime = 0;
										return this;
									}
									if (dur !== this._dur) {
										return this.render(totalTime, suppressEvents, force);
									}
								}
								this._tTime = tTime;
								this._time = time;
								if (!this._act && this._ts) {
									this._act = 1;
									this._lazy = 0;
								}
								this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
								if (this._from) {
									this.ratio = ratio = 1 - ratio;
								}
								if (time && !prevTime && !suppressEvents) {
									_callback(this, "onStart");
									if (this._tTime !== tTime) {
										return this;
									}
								}
								pt = this._pt;
								while (pt) {
									pt.r(ratio, pt.d);
									pt = pt._next;
								}
								(timeline &&
									timeline.render(
										totalTime < 0
											? totalTime
											: !time && isYoyo
											? -_tinyNum
											: timeline._dur * ratio,
										suppressEvents,
										force
									)) ||
									(this._startAt && (this._zTime = totalTime));
								if (this._onUpdate && !suppressEvents) {
									totalTime < 0 &&
										this._startAt &&
										this._startAt.render(totalTime, true, force);
									_callback(this, "onUpdate");
								}
								this._repeat &&
									iteration !== prevIteration &&
									this.vars.onRepeat &&
									!suppressEvents &&
									this.parent &&
									_callback(this, "onRepeat");
								if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
									totalTime < 0 &&
										this._startAt &&
										!this._onUpdate &&
										this._startAt.render(totalTime, true, true);
									(totalTime || !dur) &&
										((tTime === this._tDur && this._ts > 0) ||
											(!tTime && this._ts < 0)) &&
										_removeFromParent(this, 1);
									if (
										!suppressEvents &&
										!(totalTime < 0 && !prevTime) &&
										(tTime || prevTime)
									) {
										_callback(
											this,
											tTime === tDur ? "onComplete" : "onReverseComplete",
											true
										);
										this._prom &&
											!(tTime < tDur && this.timeScale() > 0) &&
											this._prom();
									}
								}
							}
							return this;
						};
						_proto3.targets = function targets() {
							return this._targets;
						};
						_proto3.invalidate = function invalidate() {
							this._pt =
								this._op =
								this._startAt =
								this._onUpdate =
								this._lazy =
								this.ratio =
									0;
							this._ptLookup = [];
							this.timeline && this.timeline.invalidate();
							return _Animation2.prototype.invalidate.call(this);
						};
						_proto3.kill = function kill(targets, vars) {
							if (vars === void 0) {
								vars = "all";
							}
							if (!targets && (!vars || vars === "all")) {
								this._lazy = this._pt = 0;
								return this.parent ? _interrupt(this) : this;
							}
							if (this.timeline) {
								var tDur = this.timeline.totalDuration();
								this.timeline.killTweensOf(
									targets,
									vars,
									_overwritingTween && _overwritingTween.vars.overwrite !== true
								)._first || _interrupt(this);
								this.parent &&
									tDur !== this.timeline.totalDuration() &&
									_setDuration(
										this,
										(this._dur * this.timeline._tDur) / tDur,
										0,
										1
									);
								return this;
							}
							var parsedTargets = this._targets,
								killingTargets = targets ? toArray(targets) : parsedTargets,
								propTweenLookup = this._ptLookup,
								firstPT = this._pt,
								overwrittenProps,
								curLookup,
								curOverwriteProps,
								props,
								p,
								pt,
								i;
							if (
								(!vars || vars === "all") &&
								_arraysMatch(parsedTargets, killingTargets)
							) {
								vars === "all" && (this._pt = 0);
								return _interrupt(this);
							}
							overwrittenProps = this._op = this._op || [];
							if (vars !== "all") {
								if (_isString(vars)) {
									p = {};
									_forEachName(vars, function (name) {
										return (p[name] = 1);
									});
									vars = p;
								}
								vars = _addAliasesToVars(parsedTargets, vars);
							}
							i = parsedTargets.length;
							while (i--) {
								if (~killingTargets.indexOf(parsedTargets[i])) {
									curLookup = propTweenLookup[i];
									if (vars === "all") {
										overwrittenProps[i] = vars;
										props = curLookup;
										curOverwriteProps = {};
									} else {
										curOverwriteProps = overwrittenProps[i] =
											overwrittenProps[i] || {};
										props = vars;
									}
									for (p in props) {
										pt = curLookup && curLookup[p];
										if (pt) {
											if (!("kill" in pt.d) || pt.d.kill(p) === true) {
												_removeLinkedListItem(this, pt, "_pt");
											}
											delete curLookup[p];
										}
										if (curOverwriteProps !== "all") {
											curOverwriteProps[p] = 1;
										}
									}
								}
							}
							this._initted && !this._pt && firstPT && _interrupt(this);
							return this;
						};
						Tween.to = function to(targets, vars) {
							return new Tween(targets, vars, arguments[2]);
						};
						Tween.from = function from(targets, vars) {
							return _createTweenType(1, arguments);
						};
						Tween.delayedCall = function delayedCall(
							delay,
							callback,
							params,
							scope
						) {
							return new Tween(callback, 0, {
								immediateRender: false,
								lazy: false,
								overwrite: false,
								delay: delay,
								onComplete: callback,
								onReverseComplete: callback,
								onCompleteParams: params,
								onReverseCompleteParams: params,
								callbackScope: scope,
							});
						};
						Tween.fromTo = function fromTo(targets, fromVars, toVars) {
							return _createTweenType(2, arguments);
						};
						Tween.set = function set(targets, vars) {
							vars.duration = 0;
							vars.repeatDelay || (vars.repeat = 0);
							return new Tween(targets, vars);
						};
						Tween.killTweensOf = function killTweensOf(
							targets,
							props,
							onlyActive
						) {
							return _globalTimeline.killTweensOf(targets, props, onlyActive);
						};
						return Tween;
					})(Animation);
					_setDefaults(Tween.prototype, {
						_targets: [],
						_lazy: 0,
						_startAt: 0,
						_op: 0,
						_onInit: 0,
					});
					_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
						Tween[name] = function () {
							var tl = new Timeline(),
								params = _slice.call(arguments, 0);
							params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
							return tl[name].apply(tl, params);
						};
					});
					var _setterPlain = function _setterPlain(target, property, value) {
							return (target[property] = value);
						},
						_setterFunc = function _setterFunc(target, property, value) {
							return target[property](value);
						},
						_setterFuncWithParam = function _setterFuncWithParam(
							target,
							property,
							value,
							data
						) {
							return target[property](data.fp, value);
						},
						_setterAttribute = function _setterAttribute(
							target,
							property,
							value
						) {
							return target.setAttribute(property, value);
						},
						_getSetter = function _getSetter(target, property) {
							return _isFunction(target[property])
								? _setterFunc
								: _isUndefined(target[property]) && target.setAttribute
								? _setterAttribute
								: _setterPlain;
						},
						_renderPlain = function _renderPlain(ratio, data) {
							return data.set(
								data.t,
								data.p,
								Math.round((data.s + data.c * ratio) * 1e6) / 1e6,
								data
							);
						},
						_renderBoolean = function _renderBoolean(ratio, data) {
							return data.set(
								data.t,
								data.p,
								!!(data.s + data.c * ratio),
								data
							);
						},
						_renderComplexString = function _renderComplexString(ratio, data) {
							var pt = data._pt,
								s = "";
							if (!ratio && data.b) {
								s = data.b;
							} else if (ratio === 1 && data.e) {
								s = data.e;
							} else {
								while (pt) {
									s =
										pt.p +
										(pt.m
											? pt.m(pt.s + pt.c * ratio)
											: Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) +
										s;
									pt = pt._next;
								}
								s += data.c;
							}
							data.set(data.t, data.p, s, data);
						},
						_renderPropTweens = function _renderPropTweens(ratio, data) {
							var pt = data._pt;
							while (pt) {
								pt.r(ratio, pt.d);
								pt = pt._next;
							}
						},
						_addPluginModifier = function _addPluginModifier(
							modifier,
							tween,
							target,
							property
						) {
							var pt = this._pt,
								next;
							while (pt) {
								next = pt._next;
								pt.p === property && pt.modifier(modifier, tween, target);
								pt = next;
							}
						},
						_killPropTweensOf = function _killPropTweensOf(property) {
							var pt = this._pt,
								hasNonDependentRemaining,
								next;
							while (pt) {
								next = pt._next;
								if ((pt.p === property && !pt.op) || pt.op === property) {
									_removeLinkedListItem(this, pt, "_pt");
								} else if (!pt.dep) {
									hasNonDependentRemaining = 1;
								}
								pt = next;
							}
							return !hasNonDependentRemaining;
						},
						_setterWithModifier = function _setterWithModifier(
							target,
							property,
							value,
							data
						) {
							data.mSet(
								target,
								property,
								data.m.call(data.tween, value, data.mt),
								data
							);
						},
						_sortPropTweensByPriority = function _sortPropTweensByPriority(
							parent
						) {
							var pt = parent._pt,
								next,
								pt2,
								first,
								last;
							while (pt) {
								next = pt._next;
								pt2 = first;
								while (pt2 && pt2.pr > pt.pr) {
									pt2 = pt2._next;
								}
								if ((pt._prev = pt2 ? pt2._prev : last)) {
									pt._prev._next = pt;
								} else {
									first = pt;
								}
								if ((pt._next = pt2)) {
									pt2._prev = pt;
								} else {
									last = pt;
								}
								pt = next;
							}
							parent._pt = first;
						};
					var PropTween = (function () {
						function PropTween(
							next,
							target,
							prop,
							start,
							change,
							renderer,
							data,
							setter,
							priority
						) {
							this.t = target;
							this.s = start;
							this.c = change;
							this.p = prop;
							this.r = renderer || _renderPlain;
							this.d = data || this;
							this.set = setter || _setterPlain;
							this.pr = priority || 0;
							this._next = next;
							if (next) {
								next._prev = this;
							}
						}
						var _proto4 = PropTween.prototype;
						_proto4.modifier = function modifier(func, tween, target) {
							this.mSet = this.mSet || this.set;
							this.set = _setterWithModifier;
							this.m = func;
							this.mt = target;
							this.tween = tween;
						};
						return PropTween;
					})();
					_forEachName(
						_callbackNames +
							"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
						function (name) {
							return (_reservedProps[name] = 1);
						}
					);
					_globals.TweenMax = _globals.TweenLite = Tween;
					_globals.TimelineLite = _globals.TimelineMax = Timeline;
					_globalTimeline = new Timeline({
						sortChildren: false,
						defaults: _defaults,
						autoRemoveChildren: true,
						id: "root",
						smoothChildTiming: true,
					});
					_config.stringFilter = _colorStringFilter;
					var _gsap = {
						registerPlugin: function registerPlugin() {
							for (
								var _len2 = arguments.length,
									args = new Array(_len2),
									_key2 = 0;
								_key2 < _len2;
								_key2++
							) {
								args[_key2] = arguments[_key2];
							}
							args.forEach(function (config) {
								return _createPlugin(config);
							});
						},
						timeline: function timeline(vars) {
							return new Timeline(vars);
						},
						getTweensOf: function getTweensOf(targets, onlyActive) {
							return _globalTimeline.getTweensOf(targets, onlyActive);
						},
						getProperty: function getProperty(target, property, unit, uncache) {
							_isString(target) && (target = toArray(target)[0]);
							var getter = _getCache(target || {}).get,
								format = unit ? _passThrough : _numericIfPossible;
							unit === "native" && (unit = "");
							return !target
								? target
								: !property
								? function (property, unit, uncache) {
										return format(
											(
												(_plugins[property] && _plugins[property].get) ||
												getter
											)(target, property, unit, uncache)
										);
								  }
								: format(
										((_plugins[property] && _plugins[property].get) || getter)(
											target,
											property,
											unit,
											uncache
										)
								  );
						},
						quickSetter: function quickSetter(target, property, unit) {
							target = toArray(target);
							if (target.length > 1) {
								var setters = target.map(function (t) {
										return gsap.quickSetter(t, property, unit);
									}),
									l = setters.length;
								return function (value) {
									var i = l;
									while (i--) {
										setters[i](value);
									}
								};
							}
							target = target[0] || {};
							var Plugin = _plugins[property],
								cache = _getCache(target),
								p =
									(cache.harness && (cache.harness.aliases || {})[property]) ||
									property,
								setter = Plugin
									? function (value) {
											var p = new Plugin();
											_quickTween._pt = 0;
											p.init(
												target,
												unit ? value + unit : value,
												_quickTween,
												0,
												[target]
											);
											p.render(1, p);
											_quickTween._pt && _renderPropTweens(1, _quickTween);
									  }
									: cache.set(target, p);
							return Plugin
								? setter
								: function (value) {
										return setter(
											target,
											p,
											unit ? value + unit : value,
											cache,
											1
										);
								  };
						},
						isTweening: function isTweening(targets) {
							return _globalTimeline.getTweensOf(targets, true).length > 0;
						},
						defaults: function defaults(value) {
							value &&
								value.ease &&
								(value.ease = _parseEase(value.ease, _defaults.ease));
							return _mergeDeep(_defaults, value || {});
						},
						config: function config(value) {
							return _mergeDeep(_config, value || {});
						},
						registerEffect: function registerEffect(_ref3) {
							var name = _ref3.name,
								effect = _ref3.effect,
								plugins = _ref3.plugins,
								defaults = _ref3.defaults,
								extendTimeline = _ref3.extendTimeline;
							(plugins || "").split(",").forEach(function (pluginName) {
								return (
									pluginName &&
									!_plugins[pluginName] &&
									!_globals[pluginName] &&
									_warn(name + " effect requires " + pluginName + " plugin.")
								);
							});
							_effects[name] = function (targets, vars, tl) {
								return effect(
									toArray(targets),
									_setDefaults(vars || {}, defaults),
									tl
								);
							};
							if (extendTimeline) {
								Timeline.prototype[name] = function (targets, vars, position) {
									return this.add(
										_effects[name](
											targets,
											_isObject(vars) ? vars : (position = vars) && {},
											this
										),
										position
									);
								};
							}
						},
						registerEase: function registerEase(name, ease) {
							_easeMap[name] = _parseEase(ease);
						},
						parseEase: function parseEase(ease, defaultEase) {
							return arguments.length
								? _parseEase(ease, defaultEase)
								: _easeMap;
						},
						getById: function getById(id) {
							return _globalTimeline.getById(id);
						},
						exportRoot: function exportRoot(vars, includeDelayedCalls) {
							if (vars === void 0) {
								vars = {};
							}
							var tl = new Timeline(vars),
								child,
								next;
							tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
							_globalTimeline.remove(tl);
							tl._dp = 0;
							tl._time = tl._tTime = _globalTimeline._time;
							child = _globalTimeline._first;
							while (child) {
								next = child._next;
								if (
									includeDelayedCalls ||
									!(
										!child._dur &&
										child instanceof Tween &&
										child.vars.onComplete === child._targets[0]
									)
								) {
									_addToTimeline(tl, child, child._start - child._delay);
								}
								child = next;
							}
							_addToTimeline(_globalTimeline, tl, 0);
							return tl;
						},
						utils: {
							wrap: wrap,
							wrapYoyo: wrapYoyo,
							distribute: distribute,
							random: random,
							snap: snap,
							normalize: normalize,
							getUnit: getUnit,
							clamp: clamp,
							splitColor: splitColor,
							toArray: toArray,
							selector: selector,
							mapRange: mapRange,
							pipe: pipe,
							unitize: unitize,
							interpolate: interpolate,
							shuffle: shuffle,
						},
						install: _install,
						effects: _effects,
						ticker: _ticker,
						updateRoot: Timeline.updateRoot,
						plugins: _plugins,
						globalTimeline: _globalTimeline,
						core: {
							PropTween: PropTween,
							globals: _addGlobal,
							Tween: Tween,
							Timeline: Timeline,
							Animation: Animation,
							getCache: _getCache,
							_removeLinkedListItem: _removeLinkedListItem,
							suppressOverwrites: function suppressOverwrites(value) {
								return (_suppressOverwrites = value);
							},
						},
					};
					_forEachName(
						"to,from,fromTo,delayedCall,set,killTweensOf",
						function (name) {
							return (_gsap[name] = Tween[name]);
						}
					);
					_ticker.add(Timeline.updateRoot);
					_quickTween = _gsap.to({}, { duration: 0 });
					var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
							var pt = plugin._pt;
							while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
								pt = pt._next;
							}
							return pt;
						},
						_addModifiers = function _addModifiers(tween, modifiers) {
							var targets = tween._targets,
								p,
								i,
								pt;
							for (p in modifiers) {
								i = targets.length;
								while (i--) {
									pt = tween._ptLookup[i][p];
									if (pt && (pt = pt.d)) {
										if (pt._pt) {
											pt = _getPluginPropTween(pt, p);
										}
										pt &&
											pt.modifier &&
											pt.modifier(modifiers[p], tween, targets[i], p);
									}
								}
							}
						},
						_buildModifierPlugin = function _buildModifierPlugin(
							name,
							modifier
						) {
							return {
								name: name,
								rawVars: 1,
								init: function init(target, vars, tween) {
									tween._onInit = function (tween) {
										var temp, p;
										if (_isString(vars)) {
											temp = {};
											_forEachName(vars, function (name) {
												return (temp[name] = 1);
											});
											vars = temp;
										}
										if (modifier) {
											temp = {};
											for (p in vars) {
												temp[p] = modifier(vars[p]);
											}
											vars = temp;
										}
										_addModifiers(tween, vars);
									};
								},
							};
						};
					var gsap =
						_gsap.registerPlugin(
							{
								name: "attr",
								init: function init(target, vars, tween, index, targets) {
									var p, pt;
									for (p in vars) {
										pt = this.add(
											target,
											"setAttribute",
											(target.getAttribute(p) || 0) + "",
											vars[p],
											index,
											targets,
											0,
											0,
											p
										);
										pt && (pt.op = p);
										this._props.push(p);
									}
								},
							},
							{
								name: "endArray",
								init: function init(target, value) {
									var i = value.length;
									while (i--) {
										this.add(target, i, target[i] || 0, value[i]);
									}
								},
							},
							_buildModifierPlugin("roundProps", _roundModifier),
							_buildModifierPlugin("modifiers"),
							_buildModifierPlugin("snap", snap)
						) || _gsap;
					Tween.version = Timeline.version = gsap.version = "3.8.0";
					_coreReady = 1;
					_windowExists() && _wake();
					var Power0 = _easeMap.Power0,
						Power1 = _easeMap.Power1,
						Power2 = _easeMap.Power2,
						Power3 = _easeMap.Power3,
						Power4 = _easeMap.Power4,
						Linear = _easeMap.Linear,
						Quad = _easeMap.Quad,
						Cubic = _easeMap.Cubic,
						Quart = _easeMap.Quart,
						Quint = _easeMap.Quint,
						Strong = _easeMap.Strong,
						Elastic = _easeMap.Elastic,
						Back = _easeMap.Back,
						SteppedEase = _easeMap.SteppedEase,
						Bounce = _easeMap.Bounce,
						Sine = _easeMap.Sine,
						Expo = _easeMap.Expo,
						Circ = _easeMap.Circ;
					var _win$1,
						_doc$1,
						_docElement,
						_pluginInitted,
						_tempDiv,
						_tempDivStyler,
						_recentSetterPlugin,
						_windowExists$1 = function _windowExists() {
							return typeof window !== "undefined";
						},
						_transformProps = {},
						_RAD2DEG = 180 / Math.PI,
						_DEG2RAD = Math.PI / 180,
						_atan2 = Math.atan2,
						_bigNum$1 = 1e8,
						_capsExp = /([A-Z])/g,
						_horizontalExp = /(?:left|right|width|margin|padding|x)/i,
						_complexExp = /[\s,\(]\S/,
						_propertyAliases = {
							autoAlpha: "opacity,visibility",
							scale: "scaleX,scaleY",
							alpha: "opacity",
						},
						_renderCSSProp = function _renderCSSProp(ratio, data) {
							return data.set(
								data.t,
								data.p,
								Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u,
								data
							);
						},
						_renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
							return data.set(
								data.t,
								data.p,
								ratio === 1
									? data.e
									: Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u,
								data
							);
						},
						_renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(
							ratio,
							data
						) {
							return data.set(
								data.t,
								data.p,
								ratio
									? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u
									: data.b,
								data
							);
						},
						_renderRoundedCSSProp = function _renderRoundedCSSProp(
							ratio,
							data
						) {
							var value = data.s + data.c * ratio;
							data.set(
								data.t,
								data.p,
								~~(value + (value < 0 ? -0.5 : 0.5)) + data.u,
								data
							);
						},
						_renderNonTweeningValue = function _renderNonTweeningValue(
							ratio,
							data
						) {
							return data.set(data.t, data.p, ratio ? data.e : data.b, data);
						},
						_renderNonTweeningValueOnlyAtEnd =
							function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
								return data.set(
									data.t,
									data.p,
									ratio !== 1 ? data.b : data.e,
									data
								);
							},
						_setterCSSStyle = function _setterCSSStyle(
							target,
							property,
							value
						) {
							return (target.style[property] = value);
						},
						_setterCSSProp = function _setterCSSProp(target, property, value) {
							return target.style.setProperty(property, value);
						},
						_setterTransform = function _setterTransform(
							target,
							property,
							value
						) {
							return (target._gsap[property] = value);
						},
						_setterScale = function _setterScale(target, property, value) {
							return (target._gsap.scaleX = target._gsap.scaleY = value);
						},
						_setterScaleWithRender = function _setterScaleWithRender(
							target,
							property,
							value,
							data,
							ratio
						) {
							var cache = target._gsap;
							cache.scaleX = cache.scaleY = value;
							cache.renderTransform(ratio, cache);
						},
						_setterTransformWithRender = function _setterTransformWithRender(
							target,
							property,
							value,
							data,
							ratio
						) {
							var cache = target._gsap;
							cache[property] = value;
							cache.renderTransform(ratio, cache);
						},
						_transformProp = "transform",
						_transformOriginProp = _transformProp + "Origin",
						_supports3D,
						_createElement = function _createElement(type, ns) {
							var e = _doc$1.createElementNS
								? _doc$1.createElementNS(
										(ns || "http://www.w3.org/1999/xhtml").replace(
											/^https/,
											"http"
										),
										type
								  )
								: _doc$1.createElement(type);
							return e.style ? e : _doc$1.createElement(type);
						},
						_getComputedProperty = function _getComputedProperty(
							target,
							property,
							skipPrefixFallback
						) {
							var cs = getComputedStyle(target);
							return (
								cs[property] ||
								cs.getPropertyValue(
									property.replace(_capsExp, "-$1").toLowerCase()
								) ||
								cs.getPropertyValue(property) ||
								(!skipPrefixFallback &&
									_getComputedProperty(
										target,
										_checkPropPrefix(property) || property,
										1
									)) ||
								""
							);
						},
						_prefixes = "O,Moz,ms,Ms,Webkit".split(","),
						_checkPropPrefix = function _checkPropPrefix(
							property,
							element,
							preferPrefix
						) {
							var e = element || _tempDiv,
								s = e.style,
								i = 5;
							if (property in s && !preferPrefix) {
								return property;
							}
							property = property.charAt(0).toUpperCase() + property.substr(1);
							while (i-- && !(_prefixes[i] + property in s)) {}
							return i < 0
								? null
								: (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
						},
						_initCore = function _initCore() {
							if (_windowExists$1() && window.document) {
								_win$1 = window;
								_doc$1 = _win$1.document;
								_docElement = _doc$1.documentElement;
								_tempDiv = _createElement("div") || { style: {} };
								_tempDivStyler = _createElement("div");
								_transformProp = _checkPropPrefix(_transformProp);
								_transformOriginProp = _transformProp + "Origin";
								_tempDiv.style.cssText =
									"border-width:0;line-height:0;position:absolute;padding:0";
								_supports3D = !!_checkPropPrefix("perspective");
								_pluginInitted = 1;
							}
						},
						_getBBoxHack = function _getBBoxHack(swapIfPossible) {
							var svg = _createElement(
									"svg",
									(this.ownerSVGElement &&
										this.ownerSVGElement.getAttribute("xmlns")) ||
										"http://www.w3.org/2000/svg"
								),
								oldParent = this.parentNode,
								oldSibling = this.nextSibling,
								oldCSS = this.style.cssText,
								bbox;
							_docElement.appendChild(svg);
							svg.appendChild(this);
							this.style.display = "block";
							if (swapIfPossible) {
								try {
									bbox = this.getBBox();
									this._gsapBBox = this.getBBox;
									this.getBBox = _getBBoxHack;
								} catch (e) {}
							} else if (this._gsapBBox) {
								bbox = this._gsapBBox();
							}
							if (oldParent) {
								if (oldSibling) {
									oldParent.insertBefore(this, oldSibling);
								} else {
									oldParent.appendChild(this);
								}
							}
							_docElement.removeChild(svg);
							this.style.cssText = oldCSS;
							return bbox;
						},
						_getAttributeFallbacks = function _getAttributeFallbacks(
							target,
							attributesArray
						) {
							var i = attributesArray.length;
							while (i--) {
								if (target.hasAttribute(attributesArray[i])) {
									return target.getAttribute(attributesArray[i]);
								}
							}
						},
						_getBBox = function _getBBox(target) {
							var bounds;
							try {
								bounds = target.getBBox();
							} catch (error) {
								bounds = _getBBoxHack.call(target, true);
							}
							(bounds && (bounds.width || bounds.height)) ||
								target.getBBox === _getBBoxHack ||
								(bounds = _getBBoxHack.call(target, true));
							return bounds && !bounds.width && !bounds.x && !bounds.y
								? {
										x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
										y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
										width: 0,
										height: 0,
								  }
								: bounds;
						},
						_isSVG = function _isSVG(e) {
							return !!(
								e.getCTM &&
								(!e.parentNode || e.ownerSVGElement) &&
								_getBBox(e)
							);
						},
						_removeProperty = function _removeProperty(target, property) {
							if (property) {
								var style = target.style;
								if (
									property in _transformProps &&
									property !== _transformOriginProp
								) {
									property = _transformProp;
								}
								if (style.removeProperty) {
									if (
										property.substr(0, 2) === "ms" ||
										property.substr(0, 6) === "webkit"
									) {
										property = "-" + property;
									}
									style.removeProperty(
										property.replace(_capsExp, "-$1").toLowerCase()
									);
								} else {
									style.removeAttribute(property);
								}
							}
						},
						_addNonTweeningPT = function _addNonTweeningPT(
							plugin,
							target,
							property,
							beginning,
							end,
							onlySetAtEnd
						) {
							var pt = new PropTween(
								plugin._pt,
								target,
								property,
								0,
								1,
								onlySetAtEnd
									? _renderNonTweeningValueOnlyAtEnd
									: _renderNonTweeningValue
							);
							plugin._pt = pt;
							pt.b = beginning;
							pt.e = end;
							plugin._props.push(property);
							return pt;
						},
						_nonConvertibleUnits = { deg: 1, rad: 1, turn: 1 },
						_convertToUnit = function _convertToUnit(
							target,
							property,
							value,
							unit
						) {
							var curValue = parseFloat(value) || 0,
								curUnit =
									(value + "").trim().substr((curValue + "").length) || "px",
								style = _tempDiv.style,
								horizontal = _horizontalExp.test(property),
								isRootSVG = target.tagName.toLowerCase() === "svg",
								measureProperty =
									(isRootSVG ? "client" : "offset") +
									(horizontal ? "Width" : "Height"),
								amount = 100,
								toPixels = unit === "px",
								toPercent = unit === "%",
								px,
								parent,
								cache,
								isSVG;
							if (
								unit === curUnit ||
								!curValue ||
								_nonConvertibleUnits[unit] ||
								_nonConvertibleUnits[curUnit]
							) {
								return curValue;
							}
							curUnit !== "px" &&
								!toPixels &&
								(curValue = _convertToUnit(target, property, value, "px"));
							isSVG = target.getCTM && _isSVG(target);
							if (
								(toPercent || curUnit === "%") &&
								(_transformProps[property] || ~property.indexOf("adius"))
							) {
								px = isSVG
									? target.getBBox()[horizontal ? "width" : "height"]
									: target[measureProperty];
								return _round(
									toPercent ? (curValue / px) * amount : (curValue / 100) * px
								);
							}
							style[horizontal ? "width" : "height"] =
								amount + (toPixels ? curUnit : unit);
							parent =
								~property.indexOf("adius") ||
								(unit === "em" && target.appendChild && !isRootSVG)
									? target
									: target.parentNode;
							if (isSVG) {
								parent = (target.ownerSVGElement || {}).parentNode;
							}
							if (!parent || parent === _doc$1 || !parent.appendChild) {
								parent = _doc$1.body;
							}
							cache = parent._gsap;
							if (
								cache &&
								toPercent &&
								cache.width &&
								horizontal &&
								cache.time === _ticker.time
							) {
								return _round((curValue / cache.width) * amount);
							} else {
								(toPercent || curUnit === "%") &&
									(style.position = _getComputedProperty(target, "position"));
								parent === target && (style.position = "static");
								parent.appendChild(_tempDiv);
								px = _tempDiv[measureProperty];
								parent.removeChild(_tempDiv);
								style.position = "absolute";
								if (horizontal && toPercent) {
									cache = _getCache(parent);
									cache.time = _ticker.time;
									cache.width = parent[measureProperty];
								}
							}
							return _round(
								toPixels
									? (px * curValue) / amount
									: px && curValue
									? (amount / px) * curValue
									: 0
							);
						},
						_get = function _get(target, property, unit, uncache) {
							var value;
							_pluginInitted || _initCore();
							if (property in _propertyAliases && property !== "transform") {
								property = _propertyAliases[property];
								if (~property.indexOf(",")) {
									property = property.split(",")[0];
								}
							}
							if (_transformProps[property] && property !== "transform") {
								value = _parseTransform(target, uncache);
								value =
									property !== "transformOrigin"
										? value[property]
										: value.svg
										? value.origin
										: _firstTwoOnly(
												_getComputedProperty(target, _transformOriginProp)
										  ) +
										  " " +
										  value.zOrigin +
										  "px";
							} else {
								value = target.style[property];
								if (
									!value ||
									value === "auto" ||
									uncache ||
									~(value + "").indexOf("calc(")
								) {
									value =
										(_specialProps[property] &&
											_specialProps[property](target, property, unit)) ||
										_getComputedProperty(target, property) ||
										_getProperty(target, property) ||
										(property === "opacity" ? 1 : 0);
								}
							}
							return unit && !~(value + "").trim().indexOf(" ")
								? _convertToUnit(target, property, value, unit) + unit
								: value;
						},
						_tweenComplexCSSString = function _tweenComplexCSSString(
							target,
							prop,
							start,
							end
						) {
							if (!start || start === "none") {
								var p = _checkPropPrefix(prop, target, 1),
									s = p && _getComputedProperty(target, p, 1);
								if (s && s !== start) {
									prop = p;
									start = s;
								} else if (prop === "borderColor") {
									start = _getComputedProperty(target, "borderTopColor");
								}
							}
							var pt = new PropTween(
									this._pt,
									target.style,
									prop,
									0,
									1,
									_renderComplexString
								),
								index = 0,
								matchIndex = 0,
								a,
								result,
								startValues,
								startNum,
								color,
								startValue,
								endValue,
								endNum,
								chunk,
								endUnit,
								startUnit,
								relative,
								endValues;
							pt.b = start;
							pt.e = end;
							start += "";
							end += "";
							if (end === "auto") {
								target.style[prop] = end;
								end = _getComputedProperty(target, prop) || end;
								target.style[prop] = start;
							}
							a = [start, end];
							_colorStringFilter(a);
							start = a[0];
							end = a[1];
							startValues = start.match(_numWithUnitExp) || [];
							endValues = end.match(_numWithUnitExp) || [];
							if (endValues.length) {
								while ((result = _numWithUnitExp.exec(end))) {
									endValue = result[0];
									chunk = end.substring(index, result.index);
									if (color) {
										color = (color + 1) % 5;
									} else if (
										chunk.substr(-5) === "rgba(" ||
										chunk.substr(-5) === "hsla("
									) {
										color = 1;
									}
									if (
										endValue !== (startValue = startValues[matchIndex++] || "")
									) {
										startNum = parseFloat(startValue) || 0;
										startUnit = startValue.substr((startNum + "").length);
										relative =
											endValue.charAt(1) === "="
												? +(endValue.charAt(0) + "1")
												: 0;
										if (relative) {
											endValue = endValue.substr(2);
										}
										endNum = parseFloat(endValue);
										endUnit = endValue.substr((endNum + "").length);
										index = _numWithUnitExp.lastIndex - endUnit.length;
										if (!endUnit) {
											endUnit = endUnit || _config.units[prop] || startUnit;
											if (index === end.length) {
												end += endUnit;
												pt.e += endUnit;
											}
										}
										if (startUnit !== endUnit) {
											startNum =
												_convertToUnit(target, prop, startValue, endUnit) || 0;
										}
										pt._pt = {
											_next: pt._pt,
											p: chunk || matchIndex === 1 ? chunk : ",",
											s: startNum,
											c: relative ? relative * endNum : endNum - startNum,
											m:
												(color && color < 4) || prop === "zIndex"
													? Math.round
													: 0,
										};
									}
								}
								pt.c =
									index < end.length ? end.substring(index, end.length) : "";
							} else {
								pt.r =
									prop === "display" && end === "none"
										? _renderNonTweeningValueOnlyAtEnd
										: _renderNonTweeningValue;
							}
							_relExp.test(end) && (pt.e = 0);
							this._pt = pt;
							return pt;
						},
						_keywordToPercent = {
							top: "0%",
							bottom: "100%",
							left: "0%",
							right: "100%",
							center: "50%",
						},
						_convertKeywordsToPercentages =
							function _convertKeywordsToPercentages(value) {
								var split = value.split(" "),
									x = split[0],
									y = split[1] || "50%";
								if (
									x === "top" ||
									x === "bottom" ||
									y === "left" ||
									y === "right"
								) {
									value = x;
									x = y;
									y = value;
								}
								split[0] = _keywordToPercent[x] || x;
								split[1] = _keywordToPercent[y] || y;
								return split.join(" ");
							},
						_renderClearProps = function _renderClearProps(ratio, data) {
							if (data.tween && data.tween._time === data.tween._dur) {
								var target = data.t,
									style = target.style,
									props = data.u,
									cache = target._gsap,
									prop,
									clearTransforms,
									i;
								if (props === "all" || props === true) {
									style.cssText = "";
									clearTransforms = 1;
								} else {
									props = props.split(",");
									i = props.length;
									while (--i > -1) {
										prop = props[i];
										if (_transformProps[prop]) {
											clearTransforms = 1;
											prop =
												prop === "transformOrigin"
													? _transformOriginProp
													: _transformProp;
										}
										_removeProperty(target, prop);
									}
								}
								if (clearTransforms) {
									_removeProperty(target, _transformProp);
									if (cache) {
										cache.svg && target.removeAttribute("transform");
										_parseTransform(target, 1);
										cache.uncache = 1;
									}
								}
							}
						},
						_specialProps = {
							clearProps: function clearProps(
								plugin,
								target,
								property,
								endValue,
								tween
							) {
								if (tween.data !== "isFromStart") {
									var pt = (plugin._pt = new PropTween(
										plugin._pt,
										target,
										property,
										0,
										0,
										_renderClearProps
									));
									pt.u = endValue;
									pt.pr = -10;
									pt.tween = tween;
									plugin._props.push(property);
									return 1;
								}
							},
						},
						_identity2DMatrix = [1, 0, 0, 1, 0, 0],
						_rotationalProperties = {},
						_isNullTransform = function _isNullTransform(value) {
							return (
								value === "matrix(1, 0, 0, 1, 0, 0)" ||
								value === "none" ||
								!value
							);
						},
						_getComputedTransformMatrixAsArray =
							function _getComputedTransformMatrixAsArray(target) {
								var matrixString = _getComputedProperty(target, _transformProp);
								return _isNullTransform(matrixString)
									? _identity2DMatrix
									: matrixString.substr(7).match(_numExp).map(_round);
							},
						_getMatrix = function _getMatrix(target, force2D) {
							var cache = target._gsap || _getCache(target),
								style = target.style,
								matrix = _getComputedTransformMatrixAsArray(target),
								parent,
								nextSibling,
								temp,
								addedToDOM;
							if (cache.svg && target.getAttribute("transform")) {
								temp = target.transform.baseVal.consolidate().matrix;
								matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
								return matrix.join(",") === "1,0,0,1,0,0"
									? _identity2DMatrix
									: matrix;
							} else if (
								matrix === _identity2DMatrix &&
								!target.offsetParent &&
								target !== _docElement &&
								!cache.svg
							) {
								temp = style.display;
								style.display = "block";
								parent = target.parentNode;
								if (!parent || !target.offsetParent) {
									addedToDOM = 1;
									nextSibling = target.nextSibling;
									_docElement.appendChild(target);
								}
								matrix = _getComputedTransformMatrixAsArray(target);
								temp
									? (style.display = temp)
									: _removeProperty(target, "display");
								if (addedToDOM) {
									nextSibling
										? parent.insertBefore(target, nextSibling)
										: parent
										? parent.appendChild(target)
										: _docElement.removeChild(target);
								}
							}
							return force2D && matrix.length > 6
								? [
										matrix[0],
										matrix[1],
										matrix[4],
										matrix[5],
										matrix[12],
										matrix[13],
								  ]
								: matrix;
						},
						_applySVGOrigin = function _applySVGOrigin(
							target,
							origin,
							originIsAbsolute,
							smooth,
							matrixArray,
							pluginToAddPropTweensTo
						) {
							var cache = target._gsap,
								matrix = matrixArray || _getMatrix(target, true),
								xOriginOld = cache.xOrigin || 0,
								yOriginOld = cache.yOrigin || 0,
								xOffsetOld = cache.xOffset || 0,
								yOffsetOld = cache.yOffset || 0,
								a = matrix[0],
								b = matrix[1],
								c = matrix[2],
								d = matrix[3],
								tx = matrix[4],
								ty = matrix[5],
								originSplit = origin.split(" "),
								xOrigin = parseFloat(originSplit[0]) || 0,
								yOrigin = parseFloat(originSplit[1]) || 0,
								bounds,
								determinant,
								x,
								y;
							if (!originIsAbsolute) {
								bounds = _getBBox(target);
								xOrigin =
									bounds.x +
									(~originSplit[0].indexOf("%")
										? (xOrigin / 100) * bounds.width
										: xOrigin);
								yOrigin =
									bounds.y +
									(~(originSplit[1] || originSplit[0]).indexOf("%")
										? (yOrigin / 100) * bounds.height
										: yOrigin);
							} else if (
								matrix !== _identity2DMatrix &&
								(determinant = a * d - b * c)
							) {
								x =
									xOrigin * (d / determinant) +
									yOrigin * (-c / determinant) +
									(c * ty - d * tx) / determinant;
								y =
									xOrigin * (-b / determinant) +
									yOrigin * (a / determinant) -
									(a * ty - b * tx) / determinant;
								xOrigin = x;
								yOrigin = y;
							}
							if (smooth || (smooth !== false && cache.smooth)) {
								tx = xOrigin - xOriginOld;
								ty = yOrigin - yOriginOld;
								cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
								cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
							} else {
								cache.xOffset = cache.yOffset = 0;
							}
							cache.xOrigin = xOrigin;
							cache.yOrigin = yOrigin;
							cache.smooth = !!smooth;
							cache.origin = origin;
							cache.originIsAbsolute = !!originIsAbsolute;
							target.style[_transformOriginProp] = "0px 0px";
							if (pluginToAddPropTweensTo) {
								_addNonTweeningPT(
									pluginToAddPropTweensTo,
									cache,
									"xOrigin",
									xOriginOld,
									xOrigin
								);
								_addNonTweeningPT(
									pluginToAddPropTweensTo,
									cache,
									"yOrigin",
									yOriginOld,
									yOrigin
								);
								_addNonTweeningPT(
									pluginToAddPropTweensTo,
									cache,
									"xOffset",
									xOffsetOld,
									cache.xOffset
								);
								_addNonTweeningPT(
									pluginToAddPropTweensTo,
									cache,
									"yOffset",
									yOffsetOld,
									cache.yOffset
								);
							}
							target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
						},
						_parseTransform = function _parseTransform(target, uncache) {
							var cache = target._gsap || new GSCache(target);
							if ("x" in cache && !uncache && !cache.uncache) {
								return cache;
							}
							var style = target.style,
								invertedScaleX = cache.scaleX < 0,
								px = "px",
								deg = "deg",
								origin =
									_getComputedProperty(target, _transformOriginProp) || "0",
								x,
								y,
								z,
								scaleX,
								scaleY,
								rotation,
								rotationX,
								rotationY,
								skewX,
								skewY,
								perspective,
								xOrigin,
								yOrigin,
								matrix,
								angle,
								cos,
								sin,
								a,
								b,
								c,
								d,
								a12,
								a22,
								t1,
								t2,
								t3,
								a13,
								a23,
								a33,
								a42,
								a43,
								a32;
							x =
								y =
								z =
								rotation =
								rotationX =
								rotationY =
								skewX =
								skewY =
								perspective =
									0;
							scaleX = scaleY = 1;
							cache.svg = !!(target.getCTM && _isSVG(target));
							matrix = _getMatrix(target, cache.svg);
							if (cache.svg) {
								t1 =
									(!cache.uncache || origin === "0px 0px") &&
									!uncache &&
									target.getAttribute("data-svg-origin");
								_applySVGOrigin(
									target,
									t1 || origin,
									!!t1 || cache.originIsAbsolute,
									cache.smooth !== false,
									matrix
								);
							}
							xOrigin = cache.xOrigin || 0;
							yOrigin = cache.yOrigin || 0;
							if (matrix !== _identity2DMatrix) {
								a = matrix[0];
								b = matrix[1];
								c = matrix[2];
								d = matrix[3];
								x = a12 = matrix[4];
								y = a22 = matrix[5];
								if (matrix.length === 6) {
									scaleX = Math.sqrt(a * a + b * b);
									scaleY = Math.sqrt(d * d + c * c);
									rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;
									skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
									skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
									if (cache.svg) {
										x -= xOrigin - (xOrigin * a + yOrigin * c);
										y -= yOrigin - (xOrigin * b + yOrigin * d);
									}
								} else {
									a32 = matrix[6];
									a42 = matrix[7];
									a13 = matrix[8];
									a23 = matrix[9];
									a33 = matrix[10];
									a43 = matrix[11];
									x = matrix[12];
									y = matrix[13];
									z = matrix[14];
									angle = _atan2(a32, a33);
									rotationX = angle * _RAD2DEG;
									if (angle) {
										cos = Math.cos(-angle);
										sin = Math.sin(-angle);
										t1 = a12 * cos + a13 * sin;
										t2 = a22 * cos + a23 * sin;
										t3 = a32 * cos + a33 * sin;
										a13 = a12 * -sin + a13 * cos;
										a23 = a22 * -sin + a23 * cos;
										a33 = a32 * -sin + a33 * cos;
										a43 = a42 * -sin + a43 * cos;
										a12 = t1;
										a22 = t2;
										a32 = t3;
									}
									angle = _atan2(-c, a33);
									rotationY = angle * _RAD2DEG;
									if (angle) {
										cos = Math.cos(-angle);
										sin = Math.sin(-angle);
										t1 = a * cos - a13 * sin;
										t2 = b * cos - a23 * sin;
										t3 = c * cos - a33 * sin;
										a43 = d * sin + a43 * cos;
										a = t1;
										b = t2;
										c = t3;
									}
									angle = _atan2(b, a);
									rotation = angle * _RAD2DEG;
									if (angle) {
										cos = Math.cos(angle);
										sin = Math.sin(angle);
										t1 = a * cos + b * sin;
										t2 = a12 * cos + a22 * sin;
										b = b * cos - a * sin;
										a22 = a22 * cos - a12 * sin;
										a = t1;
										a12 = t2;
									}
									if (
										rotationX &&
										Math.abs(rotationX) + Math.abs(rotation) > 359.9
									) {
										rotationX = rotation = 0;
										rotationY = 180 - rotationY;
									}
									scaleX = _round(Math.sqrt(a * a + b * b + c * c));
									scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
									angle = _atan2(a12, a22);
									skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
									perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
								}
								if (cache.svg) {
									t1 = target.getAttribute("transform");
									cache.forceCSS =
										target.setAttribute("transform", "") ||
										!_isNullTransform(
											_getComputedProperty(target, _transformProp)
										);
									t1 && target.setAttribute("transform", t1);
								}
							}
							if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
								if (invertedScaleX) {
									scaleX *= -1;
									skewX += rotation <= 0 ? 180 : -180;
									rotation += rotation <= 0 ? 180 : -180;
								} else {
									scaleY *= -1;
									skewX += skewX <= 0 ? 180 : -180;
								}
							}
							cache.x =
								x -
								((cache.xPercent =
									x &&
									(cache.xPercent ||
										(Math.round(target.offsetWidth / 2) === Math.round(-x)
											? -50
											: 0)))
									? (target.offsetWidth * cache.xPercent) / 100
									: 0) +
								px;
							cache.y =
								y -
								((cache.yPercent =
									y &&
									(cache.yPercent ||
										(Math.round(target.offsetHeight / 2) === Math.round(-y)
											? -50
											: 0)))
									? (target.offsetHeight * cache.yPercent) / 100
									: 0) +
								px;
							cache.z = z + px;
							cache.scaleX = _round(scaleX);
							cache.scaleY = _round(scaleY);
							cache.rotation = _round(rotation) + deg;
							cache.rotationX = _round(rotationX) + deg;
							cache.rotationY = _round(rotationY) + deg;
							cache.skewX = skewX + deg;
							cache.skewY = skewY + deg;
							cache.transformPerspective = perspective + px;
							if ((cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0)) {
								style[_transformOriginProp] = _firstTwoOnly(origin);
							}
							cache.xOffset = cache.yOffset = 0;
							cache.force3D = _config.force3D;
							cache.renderTransform = cache.svg
								? _renderSVGTransforms
								: _supports3D
								? _renderCSSTransforms
								: _renderNon3DTransforms;
							cache.uncache = 0;
							return cache;
						},
						_firstTwoOnly = function _firstTwoOnly(value) {
							return (value = value.split(" "))[0] + " " + value[1];
						},
						_addPxTranslate = function _addPxTranslate(target, start, value) {
							var unit = getUnit(start);
							return (
								_round(
									parseFloat(start) +
										parseFloat(_convertToUnit(target, "x", value + "px", unit))
								) + unit
							);
						},
						_renderNon3DTransforms = function _renderNon3DTransforms(
							ratio,
							cache
						) {
							cache.z = "0px";
							cache.rotationY = cache.rotationX = "0deg";
							cache.force3D = 0;
							_renderCSSTransforms(ratio, cache);
						},
						_zeroDeg = "0deg",
						_zeroPx = "0px",
						_endParenthesis = ") ",
						_renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
							var _ref = cache || this,
								xPercent = _ref.xPercent,
								yPercent = _ref.yPercent,
								x = _ref.x,
								y = _ref.y,
								z = _ref.z,
								rotation = _ref.rotation,
								rotationY = _ref.rotationY,
								rotationX = _ref.rotationX,
								skewX = _ref.skewX,
								skewY = _ref.skewY,
								scaleX = _ref.scaleX,
								scaleY = _ref.scaleY,
								transformPerspective = _ref.transformPerspective,
								force3D = _ref.force3D,
								target = _ref.target,
								zOrigin = _ref.zOrigin,
								transforms = "",
								use3D =
									(force3D === "auto" && ratio && ratio !== 1) ||
									force3D === true;
							if (
								zOrigin &&
								(rotationX !== _zeroDeg || rotationY !== _zeroDeg)
							) {
								var angle = parseFloat(rotationY) * _DEG2RAD,
									a13 = Math.sin(angle),
									a33 = Math.cos(angle),
									cos;
								angle = parseFloat(rotationX) * _DEG2RAD;
								cos = Math.cos(angle);
								x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
								y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
								z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
							}
							if (transformPerspective !== _zeroPx) {
								transforms +=
									"perspective(" + transformPerspective + _endParenthesis;
							}
							if (xPercent || yPercent) {
								transforms +=
									"translate(" + xPercent + "%, " + yPercent + "%) ";
							}
							if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
								transforms +=
									z !== _zeroPx || use3D
										? "translate3d(" + x + ", " + y + ", " + z + ") "
										: "translate(" + x + ", " + y + _endParenthesis;
							}
							if (rotation !== _zeroDeg) {
								transforms += "rotate(" + rotation + _endParenthesis;
							}
							if (rotationY !== _zeroDeg) {
								transforms += "rotateY(" + rotationY + _endParenthesis;
							}
							if (rotationX !== _zeroDeg) {
								transforms += "rotateX(" + rotationX + _endParenthesis;
							}
							if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
								transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
							}
							if (scaleX !== 1 || scaleY !== 1) {
								transforms +=
									"scale(" + scaleX + ", " + scaleY + _endParenthesis;
							}
							target.style[_transformProp] = transforms || "translate(0, 0)";
						},
						_renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
							var _ref2 = cache || this,
								xPercent = _ref2.xPercent,
								yPercent = _ref2.yPercent,
								x = _ref2.x,
								y = _ref2.y,
								rotation = _ref2.rotation,
								skewX = _ref2.skewX,
								skewY = _ref2.skewY,
								scaleX = _ref2.scaleX,
								scaleY = _ref2.scaleY,
								target = _ref2.target,
								xOrigin = _ref2.xOrigin,
								yOrigin = _ref2.yOrigin,
								xOffset = _ref2.xOffset,
								yOffset = _ref2.yOffset,
								forceCSS = _ref2.forceCSS,
								tx = parseFloat(x),
								ty = parseFloat(y),
								a11,
								a21,
								a12,
								a22,
								temp;
							rotation = parseFloat(rotation);
							skewX = parseFloat(skewX);
							skewY = parseFloat(skewY);
							if (skewY) {
								skewY = parseFloat(skewY);
								skewX += skewY;
								rotation += skewY;
							}
							if (rotation || skewX) {
								rotation *= _DEG2RAD;
								skewX *= _DEG2RAD;
								a11 = Math.cos(rotation) * scaleX;
								a21 = Math.sin(rotation) * scaleX;
								a12 = Math.sin(rotation - skewX) * -scaleY;
								a22 = Math.cos(rotation - skewX) * scaleY;
								if (skewX) {
									skewY *= _DEG2RAD;
									temp = Math.tan(skewX - skewY);
									temp = Math.sqrt(1 + temp * temp);
									a12 *= temp;
									a22 *= temp;
									if (skewY) {
										temp = Math.tan(skewY);
										temp = Math.sqrt(1 + temp * temp);
										a11 *= temp;
										a21 *= temp;
									}
								}
								a11 = _round(a11);
								a21 = _round(a21);
								a12 = _round(a12);
								a22 = _round(a22);
							} else {
								a11 = scaleX;
								a22 = scaleY;
								a21 = a12 = 0;
							}
							if (
								(tx && !~(x + "").indexOf("px")) ||
								(ty && !~(y + "").indexOf("px"))
							) {
								tx = _convertToUnit(target, "x", x, "px");
								ty = _convertToUnit(target, "y", y, "px");
							}
							if (xOrigin || yOrigin || xOffset || yOffset) {
								tx = _round(
									tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset
								);
								ty = _round(
									ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset
								);
							}
							if (xPercent || yPercent) {
								temp = target.getBBox();
								tx = _round(tx + (xPercent / 100) * temp.width);
								ty = _round(ty + (yPercent / 100) * temp.height);
							}
							temp =
								"matrix(" +
								a11 +
								"," +
								a21 +
								"," +
								a12 +
								"," +
								a22 +
								"," +
								tx +
								"," +
								ty +
								")";
							target.setAttribute("transform", temp);
							forceCSS && (target.style[_transformProp] = temp);
						},
						_addRotationalPropTween = function _addRotationalPropTween(
							plugin,
							target,
							property,
							startNum,
							endValue,
							relative
						) {
							var cap = 360,
								isString = _isString(endValue),
								endNum =
									parseFloat(endValue) *
									(isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
								change = relative ? endNum * relative : endNum - startNum,
								finalValue = startNum + change + "deg",
								direction,
								pt;
							if (isString) {
								direction = endValue.split("_")[1];
								if (direction === "short") {
									change %= cap;
									if (change !== change % (cap / 2)) {
										change += change < 0 ? cap : -cap;
									}
								}
								if (direction === "cw" && change < 0) {
									change =
										((change + cap * _bigNum$1) % cap) - ~~(change / cap) * cap;
								} else if (direction === "ccw" && change > 0) {
									change =
										((change - cap * _bigNum$1) % cap) - ~~(change / cap) * cap;
								}
							}
							plugin._pt = pt = new PropTween(
								plugin._pt,
								target,
								property,
								startNum,
								change,
								_renderPropWithEnd
							);
							pt.e = finalValue;
							pt.u = "deg";
							plugin._props.push(property);
							return pt;
						},
						_assign = function _assign(target, source) {
							for (var p in source) {
								target[p] = source[p];
							}
							return target;
						},
						_addRawTransformPTs = function _addRawTransformPTs(
							plugin,
							transforms,
							target
						) {
							var startCache = _assign({}, target._gsap),
								exclude = "perspective,force3D,transformOrigin,svgOrigin",
								style = target.style,
								endCache,
								p,
								startValue,
								endValue,
								startNum,
								endNum,
								startUnit,
								endUnit;
							if (startCache.svg) {
								startValue = target.getAttribute("transform");
								target.setAttribute("transform", "");
								style[_transformProp] = transforms;
								endCache = _parseTransform(target, 1);
								_removeProperty(target, _transformProp);
								target.setAttribute("transform", startValue);
							} else {
								startValue = getComputedStyle(target)[_transformProp];
								style[_transformProp] = transforms;
								endCache = _parseTransform(target, 1);
								style[_transformProp] = startValue;
							}
							for (p in _transformProps) {
								startValue = startCache[p];
								endValue = endCache[p];
								if (startValue !== endValue && exclude.indexOf(p) < 0) {
									startUnit = getUnit(startValue);
									endUnit = getUnit(endValue);
									startNum =
										startUnit !== endUnit
											? _convertToUnit(target, p, startValue, endUnit)
											: parseFloat(startValue);
									endNum = parseFloat(endValue);
									plugin._pt = new PropTween(
										plugin._pt,
										endCache,
										p,
										startNum,
										endNum - startNum,
										_renderCSSProp
									);
									plugin._pt.u = endUnit || 0;
									plugin._props.push(p);
								}
							}
							_assign(endCache, startCache);
						};
					_forEachName("padding,margin,Width,Radius", function (name, index) {
						var t = "Top",
							r = "Right",
							b = "Bottom",
							l = "Left",
							props = (
								index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]
							).map(function (side) {
								return index < 2 ? name + side : "border" + side + name;
							});
						_specialProps[index > 1 ? "border" + name : name] = function (
							plugin,
							target,
							property,
							endValue,
							tween
						) {
							var a, vars;
							if (arguments.length < 4) {
								a = props.map(function (prop) {
									return _get(plugin, prop, property);
								});
								vars = a.join(" ");
								return vars.split(a[0]).length === 5 ? a[0] : vars;
							}
							a = (endValue + "").split(" ");
							vars = {};
							props.forEach(function (prop, i) {
								return (vars[prop] = a[i] = a[i] || a[((i - 1) / 2) | 0]);
							});
							plugin.init(target, vars, tween);
						};
					});
					var CSSPlugin = {
						name: "css",
						register: _initCore,
						targetTest: function targetTest(target) {
							return target.style && target.nodeType;
						},
						init: function init(target, vars, tween, index, targets) {
							var props = this._props,
								style = target.style,
								startAt = tween.vars.startAt,
								startValue,
								endValue,
								endNum,
								startNum,
								type,
								specialProp,
								p,
								startUnit,
								endUnit,
								relative,
								isTransformRelated,
								transformPropTween,
								cache,
								smooth,
								hasPriority;
							_pluginInitted || _initCore();
							for (p in vars) {
								if (p === "autoRound") {
									continue;
								}
								endValue = vars[p];
								if (
									_plugins[p] &&
									_checkPlugin(p, vars, tween, index, target, targets)
								) {
									continue;
								}
								type = typeof endValue;
								specialProp = _specialProps[p];
								if (type === "function") {
									endValue = endValue.call(tween, index, target, targets);
									type = typeof endValue;
								}
								if (type === "string" && ~endValue.indexOf("random(")) {
									endValue = _replaceRandom(endValue);
								}
								if (specialProp) {
									specialProp(this, target, p, endValue, tween) &&
										(hasPriority = 1);
								} else if (p.substr(0, 2) === "--") {
									startValue = (
										getComputedStyle(target).getPropertyValue(p) + ""
									).trim();
									endValue += "";
									_colorExp.lastIndex = 0;
									if (!_colorExp.test(startValue)) {
										startUnit = getUnit(startValue);
										endUnit = getUnit(endValue);
									}
									endUnit
										? startUnit !== endUnit &&
										  (startValue =
												_convertToUnit(target, p, startValue, endUnit) +
												endUnit)
										: startUnit && (endValue += startUnit);
									this.add(
										style,
										"setProperty",
										startValue,
										endValue,
										index,
										targets,
										0,
										0,
										p
									);
									props.push(p);
								} else if (type !== "undefined") {
									if (startAt && p in startAt) {
										startValue =
											typeof startAt[p] === "function"
												? startAt[p].call(tween, index, target, targets)
												: startAt[p];
										p in _config.units &&
											!getUnit(startValue) &&
											(startValue += _config.units[p]);
										_isString(startValue) &&
											~startValue.indexOf("random(") &&
											(startValue = _replaceRandom(startValue));
										(startValue + "").charAt(1) === "=" &&
											(startValue = _get(target, p));
									} else {
										startValue = _get(target, p);
									}
									startNum = parseFloat(startValue);
									relative =
										type === "string" && endValue.charAt(1) === "="
											? +(endValue.charAt(0) + "1")
											: 0;
									relative && (endValue = endValue.substr(2));
									endNum = parseFloat(endValue);
									if (p in _propertyAliases) {
										if (p === "autoAlpha") {
											if (
												startNum === 1 &&
												_get(target, "visibility") === "hidden" &&
												endNum
											) {
												startNum = 0;
											}
											_addNonTweeningPT(
												this,
												style,
												"visibility",
												startNum ? "inherit" : "hidden",
												endNum ? "inherit" : "hidden",
												!endNum
											);
										}
										if (p !== "scale" && p !== "transform") {
											p = _propertyAliases[p];
											~p.indexOf(",") && (p = p.split(",")[0]);
										}
									}
									isTransformRelated = p in _transformProps;
									if (isTransformRelated) {
										if (!transformPropTween) {
											cache = target._gsap;
											(cache.renderTransform && !vars.parseTransform) ||
												_parseTransform(target, vars.parseTransform);
											smooth = vars.smoothOrigin !== false && cache.smooth;
											transformPropTween = this._pt = new PropTween(
												this._pt,
												style,
												_transformProp,
												0,
												1,
												cache.renderTransform,
												cache,
												0,
												-1
											);
											transformPropTween.dep = 1;
										}
										if (p === "scale") {
											this._pt = new PropTween(
												this._pt,
												cache,
												"scaleY",
												cache.scaleY,
												(relative
													? relative * endNum
													: endNum - cache.scaleY) || 0
											);
											props.push("scaleY", p);
											p += "X";
										} else if (p === "transformOrigin") {
											endValue = _convertKeywordsToPercentages(endValue);
											if (cache.svg) {
												_applySVGOrigin(target, endValue, 0, smooth, 0, this);
											} else {
												endUnit = parseFloat(endValue.split(" ")[2]) || 0;
												endUnit !== cache.zOrigin &&
													_addNonTweeningPT(
														this,
														cache,
														"zOrigin",
														cache.zOrigin,
														endUnit
													);
												_addNonTweeningPT(
													this,
													style,
													p,
													_firstTwoOnly(startValue),
													_firstTwoOnly(endValue)
												);
											}
											continue;
										} else if (p === "svgOrigin") {
											_applySVGOrigin(target, endValue, 1, smooth, 0, this);
											continue;
										} else if (p in _rotationalProperties) {
											_addRotationalPropTween(
												this,
												cache,
												p,
												startNum,
												endValue,
												relative
											);
											continue;
										} else if (p === "smoothOrigin") {
											_addNonTweeningPT(
												this,
												cache,
												"smooth",
												cache.smooth,
												endValue
											);
											continue;
										} else if (p === "force3D") {
											cache[p] = endValue;
											continue;
										} else if (p === "transform") {
											_addRawTransformPTs(this, endValue, target);
											continue;
										}
									} else if (!(p in style)) {
										p = _checkPropPrefix(p) || p;
									}
									if (
										isTransformRelated ||
										((endNum || endNum === 0) &&
											(startNum || startNum === 0) &&
											!_complexExp.test(endValue) &&
											p in style)
									) {
										startUnit = (startValue + "").substr(
											(startNum + "").length
										);
										endNum || (endNum = 0);
										endUnit =
											getUnit(endValue) ||
											(p in _config.units ? _config.units[p] : startUnit);
										startUnit !== endUnit &&
											(startNum = _convertToUnit(
												target,
												p,
												startValue,
												endUnit
											));
										this._pt = new PropTween(
											this._pt,
											isTransformRelated ? cache : style,
											p,
											startNum,
											relative ? relative * endNum : endNum - startNum,
											!isTransformRelated &&
											(endUnit === "px" || p === "zIndex") &&
											vars.autoRound !== false
												? _renderRoundedCSSProp
												: _renderCSSProp
										);
										this._pt.u = endUnit || 0;
										if (startUnit !== endUnit && endUnit !== "%") {
											this._pt.b = startValue;
											this._pt.r = _renderCSSPropWithBeginning;
										}
									} else if (!(p in style)) {
										if (p in target) {
											this.add(
												target,
												p,
												startValue || target[p],
												endValue,
												index,
												targets
											);
										} else {
											_missingPlugin(p, endValue);
											continue;
										}
									} else {
										_tweenComplexCSSString.call(
											this,
											target,
											p,
											startValue,
											endValue
										);
									}
									props.push(p);
								}
							}
							hasPriority && _sortPropTweensByPriority(this);
						},
						get: _get,
						aliases: _propertyAliases,
						getSetter: function getSetter(target, property, plugin) {
							var p = _propertyAliases[property];
							p && p.indexOf(",") < 0 && (property = p);
							return property in _transformProps &&
								property !== _transformOriginProp &&
								(target._gsap.x || _get(target, "x"))
								? plugin && _recentSetterPlugin === plugin
									? property === "scale"
										? _setterScale
										: _setterTransform
									: (_recentSetterPlugin = plugin || {}) &&
									  (property === "scale"
											? _setterScaleWithRender
											: _setterTransformWithRender)
								: target.style && !_isUndefined(target.style[property])
								? _setterCSSStyle
								: ~property.indexOf("-")
								? _setterCSSProp
								: _getSetter(target, property);
						},
						core: { _removeProperty: _removeProperty, _getMatrix: _getMatrix },
					};
					gsap.utils.checkPrefix = _checkPropPrefix;
					(function (positionAndScale, rotation, others, aliases) {
						var all = _forEachName(
							positionAndScale + "," + rotation + "," + others,
							function (name) {
								_transformProps[name] = 1;
							}
						);
						_forEachName(rotation, function (name) {
							_config.units[name] = "deg";
							_rotationalProperties[name] = 1;
						});
						_propertyAliases[all[13]] = positionAndScale + "," + rotation;
						_forEachName(aliases, function (name) {
							var split = name.split(":");
							_propertyAliases[split[1]] = all[split[0]];
						});
					})(
						"x,y,z,scale,scaleX,scaleY,xPercent,yPercent",
						"rotation,rotationX,rotationY,skewX,skewY",
						"transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
						"0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"
					);
					_forEachName(
						"x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
						function (name) {
							_config.units[name] = "px";
						}
					);
					gsap.registerPlugin(CSSPlugin);
					var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap,
						TweenMaxWithCSS = gsapWithCSS.core.Tween;
					exports.Back = Back;
					exports.Bounce = Bounce;
					exports.CSSPlugin = CSSPlugin;
					exports.Circ = Circ;
					exports.Cubic = Cubic;
					exports.Elastic = Elastic;
					exports.Expo = Expo;
					exports.Linear = Linear;
					exports.Power0 = Power0;
					exports.Power1 = Power1;
					exports.Power2 = Power2;
					exports.Power3 = Power3;
					exports.Power4 = Power4;
					exports.Quad = Quad;
					exports.Quart = Quart;
					exports.Quint = Quint;
					exports.Sine = Sine;
					exports.SteppedEase = SteppedEase;
					exports.Strong = Strong;
					exports.TimelineLite = Timeline;
					exports.TimelineMax = Timeline;
					exports.TweenLite = Tween;
					exports.TweenMax = TweenMaxWithCSS;
					exports.default = gsapWithCSS;
					exports.gsap = gsapWithCSS;
					if (typeof window === "undefined" || window !== exports) {
						Object.defineProperty(exports, "__esModule", { value: true });
					} else {
						delete window.default;
					}
				});
			},
			{},
		],
		8: [
			function (require, module, exports) {
				typeof window !== "undefined" &&
					(function webpackUniversalModuleDefinition(root, factory) {
						if (typeof exports === "object" && typeof module === "object")
							module.exports = factory();
						else if (typeof define === "function" && define.amd)
							define([], factory);
						else if (typeof exports === "object") exports["Hls"] = factory();
						else root["Hls"] = factory();
					})(this, function () {
						return (function (modules) {
							var installedModules = {};
							function __webpack_require__(moduleId) {
								if (installedModules[moduleId]) {
									return installedModules[moduleId].exports;
								}
								var module = (installedModules[moduleId] = {
									i: moduleId,
									l: false,
									exports: {},
								});
								modules[moduleId].call(
									module.exports,
									module,
									module.exports,
									__webpack_require__
								);
								module.l = true;
								return module.exports;
							}
							__webpack_require__.m = modules;
							__webpack_require__.c = installedModules;
							__webpack_require__.d = function (exports, name, getter) {
								if (!__webpack_require__.o(exports, name)) {
									Object.defineProperty(exports, name, {
										enumerable: true,
										get: getter,
									});
								}
							};
							__webpack_require__.r = function (exports) {
								if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
									Object.defineProperty(exports, Symbol.toStringTag, {
										value: "Module",
									});
								}
								Object.defineProperty(exports, "__esModule", { value: true });
							};
							__webpack_require__.t = function (value, mode) {
								if (mode & 1) value = __webpack_require__(value);
								if (mode & 8) return value;
								if (
									mode & 4 &&
									typeof value === "object" &&
									value &&
									value.__esModule
								)
									return value;
								var ns = Object.create(null);
								__webpack_require__.r(ns);
								Object.defineProperty(ns, "default", {
									enumerable: true,
									value: value,
								});
								if (mode & 2 && typeof value != "string")
									for (var key in value)
										__webpack_require__.d(
											ns,
											key,
											function (key) {
												return value[key];
											}.bind(null, key)
										);
								return ns;
							};
							__webpack_require__.n = function (module) {
								var getter =
									module && module.__esModule
										? function getDefault() {
												return module["default"];
										  }
										: function getModuleExports() {
												return module;
										  };
								__webpack_require__.d(getter, "a", getter);
								return getter;
							};
							__webpack_require__.o = function (object, property) {
								return Object.prototype.hasOwnProperty.call(object, property);
							};
							__webpack_require__.p = "/dist/";
							return __webpack_require__(
								(__webpack_require__.s = "./src/hls.ts")
							);
						})({
							"./node_modules/eventemitter3/index.js": function (
								module,
								exports,
								__webpack_require__
							) {
								"use strict";
								var has = Object.prototype.hasOwnProperty,
									prefix = "~";
								function Events() {}
								if (Object.create) {
									Events.prototype = Object.create(null);
									if (!new Events().__proto__) prefix = false;
								}
								function EE(fn, context, once) {
									this.fn = fn;
									this.context = context;
									this.once = once || false;
								}
								function addListener(emitter, event, fn, context, once) {
									if (typeof fn !== "function") {
										throw new TypeError("The listener must be a function");
									}
									var listener = new EE(fn, context || emitter, once),
										evt = prefix ? prefix + event : event;
									if (!emitter._events[evt])
										(emitter._events[evt] = listener), emitter._eventsCount++;
									else if (!emitter._events[evt].fn)
										emitter._events[evt].push(listener);
									else emitter._events[evt] = [emitter._events[evt], listener];
									return emitter;
								}
								function clearEvent(emitter, evt) {
									if (--emitter._eventsCount === 0)
										emitter._events = new Events();
									else delete emitter._events[evt];
								}
								function EventEmitter() {
									this._events = new Events();
									this._eventsCount = 0;
								}
								EventEmitter.prototype.eventNames = function eventNames() {
									var names = [],
										events,
										name;
									if (this._eventsCount === 0) return names;
									for (name in (events = this._events)) {
										if (has.call(events, name))
											names.push(prefix ? name.slice(1) : name);
									}
									if (Object.getOwnPropertySymbols) {
										return names.concat(Object.getOwnPropertySymbols(events));
									}
									return names;
								};
								EventEmitter.prototype.listeners = function listeners(event) {
									var evt = prefix ? prefix + event : event,
										handlers = this._events[evt];
									if (!handlers) return [];
									if (handlers.fn) return [handlers.fn];
									for (
										var i = 0, l = handlers.length, ee = new Array(l);
										i < l;
										i++
									) {
										ee[i] = handlers[i].fn;
									}
									return ee;
								};
								EventEmitter.prototype.listenerCount = function listenerCount(
									event
								) {
									var evt = prefix ? prefix + event : event,
										listeners = this._events[evt];
									if (!listeners) return 0;
									if (listeners.fn) return 1;
									return listeners.length;
								};
								EventEmitter.prototype.emit = function emit(
									event,
									a1,
									a2,
									a3,
									a4,
									a5
								) {
									var evt = prefix ? prefix + event : event;
									if (!this._events[evt]) return false;
									var listeners = this._events[evt],
										len = arguments.length,
										args,
										i;
									if (listeners.fn) {
										if (listeners.once)
											this.removeListener(event, listeners.fn, undefined, true);
										switch (len) {
											case 1:
												return listeners.fn.call(listeners.context), true;
											case 2:
												return listeners.fn.call(listeners.context, a1), true;
											case 3:
												return (
													listeners.fn.call(listeners.context, a1, a2), true
												);
											case 4:
												return (
													listeners.fn.call(listeners.context, a1, a2, a3), true
												);
											case 5:
												return (
													listeners.fn.call(listeners.context, a1, a2, a3, a4),
													true
												);
											case 6:
												return (
													listeners.fn.call(
														listeners.context,
														a1,
														a2,
														a3,
														a4,
														a5
													),
													true
												);
										}
										for (i = 1, args = new Array(len - 1); i < len; i++) {
											args[i - 1] = arguments[i];
										}
										listeners.fn.apply(listeners.context, args);
									} else {
										var length = listeners.length,
											j;
										for (i = 0; i < length; i++) {
											if (listeners[i].once)
												this.removeListener(
													event,
													listeners[i].fn,
													undefined,
													true
												);
											switch (len) {
												case 1:
													listeners[i].fn.call(listeners[i].context);
													break;
												case 2:
													listeners[i].fn.call(listeners[i].context, a1);
													break;
												case 3:
													listeners[i].fn.call(listeners[i].context, a1, a2);
													break;
												case 4:
													listeners[i].fn.call(
														listeners[i].context,
														a1,
														a2,
														a3
													);
													break;
												default:
													if (!args)
														for (
															j = 1, args = new Array(len - 1);
															j < len;
															j++
														) {
															args[j - 1] = arguments[j];
														}
													listeners[i].fn.apply(listeners[i].context, args);
											}
										}
									}
									return true;
								};
								EventEmitter.prototype.on = function on(event, fn, context) {
									return addListener(this, event, fn, context, false);
								};
								EventEmitter.prototype.once = function once(
									event,
									fn,
									context
								) {
									return addListener(this, event, fn, context, true);
								};
								EventEmitter.prototype.removeListener = function removeListener(
									event,
									fn,
									context,
									once
								) {
									var evt = prefix ? prefix + event : event;
									if (!this._events[evt]) return this;
									if (!fn) {
										clearEvent(this, evt);
										return this;
									}
									var listeners = this._events[evt];
									if (listeners.fn) {
										if (
											listeners.fn === fn &&
											(!once || listeners.once) &&
											(!context || listeners.context === context)
										) {
											clearEvent(this, evt);
										}
									} else {
										for (
											var i = 0, events = [], length = listeners.length;
											i < length;
											i++
										) {
											if (
												listeners[i].fn !== fn ||
												(once && !listeners[i].once) ||
												(context && listeners[i].context !== context)
											) {
												events.push(listeners[i]);
											}
										}
										if (events.length)
											this._events[evt] =
												events.length === 1 ? events[0] : events;
										else clearEvent(this, evt);
									}
									return this;
								};
								EventEmitter.prototype.removeAllListeners =
									function removeAllListeners(event) {
										var evt;
										if (event) {
											evt = prefix ? prefix + event : event;
											if (this._events[evt]) clearEvent(this, evt);
										} else {
											this._events = new Events();
											this._eventsCount = 0;
										}
										return this;
									};
								EventEmitter.prototype.off =
									EventEmitter.prototype.removeListener;
								EventEmitter.prototype.addListener = EventEmitter.prototype.on;
								EventEmitter.prefixed = prefix;
								EventEmitter.EventEmitter = EventEmitter;
								if (true) {
									module.exports = EventEmitter;
								}
							},
							"./node_modules/url-toolkit/src/url-toolkit.js": function (
								module,
								exports,
								__webpack_require__
							) {
								(function (root) {
									var URL_REGEX =
										/^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/?#]*\/)*[^;?#]*)?(;[^?#]*)?(\?[^#]*)?(#.*)?$/;
									var FIRST_SEGMENT_REGEX = /^([^\/?#]*)(.*)$/;
									var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
									var SLASH_DOT_DOT_REGEX =
										/(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
									var URLToolkit = {
										buildAbsoluteURL: function (baseURL, relativeURL, opts) {
											opts = opts || {};
											baseURL = baseURL.trim();
											relativeURL = relativeURL.trim();
											if (!relativeURL) {
												if (!opts.alwaysNormalize) {
													return baseURL;
												}
												var basePartsForNormalise =
													URLToolkit.parseURL(baseURL);
												if (!basePartsForNormalise) {
													throw new Error("Error trying to parse base URL.");
												}
												basePartsForNormalise.path = URLToolkit.normalizePath(
													basePartsForNormalise.path
												);
												return URLToolkit.buildURLFromParts(
													basePartsForNormalise
												);
											}
											var relativeParts = URLToolkit.parseURL(relativeURL);
											if (!relativeParts) {
												throw new Error("Error trying to parse relative URL.");
											}
											if (relativeParts.scheme) {
												if (!opts.alwaysNormalize) {
													return relativeURL;
												}
												relativeParts.path = URLToolkit.normalizePath(
													relativeParts.path
												);
												return URLToolkit.buildURLFromParts(relativeParts);
											}
											var baseParts = URLToolkit.parseURL(baseURL);
											if (!baseParts) {
												throw new Error("Error trying to parse base URL.");
											}
											if (
												!baseParts.netLoc &&
												baseParts.path &&
												baseParts.path[0] !== "/"
											) {
												var pathParts = FIRST_SEGMENT_REGEX.exec(
													baseParts.path
												);
												baseParts.netLoc = pathParts[1];
												baseParts.path = pathParts[2];
											}
											if (baseParts.netLoc && !baseParts.path) {
												baseParts.path = "/";
											}
											var builtParts = {
												scheme: baseParts.scheme,
												netLoc: relativeParts.netLoc,
												path: null,
												params: relativeParts.params,
												query: relativeParts.query,
												fragment: relativeParts.fragment,
											};
											if (!relativeParts.netLoc) {
												builtParts.netLoc = baseParts.netLoc;
												if (relativeParts.path[0] !== "/") {
													if (!relativeParts.path) {
														builtParts.path = baseParts.path;
														if (!relativeParts.params) {
															builtParts.params = baseParts.params;
															if (!relativeParts.query) {
																builtParts.query = baseParts.query;
															}
														}
													} else {
														var baseURLPath = baseParts.path;
														var newPath =
															baseURLPath.substring(
																0,
																baseURLPath.lastIndexOf("/") + 1
															) + relativeParts.path;
														builtParts.path = URLToolkit.normalizePath(newPath);
													}
												}
											}
											if (builtParts.path === null) {
												builtParts.path = opts.alwaysNormalize
													? URLToolkit.normalizePath(relativeParts.path)
													: relativeParts.path;
											}
											return URLToolkit.buildURLFromParts(builtParts);
										},
										parseURL: function (url) {
											var parts = URL_REGEX.exec(url);
											if (!parts) {
												return null;
											}
											return {
												scheme: parts[1] || "",
												netLoc: parts[2] || "",
												path: parts[3] || "",
												params: parts[4] || "",
												query: parts[5] || "",
												fragment: parts[6] || "",
											};
										},
										normalizePath: function (path) {
											path = path
												.split("")
												.reverse()
												.join("")
												.replace(SLASH_DOT_REGEX, "");
											while (
												path.length !==
												(path = path.replace(SLASH_DOT_DOT_REGEX, "")).length
											) {}
											return path.split("").reverse().join("");
										},
										buildURLFromParts: function (parts) {
											return (
												parts.scheme +
												parts.netLoc +
												parts.path +
												parts.params +
												parts.query +
												parts.fragment
											);
										},
									};
									if (true) module.exports = URLToolkit;
									else {
									}
								})(this);
							},
							"./node_modules/webworkify-webpack/index.js": function (
								module,
								exports,
								__webpack_require__
							) {
								function webpackBootstrapFunc(modules) {
									var installedModules = {};
									function __webpack_require__(moduleId) {
										if (installedModules[moduleId])
											return installedModules[moduleId].exports;
										var module = (installedModules[moduleId] = {
											i: moduleId,
											l: false,
											exports: {},
										});
										modules[moduleId].call(
											module.exports,
											module,
											module.exports,
											__webpack_require__
										);
										module.l = true;
										return module.exports;
									}
									__webpack_require__.m = modules;
									__webpack_require__.c = installedModules;
									__webpack_require__.i = function (value) {
										return value;
									};
									__webpack_require__.d = function (exports, name, getter) {
										if (!__webpack_require__.o(exports, name)) {
											Object.defineProperty(exports, name, {
												configurable: false,
												enumerable: true,
												get: getter,
											});
										}
									};
									__webpack_require__.r = function (exports) {
										Object.defineProperty(exports, "__esModule", {
											value: true,
										});
									};
									__webpack_require__.n = function (module) {
										var getter =
											module && module.__esModule
												? function getDefault() {
														return module["default"];
												  }
												: function getModuleExports() {
														return module;
												  };
										__webpack_require__.d(getter, "a", getter);
										return getter;
									};
									__webpack_require__.o = function (object, property) {
										return Object.prototype.hasOwnProperty.call(
											object,
											property
										);
									};
									__webpack_require__.p = "/";
									__webpack_require__.oe = function (err) {
										console.error(err);
										throw err;
									};
									var f = __webpack_require__(
										(__webpack_require__.s = ENTRY_MODULE)
									);
									return f.default || f;
								}
								var moduleNameReqExp = "[\\.|\\-|\\+|\\w|/|@]+";
								var dependencyRegExp =
									"\\(\\s*(/\\*.*?\\*/)?\\s*.*?(" +
									moduleNameReqExp +
									").*?\\)";
								function quoteRegExp(str) {
									return (str + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
								}
								function isNumeric(n) {
									return !isNaN(1 * n);
								}
								function getModuleDependencies(sources, module, queueName) {
									var retval = {};
									retval[queueName] = [];
									var fnString = module.toString();
									var wrapperSignature = fnString.match(
										/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/
									);
									if (!wrapperSignature) return retval;
									var webpackRequireName = wrapperSignature[1];
									var re = new RegExp(
										"(\\\\n|\\W)" +
											quoteRegExp(webpackRequireName) +
											dependencyRegExp,
										"g"
									);
									var match;
									while ((match = re.exec(fnString))) {
										if (match[3] === "dll-reference") continue;
										retval[queueName].push(match[3]);
									}
									re = new RegExp(
										"\\(" +
											quoteRegExp(webpackRequireName) +
											'\\("(dll-reference\\s(' +
											moduleNameReqExp +
											'))"\\)\\)' +
											dependencyRegExp,
										"g"
									);
									while ((match = re.exec(fnString))) {
										if (!sources[match[2]]) {
											retval[queueName].push(match[1]);
											sources[match[2]] = __webpack_require__(match[1]).m;
										}
										retval[match[2]] = retval[match[2]] || [];
										retval[match[2]].push(match[4]);
									}
									var keys = Object.keys(retval);
									for (var i = 0; i < keys.length; i++) {
										for (var j = 0; j < retval[keys[i]].length; j++) {
											if (isNumeric(retval[keys[i]][j])) {
												retval[keys[i]][j] = 1 * retval[keys[i]][j];
											}
										}
									}
									return retval;
								}
								function hasValuesInQueues(queues) {
									var keys = Object.keys(queues);
									return keys.reduce(function (hasValues, key) {
										return hasValues || queues[key].length > 0;
									}, false);
								}
								function getRequiredModules(sources, moduleId) {
									var modulesQueue = { main: [moduleId] };
									var requiredModules = { main: [] };
									var seenModules = { main: {} };
									while (hasValuesInQueues(modulesQueue)) {
										var queues = Object.keys(modulesQueue);
										for (var i = 0; i < queues.length; i++) {
											var queueName = queues[i];
											var queue = modulesQueue[queueName];
											var moduleToCheck = queue.pop();
											seenModules[queueName] = seenModules[queueName] || {};
											if (
												seenModules[queueName][moduleToCheck] ||
												!sources[queueName][moduleToCheck]
											)
												continue;
											seenModules[queueName][moduleToCheck] = true;
											requiredModules[queueName] =
												requiredModules[queueName] || [];
											requiredModules[queueName].push(moduleToCheck);
											var newModules = getModuleDependencies(
												sources,
												sources[queueName][moduleToCheck],
												queueName
											);
											var newModulesKeys = Object.keys(newModules);
											for (var j = 0; j < newModulesKeys.length; j++) {
												modulesQueue[newModulesKeys[j]] =
													modulesQueue[newModulesKeys[j]] || [];
												modulesQueue[newModulesKeys[j]] = modulesQueue[
													newModulesKeys[j]
												].concat(newModules[newModulesKeys[j]]);
											}
										}
									}
									return requiredModules;
								}
								module.exports = function (moduleId, options) {
									options = options || {};
									var sources = { main: __webpack_require__.m };
									var requiredModules = options.all
										? { main: Object.keys(sources.main) }
										: getRequiredModules(sources, moduleId);
									var src = "";
									Object.keys(requiredModules)
										.filter(function (m) {
											return m !== "main";
										})
										.forEach(function (module) {
											var entryModule = 0;
											while (requiredModules[module][entryModule]) {
												entryModule++;
											}
											requiredModules[module].push(entryModule);
											sources[module][entryModule] =
												"(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })";
											src =
												src +
												"var " +
												module +
												" = (" +
												webpackBootstrapFunc
													.toString()
													.replace(
														"ENTRY_MODULE",
														JSON.stringify(entryModule)
													) +
												")({" +
												requiredModules[module]
													.map(function (id) {
														return (
															"" +
															JSON.stringify(id) +
															": " +
															sources[module][id].toString()
														);
													})
													.join(",") +
												"});\n";
										});
									src =
										src +
										"new ((" +
										webpackBootstrapFunc
											.toString()
											.replace("ENTRY_MODULE", JSON.stringify(moduleId)) +
										")({" +
										requiredModules.main
											.map(function (id) {
												return (
													"" +
													JSON.stringify(id) +
													": " +
													sources.main[id].toString()
												);
											})
											.join(",") +
										"}))(self);";
									var blob = new window.Blob([src], {
										type: "text/javascript",
									});
									if (options.bare) {
										return blob;
									}
									var URL =
										window.URL ||
										window.webkitURL ||
										window.mozURL ||
										window.msURL;
									var workerUrl = URL.createObjectURL(blob);
									var worker = new window.Worker(workerUrl);
									worker.objectURL = workerUrl;
									return worker;
								};
							},
							"./src/crypt/decrypter.js": function (
								module,
								__webpack_exports__,
								__webpack_require__
							) {
								"use strict";
								__webpack_require__.r(__webpack_exports__);
								var AESCrypto = (function () {
									function AESCrypto(subtle, iv) {
										this.subtle = subtle;
										this.aesIV = iv;
									}
									var _proto = AESCrypto.prototype;
									_proto.decrypt = function decrypt(data, key) {
										return this.subtle.decrypt(
											{ name: "AES-CBC", iv: this.aesIV },
											key,
											data
										);
									};
									return AESCrypto;
								})();
								var FastAESKey = (function () {
									function FastAESKey(subtle, key) {
										this.subtle = subtle;
										this.key = key;
									}
									var _proto = FastAESKey.prototype;
									_proto.expandKey = function expandKey() {
										return this.subtle.importKey(
											"raw",
											this.key,
											{ name: "AES-CBC" },
											false,
											["encrypt", "decrypt"]
										);
									};
									return FastAESKey;
								})();
								var fast_aes_key = FastAESKey;
								function removePadding(buffer) {
									var outputBytes = buffer.byteLength;
									var paddingBytes =
										outputBytes &&
										new DataView(buffer).getUint8(outputBytes - 1);
									if (paddingBytes) {
										return buffer.slice(0, outputBytes - paddingBytes);
									} else {
										return buffer;
									}
								}
								var AESDecryptor = (function () {
									function AESDecryptor() {
										this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
										this.subMix = [
											new Uint32Array(256),
											new Uint32Array(256),
											new Uint32Array(256),
											new Uint32Array(256),
										];
										this.invSubMix = [
											new Uint32Array(256),
											new Uint32Array(256),
											new Uint32Array(256),
											new Uint32Array(256),
										];
										this.sBox = new Uint32Array(256);
										this.invSBox = new Uint32Array(256);
										this.key = new Uint32Array(0);
										this.initTable();
									}
									var _proto = AESDecryptor.prototype;
									_proto.uint8ArrayToUint32Array_ =
										function uint8ArrayToUint32Array_(arrayBuffer) {
											var view = new DataView(arrayBuffer);
											var newArray = new Uint32Array(4);
											for (var i = 0; i < 4; i++) {
												newArray[i] = view.getUint32(i * 4);
											}
											return newArray;
										};
									_proto.initTable = function initTable() {
										var sBox = this.sBox;
										var invSBox = this.invSBox;
										var subMix = this.subMix;
										var subMix0 = subMix[0];
										var subMix1 = subMix[1];
										var subMix2 = subMix[2];
										var subMix3 = subMix[3];
										var invSubMix = this.invSubMix;
										var invSubMix0 = invSubMix[0];
										var invSubMix1 = invSubMix[1];
										var invSubMix2 = invSubMix[2];
										var invSubMix3 = invSubMix[3];
										var d = new Uint32Array(256);
										var x = 0;
										var xi = 0;
										var i = 0;
										for (i = 0; i < 256; i++) {
											if (i < 128) {
												d[i] = i << 1;
											} else {
												d[i] = (i << 1) ^ 283;
											}
										}
										for (i = 0; i < 256; i++) {
											var sx =
												xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
											sx = (sx >>> 8) ^ (sx & 255) ^ 99;
											sBox[x] = sx;
											invSBox[sx] = x;
											var x2 = d[x];
											var x4 = d[x2];
											var x8 = d[x4];
											var t = (d[sx] * 257) ^ (sx * 16843008);
											subMix0[x] = (t << 24) | (t >>> 8);
											subMix1[x] = (t << 16) | (t >>> 16);
											subMix2[x] = (t << 8) | (t >>> 24);
											subMix3[x] = t;
											t =
												(x8 * 16843009) ^
												(x4 * 65537) ^
												(x2 * 257) ^
												(x * 16843008);
											invSubMix0[sx] = (t << 24) | (t >>> 8);
											invSubMix1[sx] = (t << 16) | (t >>> 16);
											invSubMix2[sx] = (t << 8) | (t >>> 24);
											invSubMix3[sx] = t;
											if (!x) {
												x = xi = 1;
											} else {
												x = x2 ^ d[d[d[x8 ^ x2]]];
												xi ^= d[d[xi]];
											}
										}
									};
									_proto.expandKey = function expandKey(keyBuffer) {
										var key = this.uint8ArrayToUint32Array_(keyBuffer);
										var sameKey = true;
										var offset = 0;
										while (offset < key.length && sameKey) {
											sameKey = key[offset] === this.key[offset];
											offset++;
										}
										if (sameKey) {
											return;
										}
										this.key = key;
										var keySize = (this.keySize = key.length);
										if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
											throw new Error("Invalid aes key size=" + keySize);
										}
										var ksRows = (this.ksRows = (keySize + 6 + 1) * 4);
										var ksRow;
										var invKsRow;
										var keySchedule = (this.keySchedule = new Uint32Array(
											ksRows
										));
										var invKeySchedule = (this.invKeySchedule = new Uint32Array(
											ksRows
										));
										var sbox = this.sBox;
										var rcon = this.rcon;
										var invSubMix = this.invSubMix;
										var invSubMix0 = invSubMix[0];
										var invSubMix1 = invSubMix[1];
										var invSubMix2 = invSubMix[2];
										var invSubMix3 = invSubMix[3];
										var prev;
										var t;
										for (ksRow = 0; ksRow < ksRows; ksRow++) {
											if (ksRow < keySize) {
												prev = keySchedule[ksRow] = key[ksRow];
												continue;
											}
											t = prev;
											if (ksRow % keySize === 0) {
												t = (t << 8) | (t >>> 24);
												t =
													(sbox[t >>> 24] << 24) |
													(sbox[(t >>> 16) & 255] << 16) |
													(sbox[(t >>> 8) & 255] << 8) |
													sbox[t & 255];
												t ^= rcon[(ksRow / keySize) | 0] << 24;
											} else if (keySize > 6 && ksRow % keySize === 4) {
												t =
													(sbox[t >>> 24] << 24) |
													(sbox[(t >>> 16) & 255] << 16) |
													(sbox[(t >>> 8) & 255] << 8) |
													sbox[t & 255];
											}
											keySchedule[ksRow] = prev =
												(keySchedule[ksRow - keySize] ^ t) >>> 0;
										}
										for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
											ksRow = ksRows - invKsRow;
											if (invKsRow & 3) {
												t = keySchedule[ksRow];
											} else {
												t = keySchedule[ksRow - 4];
											}
											if (invKsRow < 4 || ksRow <= 4) {
												invKeySchedule[invKsRow] = t;
											} else {
												invKeySchedule[invKsRow] =
													invSubMix0[sbox[t >>> 24]] ^
													invSubMix1[sbox[(t >>> 16) & 255]] ^
													invSubMix2[sbox[(t >>> 8) & 255]] ^
													invSubMix3[sbox[t & 255]];
											}
											invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
										}
									};
									_proto.networkToHostOrderSwap =
										function networkToHostOrderSwap(word) {
											return (
												(word << 24) |
												((word & 65280) << 8) |
												((word & 16711680) >> 8) |
												(word >>> 24)
											);
										};
									_proto.decrypt = function decrypt(
										inputArrayBuffer,
										offset,
										aesIV,
										removePKCS7Padding
									) {
										var nRounds = this.keySize + 6;
										var invKeySchedule = this.invKeySchedule;
										var invSBOX = this.invSBox;
										var invSubMix = this.invSubMix;
										var invSubMix0 = invSubMix[0];
										var invSubMix1 = invSubMix[1];
										var invSubMix2 = invSubMix[2];
										var invSubMix3 = invSubMix[3];
										var initVector = this.uint8ArrayToUint32Array_(aesIV);
										var initVector0 = initVector[0];
										var initVector1 = initVector[1];
										var initVector2 = initVector[2];
										var initVector3 = initVector[3];
										var inputInt32 = new Int32Array(inputArrayBuffer);
										var outputInt32 = new Int32Array(inputInt32.length);
										var t0, t1, t2, t3;
										var s0, s1, s2, s3;
										var inputWords0, inputWords1, inputWords2, inputWords3;
										var ksRow, i;
										var swapWord = this.networkToHostOrderSwap;
										while (offset < inputInt32.length) {
											inputWords0 = swapWord(inputInt32[offset]);
											inputWords1 = swapWord(inputInt32[offset + 1]);
											inputWords2 = swapWord(inputInt32[offset + 2]);
											inputWords3 = swapWord(inputInt32[offset + 3]);
											s0 = inputWords0 ^ invKeySchedule[0];
											s1 = inputWords3 ^ invKeySchedule[1];
											s2 = inputWords2 ^ invKeySchedule[2];
											s3 = inputWords1 ^ invKeySchedule[3];
											ksRow = 4;
											for (i = 1; i < nRounds; i++) {
												t0 =
													invSubMix0[s0 >>> 24] ^
													invSubMix1[(s1 >> 16) & 255] ^
													invSubMix2[(s2 >> 8) & 255] ^
													invSubMix3[s3 & 255] ^
													invKeySchedule[ksRow];
												t1 =
													invSubMix0[s1 >>> 24] ^
													invSubMix1[(s2 >> 16) & 255] ^
													invSubMix2[(s3 >> 8) & 255] ^
													invSubMix3[s0 & 255] ^
													invKeySchedule[ksRow + 1];
												t2 =
													invSubMix0[s2 >>> 24] ^
													invSubMix1[(s3 >> 16) & 255] ^
													invSubMix2[(s0 >> 8) & 255] ^
													invSubMix3[s1 & 255] ^
													invKeySchedule[ksRow + 2];
												t3 =
													invSubMix0[s3 >>> 24] ^
													invSubMix1[(s0 >> 16) & 255] ^
													invSubMix2[(s1 >> 8) & 255] ^
													invSubMix3[s2 & 255] ^
													invKeySchedule[ksRow + 3];
												s0 = t0;
												s1 = t1;
												s2 = t2;
												s3 = t3;
												ksRow = ksRow + 4;
											}
											t0 =
												(invSBOX[s0 >>> 24] << 24) ^
												(invSBOX[(s1 >> 16) & 255] << 16) ^
												(invSBOX[(s2 >> 8) & 255] << 8) ^
												invSBOX[s3 & 255] ^
												invKeySchedule[ksRow];
											t1 =
												(invSBOX[s1 >>> 24] << 24) ^
												(invSBOX[(s2 >> 16) & 255] << 16) ^
												(invSBOX[(s3 >> 8) & 255] << 8) ^
												invSBOX[s0 & 255] ^
												invKeySchedule[ksRow + 1];
											t2 =
												(invSBOX[s2 >>> 24] << 24) ^
												(invSBOX[(s3 >> 16) & 255] << 16) ^
												(invSBOX[(s0 >> 8) & 255] << 8) ^
												invSBOX[s1 & 255] ^
												invKeySchedule[ksRow + 2];
											t3 =
												(invSBOX[s3 >>> 24] << 24) ^
												(invSBOX[(s0 >> 16) & 255] << 16) ^
												(invSBOX[(s1 >> 8) & 255] << 8) ^
												invSBOX[s2 & 255] ^
												invKeySchedule[ksRow + 3];
											ksRow = ksRow + 3;
											outputInt32[offset] = swapWord(t0 ^ initVector0);
											outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
											outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
											outputInt32[offset + 3] = swapWord(t1 ^ initVector3);
											initVector0 = inputWords0;
											initVector1 = inputWords1;
											initVector2 = inputWords2;
											initVector3 = inputWords3;
											offset = offset + 4;
										}
										return removePKCS7Padding
											? removePadding(outputInt32.buffer)
											: outputInt32.buffer;
									};
									_proto.destroy = function destroy() {
										this.key = undefined;
										this.keySize = undefined;
										this.ksRows = undefined;
										this.sBox = undefined;
										this.invSBox = undefined;
										this.subMix = undefined;
										this.invSubMix = undefined;
										this.keySchedule = undefined;
										this.invKeySchedule = undefined;
										this.rcon = undefined;
									};
									return AESDecryptor;
								})();
								var aes_decryptor = AESDecryptor;
								var errors = __webpack_require__("./src/errors.ts");
								var logger = __webpack_require__("./src/utils/logger.js");
								var events = __webpack_require__("./src/events.js");
								var get_self_scope = __webpack_require__(
									"./src/utils/get-self-scope.js"
								);
								var global = Object(get_self_scope["getSelfScope"])();
								var decrypter_Decrypter = (function () {
									function Decrypter(observer, config, _temp) {
										var _ref = _temp === void 0 ? {} : _temp,
											_ref$removePKCS7Paddi = _ref.removePKCS7Padding,
											removePKCS7Padding =
												_ref$removePKCS7Paddi === void 0
													? true
													: _ref$removePKCS7Paddi;
										this.logEnabled = true;
										this.observer = observer;
										this.config = config;
										this.removePKCS7Padding = removePKCS7Padding;
										if (removePKCS7Padding) {
											try {
												var browserCrypto = global.crypto;
												if (browserCrypto) {
													this.subtle =
														browserCrypto.subtle || browserCrypto.webkitSubtle;
												}
											} catch (e) {}
										}
										this.disableWebCrypto = !this.subtle;
									}
									var _proto = Decrypter.prototype;
									_proto.isSync = function isSync() {
										return (
											this.disableWebCrypto && this.config.enableSoftwareAES
										);
									};
									_proto.decrypt = function decrypt(data, key, iv, callback) {
										var _this = this;
										if (
											this.disableWebCrypto &&
											this.config.enableSoftwareAES
										) {
											if (this.logEnabled) {
												logger["logger"].log("JS AES decrypt");
												this.logEnabled = false;
											}
											var decryptor = this.decryptor;
											if (!decryptor) {
												this.decryptor = decryptor = new aes_decryptor();
											}
											decryptor.expandKey(key);
											callback(
												decryptor.decrypt(data, 0, iv, this.removePKCS7Padding)
											);
										} else {
											if (this.logEnabled) {
												logger["logger"].log("WebCrypto AES decrypt");
												this.logEnabled = false;
											}
											var subtle = this.subtle;
											if (this.key !== key) {
												this.key = key;
												this.fastAesKey = new fast_aes_key(subtle, key);
											}
											this.fastAesKey
												.expandKey()
												.then(function (aesKey) {
													var crypto = new AESCrypto(subtle, iv);
													crypto
														.decrypt(data, aesKey)
														.catch(function (err) {
															_this.onWebCryptoError(
																err,
																data,
																key,
																iv,
																callback
															);
														})
														.then(function (result) {
															callback(result);
														});
												})
												.catch(function (err) {
													_this.onWebCryptoError(err, data, key, iv, callback);
												});
										}
									};
									_proto.onWebCryptoError = function onWebCryptoError(
										err,
										data,
										key,
										iv,
										callback
									) {
										if (this.config.enableSoftwareAES) {
											logger["logger"].log(
												"WebCrypto Error, disable WebCrypto API"
											);
											this.disableWebCrypto = true;
											this.logEnabled = true;
											this.decrypt(data, key, iv, callback);
										} else {
											logger["logger"].error(
												"decrypting error : " + err.message
											);
											this.observer.trigger(events["default"].ERROR, {
												type: errors["ErrorTypes"].MEDIA_ERROR,
												details: errors["ErrorDetails"].FRAG_DECRYPT_ERROR,
												fatal: true,
												reason: err.message,
											});
										}
									};
									_proto.destroy = function destroy() {
										var decryptor = this.decryptor;
										if (decryptor) {
											decryptor.destroy();
											this.decryptor = undefined;
										}
									};
									return Decrypter;
								})();
								var decrypter = (__webpack_exports__["default"] =
									decrypter_Decrypter);
							},
							"./src/demux/demuxer-inline.js": function (
								module,
								__webpack_exports__,
								__webpack_require__
							) {
								"use strict";
								__webpack_require__.r(__webpack_exports__);
								var events = __webpack_require__("./src/events.js");
								var errors = __webpack_require__("./src/errors.ts");
								var crypt_decrypter = __webpack_require__(
									"./src/crypt/decrypter.js"
								);
								var number = __webpack_require__("./src/polyfills/number.js");
								var logger = __webpack_require__("./src/utils/logger.js");
								var get_self_scope = __webpack_require__(
									"./src/utils/get-self-scope.js"
								);
								function getAudioConfig(observer, data, offset, audioCodec) {
									var adtsObjectType,
										adtsSampleingIndex,
										adtsExtensionSampleingIndex,
										adtsChanelConfig,
										config,
										userAgent = navigator.userAgent.toLowerCase(),
										manifestCodec = audioCodec,
										adtsSampleingRates = [
											96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3,
											12e3, 11025, 8e3, 7350,
										];
									adtsObjectType = ((data[offset + 2] & 192) >>> 6) + 1;
									adtsSampleingIndex = (data[offset + 2] & 60) >>> 2;
									if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
										observer.trigger(events["default"].ERROR, {
											type: errors["ErrorTypes"].MEDIA_ERROR,
											details: errors["ErrorDetails"].FRAG_PARSING_ERROR,
											fatal: true,
											reason:
												"invalid ADTS sampling index:" + adtsSampleingIndex,
										});
										return;
									}
									adtsChanelConfig = (data[offset + 2] & 1) << 2;
									adtsChanelConfig |= (data[offset + 3] & 192) >>> 6;
									logger["logger"].log(
										"manifest codec:" +
											audioCodec +
											",ADTS data:type:" +
											adtsObjectType +
											",sampleingIndex:" +
											adtsSampleingIndex +
											"[" +
											adtsSampleingRates[adtsSampleingIndex] +
											"Hz],channelConfig:" +
											adtsChanelConfig
									);
									if (/firefox/i.test(userAgent)) {
										if (adtsSampleingIndex >= 6) {
											adtsObjectType = 5;
											config = new Array(4);
											adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
										} else {
											adtsObjectType = 2;
											config = new Array(2);
											adtsExtensionSampleingIndex = adtsSampleingIndex;
										}
									} else if (userAgent.indexOf("android") !== -1) {
										adtsObjectType = 2;
										config = new Array(2);
										adtsExtensionSampleingIndex = adtsSampleingIndex;
									} else {
										adtsObjectType = 5;
										config = new Array(4);
										if (
											(audioCodec &&
												(audioCodec.indexOf("mp4a.40.29") !== -1 ||
													audioCodec.indexOf("mp4a.40.5") !== -1)) ||
											(!audioCodec && adtsSampleingIndex >= 6)
										) {
											adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
										} else {
											if (
												(audioCodec &&
													audioCodec.indexOf("mp4a.40.2") !== -1 &&
													((adtsSampleingIndex >= 6 &&
														adtsChanelConfig === 1) ||
														/vivaldi/i.test(userAgent))) ||
												(!audioCodec && adtsChanelConfig === 1)
											) {
												adtsObjectType = 2;
												config = new Array(2);
											}
											adtsExtensionSampleingIndex = adtsSampleingIndex;
										}
									}
									config[0] = adtsObjectType << 3;
									config[0] |= (adtsSampleingIndex & 14) >> 1;
									config[1] |= (adtsSampleingIndex & 1) << 7;
									config[1] |= adtsChanelConfig << 3;
									if (adtsObjectType === 5) {
										config[1] |= (adtsExtensionSampleingIndex & 14) >> 1;
										config[2] = (adtsExtensionSampleingIndex & 1) << 7;
										config[2] |= 2 << 2;
										config[3] = 0;
									}
									return {
										config: config,
										samplerate: adtsSampleingRates[adtsSampleingIndex],
										channelCount: adtsChanelConfig,
										codec: "mp4a.40." + adtsObjectType,
										manifestCodec: manifestCodec,
									};
								}
								function isHeaderPattern(data, offset) {
									return (
										data[offset] === 255 && (data[offset + 1] & 246) === 240
									);
								}
								function getHeaderLength(data, offset) {
									return data[offset + 1] & 1 ? 7 : 9;
								}
								function getFullFrameLength(data, offset) {
									return (
										((data[offset + 3] & 3) << 11) |
										(data[offset + 4] << 3) |
										((data[offset + 5] & 224) >>> 5)
									);
								}
								function isHeader(data, offset) {
									if (
										offset + 1 < data.length &&
										isHeaderPattern(data, offset)
									) {
										return true;
									}
									return false;
								}
								function adts_probe(data, offset) {
									if (isHeader(data, offset)) {
										var headerLength = getHeaderLength(data, offset);
										if (offset + headerLength >= data.length) {
											return false;
										}
										var frameLength = getFullFrameLength(data, offset);
										if (frameLength <= headerLength) {
											return false;
										}
										var newOffset = offset + frameLength;
										if (
											newOffset === data.length ||
											(newOffset + 1 < data.length &&
												isHeaderPattern(data, newOffset))
										) {
											return true;
										}
									}
									return false;
								}
								function initTrackConfig(
									track,
									observer,
									data,
									offset,
									audioCodec
								) {
									if (!track.samplerate) {
										var config = getAudioConfig(
											observer,
											data,
											offset,
											audioCodec
										);
										track.config = config.config;
										track.samplerate = config.samplerate;
										track.channelCount = config.channelCount;
										track.codec = config.codec;
										track.manifestCodec = config.manifestCodec;
										logger["logger"].log(
											"parsed codec:" +
												track.codec +
												",rate:" +
												config.samplerate +
												",nb channel:" +
												config.channelCount
										);
									}
								}
								function getFrameDuration(samplerate) {
									return (1024 * 9e4) / samplerate;
								}
								function parseFrameHeader(
									data,
									offset,
									pts,
									frameIndex,
									frameDuration
								) {
									var headerLength, frameLength, stamp;
									var length = data.length;
									headerLength = getHeaderLength(data, offset);
									frameLength = getFullFrameLength(data, offset);
									frameLength -= headerLength;
									if (
										frameLength > 0 &&
										offset + headerLength + frameLength <= length
									) {
										stamp = pts + frameIndex * frameDuration;
										return {
											headerLength: headerLength,
											frameLength: frameLength,
											stamp: stamp,
										};
									}
									return undefined;
								}
								function appendFrame(track, data, offset, pts, frameIndex) {
									var frameDuration = getFrameDuration(track.samplerate);
									var header = parseFrameHeader(
										data,
										offset,
										pts,
										frameIndex,
										frameDuration
									);
									if (header) {
										var stamp = header.stamp;
										var headerLength = header.headerLength;
										var frameLength = header.frameLength;
										var aacSample = {
											unit: data.subarray(
												offset + headerLength,
												offset + headerLength + frameLength
											),
											pts: stamp,
											dts: stamp,
										};
										track.samples.push(aacSample);
										return {
											sample: aacSample,
											length: frameLength + headerLength,
										};
									}
									return undefined;
								}
								var id3 = __webpack_require__("./src/demux/id3.js");
								var aacdemuxer_AACDemuxer = (function () {
									function AACDemuxer(observer, remuxer, config) {
										this.observer = observer;
										this.config = config;
										this.remuxer = remuxer;
									}
									var _proto = AACDemuxer.prototype;
									_proto.resetInitSegment = function resetInitSegment(
										initSegment,
										audioCodec,
										videoCodec,
										duration
									) {
										this._audioTrack = {
											container: "audio/adts",
											type: "audio",
											id: 0,
											sequenceNumber: 0,
											isAAC: true,
											samples: [],
											len: 0,
											manifestCodec: audioCodec,
											duration: duration,
											inputTimeScale: 9e4,
										};
									};
									_proto.resetTimeStamp = function resetTimeStamp() {};
									AACDemuxer.probe = function probe(data) {
										if (!data) {
											return false;
										}
										var id3Data = id3["default"].getID3Data(data, 0) || [];
										var offset = id3Data.length;
										for (var length = data.length; offset < length; offset++) {
											if (adts_probe(data, offset)) {
												logger["logger"].log("ADTS sync word found !");
												return true;
											}
										}
										return false;
									};
									_proto.append = function append(
										data,
										timeOffset,
										contiguous,
										accurateTimeOffset
									) {
										var track = this._audioTrack;
										var id3Data = id3["default"].getID3Data(data, 0) || [];
										var timestamp = id3["default"].getTimeStamp(id3Data);
										var pts = Object(number["isFiniteNumber"])(timestamp)
											? timestamp * 90
											: timeOffset * 9e4;
										var frameIndex = 0;
										var stamp = pts;
										var length = data.length;
										var offset = id3Data.length;
										var id3Samples = [
											{ pts: stamp, dts: stamp, data: id3Data },
										];
										while (offset < length - 1) {
											if (isHeader(data, offset) && offset + 5 < length) {
												initTrackConfig(
													track,
													this.observer,
													data,
													offset,
													track.manifestCodec
												);
												var frame = appendFrame(
													track,
													data,
													offset,
													pts,
													frameIndex
												);
												if (frame) {
													offset += frame.length;
													stamp = frame.sample.pts;
													frameIndex++;
												} else {
													logger["logger"].log("Unable to parse AAC frame");
													break;
												}
											} else if (id3["default"].isHeader(data, offset)) {
												id3Data = id3["default"].getID3Data(data, offset);
												id3Samples.push({
													pts: stamp,
													dts: stamp,
													data: id3Data,
												});
												offset += id3Data.length;
											} else {
												offset++;
											}
										}
										this.remuxer.remux(
											track,
											{ samples: [] },
											{ samples: id3Samples, inputTimeScale: 9e4 },
											{ samples: [] },
											timeOffset,
											contiguous,
											accurateTimeOffset
										);
									};
									_proto.destroy = function destroy() {};
									return AACDemuxer;
								})();
								var aacdemuxer = aacdemuxer_AACDemuxer;
								var mp4demuxer = __webpack_require__(
									"./src/demux/mp4demuxer.js"
								);
								var MpegAudio = {
									BitratesMap: [
										32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384,
										416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224,
										256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160,
										192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144,
										160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80,
										96, 112, 128, 144, 160,
									],
									SamplingRateMap: [
										44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3,
									],
									SamplesCoefficients: [
										[0, 72, 144, 12],
										[0, 0, 0, 0],
										[0, 72, 144, 12],
										[0, 144, 144, 12],
									],
									BytesInSlot: [0, 1, 1, 4],
									appendFrame: function appendFrame(
										track,
										data,
										offset,
										pts,
										frameIndex
									) {
										if (offset + 24 > data.length) {
											return undefined;
										}
										var header = this.parseHeader(data, offset);
										if (header && offset + header.frameLength <= data.length) {
											var frameDuration =
												(header.samplesPerFrame * 9e4) / header.sampleRate;
											var stamp = pts + frameIndex * frameDuration;
											var sample = {
												unit: data.subarray(
													offset,
													offset + header.frameLength
												),
												pts: stamp,
												dts: stamp,
											};
											track.config = [];
											track.channelCount = header.channelCount;
											track.samplerate = header.sampleRate;
											track.samples.push(sample);
											return { sample: sample, length: header.frameLength };
										}
										return undefined;
									},
									parseHeader: function parseHeader(data, offset) {
										var headerB = (data[offset + 1] >> 3) & 3;
										var headerC = (data[offset + 1] >> 1) & 3;
										var headerE = (data[offset + 2] >> 4) & 15;
										var headerF = (data[offset + 2] >> 2) & 3;
										var headerG = (data[offset + 2] >> 1) & 1;
										if (
											headerB !== 1 &&
											headerE !== 0 &&
											headerE !== 15 &&
											headerF !== 3
										) {
											var columnInBitrates =
												headerB === 3 ? 3 - headerC : headerC === 3 ? 3 : 4;
											var bitRate =
												MpegAudio.BitratesMap[
													columnInBitrates * 14 + headerE - 1
												] * 1e3;
											var columnInSampleRates =
												headerB === 3 ? 0 : headerB === 2 ? 1 : 2;
											var sampleRate =
												MpegAudio.SamplingRateMap[
													columnInSampleRates * 3 + headerF
												];
											var channelCount = data[offset + 3] >> 6 === 3 ? 1 : 2;
											var sampleCoefficient =
												MpegAudio.SamplesCoefficients[headerB][headerC];
											var bytesInSlot = MpegAudio.BytesInSlot[headerC];
											var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
											var frameLength =
												parseInt(
													(sampleCoefficient * bitRate) / sampleRate + headerG,
													10
												) * bytesInSlot;
											return {
												sampleRate: sampleRate,
												channelCount: channelCount,
												frameLength: frameLength,
												samplesPerFrame: samplesPerFrame,
											};
										}
										return undefined;
									},
									isHeaderPattern: function isHeaderPattern(data, offset) {
										return (
											data[offset] === 255 &&
											(data[offset + 1] & 224) === 224 &&
											(data[offset + 1] & 6) !== 0
										);
									},
									isHeader: function isHeader(data, offset) {
										if (
											offset + 1 < data.length &&
											this.isHeaderPattern(data, offset)
										) {
											return true;
										}
										return false;
									},
									probe: function probe(data, offset) {
										if (
											offset + 1 < data.length &&
											this.isHeaderPattern(data, offset)
										) {
											var headerLength = 4;
											var header = this.parseHeader(data, offset);
											var frameLength = headerLength;
											if (header && header.frameLength) {
												frameLength = header.frameLength;
											}
											var newOffset = offset + frameLength;
											if (
												newOffset === data.length ||
												(newOffset + 1 < data.length &&
													this.isHeaderPattern(data, newOffset))
											) {
												return true;
											}
										}
										return false;
									},
								};
								var mpegaudio = MpegAudio;
								var exp_golomb_ExpGolomb = (function () {
									function ExpGolomb(data) {
										this.data = data;
										this.bytesAvailable = data.byteLength;
										this.word = 0;
										this.bitsAvailable = 0;
									}
									var _proto = ExpGolomb.prototype;
									_proto.loadWord = function loadWord() {
										var data = this.data,
											bytesAvailable = this.bytesAvailable,
											position = data.byteLength - bytesAvailable,
											workingBytes = new Uint8Array(4),
											availableBytes = Math.min(4, bytesAvailable);
										if (availableBytes === 0) {
											throw new Error("no bytes available");
										}
										workingBytes.set(
											data.subarray(position, position + availableBytes)
										);
										this.word = new DataView(workingBytes.buffer).getUint32(0);
										this.bitsAvailable = availableBytes * 8;
										this.bytesAvailable -= availableBytes;
									};
									_proto.skipBits = function skipBits(count) {
										var skipBytes;
										if (this.bitsAvailable > count) {
											this.word <<= count;
											this.bitsAvailable -= count;
										} else {
											count -= this.bitsAvailable;
											skipBytes = count >> 3;
											count -= skipBytes >> 3;
											this.bytesAvailable -= skipBytes;
											this.loadWord();
											this.word <<= count;
											this.bitsAvailable -= count;
										}
									};
									_proto.readBits = function readBits(size) {
										var bits = Math.min(this.bitsAvailable, size),
											valu = this.word >>> (32 - bits);
										if (size > 32) {
											logger["logger"].error(
												"Cannot read more than 32 bits at a time"
											);
										}
										this.bitsAvailable -= bits;
										if (this.bitsAvailable > 0) {
											this.word <<= bits;
										} else if (this.bytesAvailable > 0) {
											this.loadWord();
										}
										bits = size - bits;
										if (bits > 0 && this.bitsAvailable) {
											return (valu << bits) | this.readBits(bits);
										} else {
											return valu;
										}
									};
									_proto.skipLZ = function skipLZ() {
										var leadingZeroCount;
										for (
											leadingZeroCount = 0;
											leadingZeroCount < this.bitsAvailable;
											++leadingZeroCount
										) {
											if (
												(this.word & (2147483648 >>> leadingZeroCount)) !==
												0
											) {
												this.word <<= leadingZeroCount;
												this.bitsAvailable -= leadingZeroCount;
												return leadingZeroCount;
											}
										}
										this.loadWord();
										return leadingZeroCount + this.skipLZ();
									};
									_proto.skipUEG = function skipUEG() {
										this.skipBits(1 + this.skipLZ());
									};
									_proto.skipEG = function skipEG() {
										this.skipBits(1 + this.skipLZ());
									};
									_proto.readUEG = function readUEG() {
										var clz = this.skipLZ();
										return this.readBits(clz + 1) - 1;
									};
									_proto.readEG = function readEG() {
										var valu = this.readUEG();
										if (1 & valu) {
											return (1 + valu) >>> 1;
										} else {
											return -1 * (valu >>> 1);
										}
									};
									_proto.readBoolean = function readBoolean() {
										return this.readBits(1) === 1;
									};
									_proto.readUByte = function readUByte() {
										return this.readBits(8);
									};
									_proto.readUShort = function readUShort() {
										return this.readBits(16);
									};
									_proto.readUInt = function readUInt() {
										return this.readBits(32);
									};
									_proto.skipScalingList = function skipScalingList(count) {
										var lastScale = 8,
											nextScale = 8,
											j,
											deltaScale;
										for (j = 0; j < count; j++) {
											if (nextScale !== 0) {
												deltaScale = this.readEG();
												nextScale = (lastScale + deltaScale + 256) % 256;
											}
											lastScale = nextScale === 0 ? lastScale : nextScale;
										}
									};
									_proto.readSPS = function readSPS() {
										var frameCropLeftOffset = 0,
											frameCropRightOffset = 0,
											frameCropTopOffset = 0,
											frameCropBottomOffset = 0,
											profileIdc,
											profileCompat,
											levelIdc,
											numRefFramesInPicOrderCntCycle,
											picWidthInMbsMinus1,
											picHeightInMapUnitsMinus1,
											frameMbsOnlyFlag,
											scalingListCount,
											i,
											readUByte = this.readUByte.bind(this),
											readBits = this.readBits.bind(this),
											readUEG = this.readUEG.bind(this),
											readBoolean = this.readBoolean.bind(this),
											skipBits = this.skipBits.bind(this),
											skipEG = this.skipEG.bind(this),
											skipUEG = this.skipUEG.bind(this),
											skipScalingList = this.skipScalingList.bind(this);
										readUByte();
										profileIdc = readUByte();
										profileCompat = readBits(5);
										skipBits(3);
										levelIdc = readUByte();
										skipUEG();
										if (
											profileIdc === 100 ||
											profileIdc === 110 ||
											profileIdc === 122 ||
											profileIdc === 244 ||
											profileIdc === 44 ||
											profileIdc === 83 ||
											profileIdc === 86 ||
											profileIdc === 118 ||
											profileIdc === 128
										) {
											var chromaFormatIdc = readUEG();
											if (chromaFormatIdc === 3) {
												skipBits(1);
											}
											skipUEG();
											skipUEG();
											skipBits(1);
											if (readBoolean()) {
												scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
												for (i = 0; i < scalingListCount; i++) {
													if (readBoolean()) {
														if (i < 6) {
															skipScalingList(16);
														} else {
															skipScalingList(64);
														}
													}
												}
											}
										}
										skipUEG();
										var picOrderCntType = readUEG();
										if (picOrderCntType === 0) {
											readUEG();
										} else if (picOrderCntType === 1) {
											skipBits(1);
											skipEG();
											skipEG();
											numRefFramesInPicOrderCntCycle = readUEG();
											for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
												skipEG();
											}
										}
										skipUEG();
										skipBits(1);
										picWidthInMbsMinus1 = readUEG();
										picHeightInMapUnitsMinus1 = readUEG();
										frameMbsOnlyFlag = readBits(1);
										if (frameMbsOnlyFlag === 0) {
											skipBits(1);
										}
										skipBits(1);
										if (readBoolean()) {
											frameCropLeftOffset = readUEG();
											frameCropRightOffset = readUEG();
											frameCropTopOffset = readUEG();
											frameCropBottomOffset = readUEG();
										}
										var pixelRatio = [1, 1];
										if (readBoolean()) {
											if (readBoolean()) {
												var aspectRatioIdc = readUByte();
												switch (aspectRatioIdc) {
													case 1:
														pixelRatio = [1, 1];
														break;
													case 2:
														pixelRatio = [12, 11];
														break;
													case 3:
														pixelRatio = [10, 11];
														break;
													case 4:
														pixelRatio = [16, 11];
														break;
													case 5:
														pixelRatio = [40, 33];
														break;
													case 6:
														pixelRatio = [24, 11];
														break;
													case 7:
														pixelRatio = [20, 11];
														break;
													case 8:
														pixelRatio = [32, 11];
														break;
													case 9:
														pixelRatio = [80, 33];
														break;
													case 10:
														pixelRatio = [18, 11];
														break;
													case 11:
														pixelRatio = [15, 11];
														break;
													case 12:
														pixelRatio = [64, 33];
														break;
													case 13:
														pixelRatio = [160, 99];
														break;
													case 14:
														pixelRatio = [4, 3];
														break;
													case 15:
														pixelRatio = [3, 2];
														break;
													case 16:
														pixelRatio = [2, 1];
														break;
													case 255: {
														pixelRatio = [
															(readUByte() << 8) | readUByte(),
															(readUByte() << 8) | readUByte(),
														];
														break;
													}
												}
											}
										}
										return {
											width: Math.ceil(
												(picWidthInMbsMinus1 + 1) * 16 -
													frameCropLeftOffset * 2 -
													frameCropRightOffset * 2
											),
											height:
												(2 - frameMbsOnlyFlag) *
													(picHeightInMapUnitsMinus1 + 1) *
													16 -
												(frameMbsOnlyFlag ? 2 : 4) *
													(frameCropTopOffset + frameCropBottomOffset),
											pixelRatio: pixelRatio,
										};
									};
									_proto.readSliceType = function readSliceType() {
										this.readUByte();
										this.readUEG();
										return this.readUEG();
									};
									return ExpGolomb;
								})();
								var exp_golomb = exp_golomb_ExpGolomb;
								var sample_aes_SampleAesDecrypter = (function () {
									function SampleAesDecrypter(
										observer,
										config,
										decryptdata,
										discardEPB
									) {
										this.decryptdata = decryptdata;
										this.discardEPB = discardEPB;
										this.decrypter = new crypt_decrypter["default"](
											observer,
											config,
											{ removePKCS7Padding: false }
										);
									}
									var _proto = SampleAesDecrypter.prototype;
									_proto.decryptBuffer = function decryptBuffer(
										encryptedData,
										callback
									) {
										this.decrypter.decrypt(
											encryptedData,
											this.decryptdata.key.buffer,
											this.decryptdata.iv.buffer,
											callback
										);
									};
									_proto.decryptAacSample = function decryptAacSample(
										samples,
										sampleIndex,
										callback,
										sync
									) {
										var curUnit = samples[sampleIndex].unit;
										var encryptedData = curUnit.subarray(
											16,
											curUnit.length - (curUnit.length % 16)
										);
										var encryptedBuffer = encryptedData.buffer.slice(
											encryptedData.byteOffset,
											encryptedData.byteOffset + encryptedData.length
										);
										var localthis = this;
										this.decryptBuffer(
											encryptedBuffer,
											function (decryptedData) {
												decryptedData = new Uint8Array(decryptedData);
												curUnit.set(decryptedData, 16);
												if (!sync) {
													localthis.decryptAacSamples(
														samples,
														sampleIndex + 1,
														callback
													);
												}
											}
										);
									};
									_proto.decryptAacSamples = function decryptAacSamples(
										samples,
										sampleIndex,
										callback
									) {
										for (; ; sampleIndex++) {
											if (sampleIndex >= samples.length) {
												callback();
												return;
											}
											if (samples[sampleIndex].unit.length < 32) {
												continue;
											}
											var sync = this.decrypter.isSync();
											this.decryptAacSample(
												samples,
												sampleIndex,
												callback,
												sync
											);
											if (!sync) {
												return;
											}
										}
									};
									_proto.getAvcEncryptedData = function getAvcEncryptedData(
										decodedData
									) {
										var encryptedDataLen =
											Math.floor((decodedData.length - 48) / 160) * 16 + 16;
										var encryptedData = new Int8Array(encryptedDataLen);
										var outputPos = 0;
										for (
											var inputPos = 32;
											inputPos <= decodedData.length - 16;
											inputPos += 160, outputPos += 16
										) {
											encryptedData.set(
												decodedData.subarray(inputPos, inputPos + 16),
												outputPos
											);
										}
										return encryptedData;
									};
									_proto.getAvcDecryptedUnit = function getAvcDecryptedUnit(
										decodedData,
										decryptedData
									) {
										decryptedData = new Uint8Array(decryptedData);
										var inputPos = 0;
										for (
											var outputPos = 32;
											outputPos <= decodedData.length - 16;
											outputPos += 160, inputPos += 16
										) {
											decodedData.set(
												decryptedData.subarray(inputPos, inputPos + 16),
												outputPos
											);
										}
										return decodedData;
									};
									_proto.decryptAvcSample = function decryptAvcSample(
										samples,
										sampleIndex,
										unitIndex,
										callback,
										curUnit,
										sync
									) {
										var decodedData = this.discardEPB(curUnit.data);
										var encryptedData = this.getAvcEncryptedData(decodedData);
										var localthis = this;
										this.decryptBuffer(
											encryptedData.buffer,
											function (decryptedData) {
												curUnit.data = localthis.getAvcDecryptedUnit(
													decodedData,
													decryptedData
												);
												if (!sync) {
													localthis.decryptAvcSamples(
														samples,
														sampleIndex,
														unitIndex + 1,
														callback
													);
												}
											}
										);
									};
									_proto.decryptAvcSamples = function decryptAvcSamples(
										samples,
										sampleIndex,
										unitIndex,
										callback
									) {
										for (; ; sampleIndex++, unitIndex = 0) {
											if (sampleIndex >= samples.length) {
												callback();
												return;
											}
											var curUnits = samples[sampleIndex].units;
											for (; ; unitIndex++) {
												if (unitIndex >= curUnits.length) {
													break;
												}
												var curUnit = curUnits[unitIndex];
												if (
													curUnit.data.length <= 48 ||
													(curUnit.type !== 1 && curUnit.type !== 5)
												) {
													continue;
												}
												var sync = this.decrypter.isSync();
												this.decryptAvcSample(
													samples,
													sampleIndex,
													unitIndex,
													callback,
													curUnit,
													sync
												);
												if (!sync) {
													return;
												}
											}
										}
									};
									return SampleAesDecrypter;
								})();
								var sample_aes = sample_aes_SampleAesDecrypter;
								var RemuxerTrackIdConfig = {
									video: 1,
									audio: 2,
									id3: 3,
									text: 4,
								};
								var tsdemuxer_TSDemuxer = (function () {
									function TSDemuxer(observer, remuxer, config, typeSupported) {
										this.observer = observer;
										this.config = config;
										this.typeSupported = typeSupported;
										this.remuxer = remuxer;
										this.sampleAes = null;
										this.pmtUnknownTypes = {};
									}
									var _proto = TSDemuxer.prototype;
									_proto.setDecryptData = function setDecryptData(decryptdata) {
										if (
											decryptdata != null &&
											decryptdata.key != null &&
											decryptdata.method === "SAMPLE-AES"
										) {
											this.sampleAes = new sample_aes(
												this.observer,
												this.config,
												decryptdata,
												this.discardEPB
											);
										} else {
											this.sampleAes = null;
										}
									};
									TSDemuxer.probe = function probe(data) {
										var syncOffset = TSDemuxer._syncOffset(data);
										if (syncOffset < 0) {
											return false;
										} else {
											if (syncOffset) {
												logger["logger"].warn(
													"MPEG2-TS detected but first sync word found @ offset " +
														syncOffset +
														", junk ahead ?"
												);
											}
											return true;
										}
									};
									TSDemuxer._syncOffset = function _syncOffset(data) {
										var scanwindow = Math.min(1e3, data.length - 3 * 188);
										var i = 0;
										while (i < scanwindow) {
											if (
												data[i] === 71 &&
												data[i + 188] === 71 &&
												data[i + 2 * 188] === 71
											) {
												return i;
											} else {
												i++;
											}
										}
										return -1;
									};
									TSDemuxer.createTrack = function createTrack(type, duration) {
										return {
											container:
												type === "video" || type === "audio"
													? "video/mp2t"
													: undefined,
											type: type,
											id: RemuxerTrackIdConfig[type],
											pid: -1,
											inputTimeScale: 9e4,
											sequenceNumber: 0,
											samples: [],
											dropped: type === "video" ? 0 : undefined,
											isAAC: type === "audio" ? true : undefined,
											duration: type === "audio" ? duration : undefined,
										};
									};
									_proto.resetInitSegment = function resetInitSegment(
										initSegment,
										audioCodec,
										videoCodec,
										duration
									) {
										this.pmtParsed = false;
										this._pmtId = -1;
										this.pmtUnknownTypes = {};
										this._avcTrack = TSDemuxer.createTrack("video", duration);
										this._audioTrack = TSDemuxer.createTrack("audio", duration);
										this._id3Track = TSDemuxer.createTrack("id3", duration);
										this._txtTrack = TSDemuxer.createTrack("text", duration);
										this.aacOverFlow = null;
										this.aacLastPTS = null;
										this.avcSample = null;
										this.audioCodec = audioCodec;
										this.videoCodec = videoCodec;
										this._duration = duration;
									};
									_proto.resetTimeStamp = function resetTimeStamp() {};
									_proto.append = function append(
										data,
										timeOffset,
										contiguous,
										accurateTimeOffset
									) {
										var start,
											len = data.length,
											stt,
											pid,
											atf,
											offset,
											pes,
											unknownPIDs = false;
										this.pmtUnknownTypes = {};
										this.contiguous = contiguous;
										var pmtParsed = this.pmtParsed,
											avcTrack = this._avcTrack,
											audioTrack = this._audioTrack,
											id3Track = this._id3Track,
											avcId = avcTrack.pid,
											audioId = audioTrack.pid,
											id3Id = id3Track.pid,
											pmtId = this._pmtId,
											avcData = avcTrack.pesData,
											audioData = audioTrack.pesData,
											id3Data = id3Track.pesData,
											parsePAT = this._parsePAT,
											parsePMT = this._parsePMT.bind(this),
											parsePES = this._parsePES,
											parseAVCPES = this._parseAVCPES.bind(this),
											parseAACPES = this._parseAACPES.bind(this),
											parseMPEGPES = this._parseMPEGPES.bind(this),
											parseID3PES = this._parseID3PES.bind(this);
										var syncOffset = TSDemuxer._syncOffset(data);
										len -= (len + syncOffset) % 188;
										for (start = syncOffset; start < len; start += 188) {
											if (data[start] === 71) {
												stt = !!(data[start + 1] & 64);
												pid = ((data[start + 1] & 31) << 8) + data[start + 2];
												atf = (data[start + 3] & 48) >> 4;
												if (atf > 1) {
													offset = start + 5 + data[start + 4];
													if (offset === start + 188) {
														continue;
													}
												} else {
													offset = start + 4;
												}
												switch (pid) {
													case avcId:
														if (stt) {
															if (avcData && (pes = parsePES(avcData))) {
																parseAVCPES(pes, false);
															}
															avcData = { data: [], size: 0 };
														}
														if (avcData) {
															avcData.data.push(
																data.subarray(offset, start + 188)
															);
															avcData.size += start + 188 - offset;
														}
														break;
													case audioId:
														if (stt) {
															if (audioData && (pes = parsePES(audioData))) {
																if (audioTrack.isAAC) {
																	parseAACPES(pes);
																} else {
																	parseMPEGPES(pes);
																}
															}
															audioData = { data: [], size: 0 };
														}
														if (audioData) {
															audioData.data.push(
																data.subarray(offset, start + 188)
															);
															audioData.size += start + 188 - offset;
														}
														break;
													case id3Id:
														if (stt) {
															if (id3Data && (pes = parsePES(id3Data))) {
																parseID3PES(pes);
															}
															id3Data = { data: [], size: 0 };
														}
														if (id3Data) {
															id3Data.data.push(
																data.subarray(offset, start + 188)
															);
															id3Data.size += start + 188 - offset;
														}
														break;
													case 0:
														if (stt) {
															offset += data[offset] + 1;
														}
														pmtId = this._pmtId = parsePAT(data, offset);
														break;
													case pmtId:
														if (stt) {
															offset += data[offset] + 1;
														}
														var parsedPIDs = parsePMT(
															data,
															offset,
															this.typeSupported.mpeg === true ||
																this.typeSupported.mp3 === true,
															this.sampleAes != null
														);
														avcId = parsedPIDs.avc;
														if (avcId > 0) {
															avcTrack.pid = avcId;
														}
														audioId = parsedPIDs.audio;
														if (audioId > 0) {
															audioTrack.pid = audioId;
															audioTrack.isAAC = parsedPIDs.isAAC;
														}
														id3Id = parsedPIDs.id3;
														if (id3Id > 0) {
															id3Track.pid = id3Id;
														}
														if (unknownPIDs && !pmtParsed) {
															logger["logger"].log("reparse from beginning");
															unknownPIDs = false;
															start = syncOffset - 188;
														}
														pmtParsed = this.pmtParsed = true;
														break;
													case 17:
													case 8191:
														break;
													default:
														unknownPIDs = true;
														break;
												}
											} else {
												this.observer.trigger(events["default"].ERROR, {
													type: errors["ErrorTypes"].MEDIA_ERROR,
													details: errors["ErrorDetails"].FRAG_PARSING_ERROR,
													fatal: false,
													reason: "TS packet did not start with 0x47",
												});
											}
										}
										if (avcData && (pes = parsePES(avcData))) {
											parseAVCPES(pes, true);
											avcTrack.pesData = null;
										} else {
											avcTrack.pesData = avcData;
										}
										if (audioData && (pes = parsePES(audioData))) {
											if (audioTrack.isAAC) {
												parseAACPES(pes);
											} else {
												parseMPEGPES(pes);
											}
											audioTrack.pesData = null;
										} else {
											if (audioData && audioData.size) {
												logger["logger"].log(
													"last AAC PES packet truncated,might overlap between fragments"
												);
											}
											audioTrack.pesData = audioData;
										}
										if (id3Data && (pes = parsePES(id3Data))) {
											parseID3PES(pes);
											id3Track.pesData = null;
										} else {
											id3Track.pesData = id3Data;
										}
										if (this.sampleAes == null) {
											this.remuxer.remux(
												audioTrack,
												avcTrack,
												id3Track,
												this._txtTrack,
												timeOffset,
												contiguous,
												accurateTimeOffset
											);
										} else {
											this.decryptAndRemux(
												audioTrack,
												avcTrack,
												id3Track,
												this._txtTrack,
												timeOffset,
												contiguous,
												accurateTimeOffset
											);
										}
									};
									_proto.decryptAndRemux = function decryptAndRemux(
										audioTrack,
										videoTrack,
										id3Track,
										textTrack,
										timeOffset,
										contiguous,
										accurateTimeOffset
									) {
										if (audioTrack.samples && audioTrack.isAAC) {
											var localthis = this;
											this.sampleAes.decryptAacSamples(
												audioTrack.samples,
												0,
												function () {
													localthis.decryptAndRemuxAvc(
														audioTrack,
														videoTrack,
														id3Track,
														textTrack,
														timeOffset,
														contiguous,
														accurateTimeOffset
													);
												}
											);
										} else {
											this.decryptAndRemuxAvc(
												audioTrack,
												videoTrack,
												id3Track,
												textTrack,
												timeOffset,
												contiguous,
												accurateTimeOffset
											);
										}
									};
									_proto.decryptAndRemuxAvc = function decryptAndRemuxAvc(
										audioTrack,
										videoTrack,
										id3Track,
										textTrack,
										timeOffset,
										contiguous,
										accurateTimeOffset
									) {
										if (videoTrack.samples) {
											var localthis = this;
											this.sampleAes.decryptAvcSamples(
												videoTrack.samples,
												0,
												0,
												function () {
													localthis.remuxer.remux(
														audioTrack,
														videoTrack,
														id3Track,
														textTrack,
														timeOffset,
														contiguous,
														accurateTimeOffset
													);
												}
											);
										} else {
											this.remuxer.remux(
												audioTrack,
												videoTrack,
												id3Track,
												textTrack,
												timeOffset,
												contiguous,
												accurateTimeOffset
											);
										}
									};
									_proto.destroy = function destroy() {
										this._initPTS = this._initDTS = undefined;
										this._duration = 0;
									};
									_proto._parsePAT = function _parsePAT(data, offset) {
										return ((data[offset + 10] & 31) << 8) | data[offset + 11];
									};
									_proto._trackUnknownPmt = function _trackUnknownPmt(
										type,
										logLevel,
										message
									) {
										var result = this.pmtUnknownTypes[type] || 0;
										if (result === 0) {
											this.pmtUnknownTypes[type] = 0;
											logLevel.call(logger["logger"], message);
										}
										this.pmtUnknownTypes[type]++;
										return result;
									};
									_proto._parsePMT = function _parsePMT(
										data,
										offset,
										mpegSupported,
										isSampleAes
									) {
										var sectionLength,
											tableEnd,
											programInfoLength,
											pid,
											result = { audio: -1, avc: -1, id3: -1, isAAC: true };
										sectionLength =
											((data[offset + 1] & 15) << 8) | data[offset + 2];
										tableEnd = offset + 3 + sectionLength - 4;
										programInfoLength =
											((data[offset + 10] & 15) << 8) | data[offset + 11];
										offset += 12 + programInfoLength;
										while (offset < tableEnd) {
											pid = ((data[offset + 1] & 31) << 8) | data[offset + 2];
											switch (data[offset]) {
												case 207:
													if (!isSampleAes) {
														this._trackUnknownPmt(
															data[offset],
															logger["logger"].warn,
															"ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream"
														);
														break;
													}
												case 15:
													if (result.audio === -1) {
														result.audio = pid;
													}
													break;
												case 21:
													if (result.id3 === -1) {
														result.id3 = pid;
													}
													break;
												case 219:
													if (!isSampleAes) {
														this._trackUnknownPmt(
															data[offset],
															logger["logger"].warn,
															"H.264 with AES-128-CBC slice encryption found in unencrypted stream"
														);
														break;
													}
												case 27:
													if (result.avc === -1) {
														result.avc = pid;
													}
													break;
												case 3:
												case 4:
													if (!mpegSupported) {
														this._trackUnknownPmt(
															data[offset],
															logger["logger"].warn,
															"MPEG audio found, not supported in this browser"
														);
													} else if (result.audio === -1) {
														result.audio = pid;
														result.isAAC = false;
													}
													break;
												case 36:
													this._trackUnknownPmt(
														data[offset],
														logger["logger"].warn,
														"Unsupported HEVC stream type found"
													);
													break;
												default:
													this._trackUnknownPmt(
														data[offset],
														logger["logger"].log,
														"Unknown stream type:" + data[offset]
													);
													break;
											}
											offset +=
												(((data[offset + 3] & 15) << 8) | data[offset + 4]) + 5;
										}
										return result;
									};
									_proto._parsePES = function _parsePES(stream) {
										var i = 0,
											frag,
											pesFlags,
											pesPrefix,
											pesLen,
											pesHdrLen,
											pesData,
											pesPts,
											pesDts,
											payloadStartOffset,
											data = stream.data;
										if (!stream || stream.size === 0) {
											return null;
										}
										while (data[0].length < 19 && data.length > 1) {
											var newData = new Uint8Array(
												data[0].length + data[1].length
											);
											newData.set(data[0]);
											newData.set(data[1], data[0].length);
											data[0] = newData;
											data.splice(1, 1);
										}
										frag = data[0];
										pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
										if (pesPrefix === 1) {
											pesLen = (frag[4] << 8) + frag[5];
											if (pesLen && pesLen > stream.size - 6) {
												return null;
											}
											pesFlags = frag[7];
											if (pesFlags & 192) {
												pesPts =
													(frag[9] & 14) * 536870912 +
													(frag[10] & 255) * 4194304 +
													(frag[11] & 254) * 16384 +
													(frag[12] & 255) * 128 +
													(frag[13] & 254) / 2;
												if (pesFlags & 64) {
													pesDts =
														(frag[14] & 14) * 536870912 +
														(frag[15] & 255) * 4194304 +
														(frag[16] & 254) * 16384 +
														(frag[17] & 255) * 128 +
														(frag[18] & 254) / 2;
													if (pesPts - pesDts > 60 * 9e4) {
														logger["logger"].warn(
															Math.round((pesPts - pesDts) / 9e4) +
																"s delta between PTS and DTS, align them"
														);
														pesPts = pesDts;
													}
												} else {
													pesDts = pesPts;
												}
											}
											pesHdrLen = frag[8];
											payloadStartOffset = pesHdrLen + 9;
											if (stream.size <= payloadStartOffset) {
												return null;
											}
											stream.size -= payloadStartOffset;
											pesData = new Uint8Array(stream.size);
											for (var j = 0, dataLen = data.length; j < dataLen; j++) {
												frag = data[j];
												var len = frag.byteLength;
												if (payloadStartOffset) {
													if (payloadStartOffset > len) {
														payloadStartOffset -= len;
														continue;
													} else {
														frag = frag.subarray(payloadStartOffset);
														len -= payloadStartOffset;
														payloadStartOffset = 0;
													}
												}
												pesData.set(frag, i);
												i += len;
											}
											if (pesLen) {
												pesLen -= pesHdrLen + 3;
											}
											return {
												data: pesData,
												pts: pesPts,
												dts: pesDts,
												len: pesLen,
											};
										} else {
											return null;
										}
									};
									_proto.pushAccesUnit = function pushAccesUnit(
										avcSample,
										avcTrack
									) {
										if (avcSample.units.length && avcSample.frame) {
											var samples = avcTrack.samples;
											var nbSamples = samples.length;
											if (isNaN(avcSample.pts)) {
												if (nbSamples) {
													var lastSample = samples[nbSamples - 1];
													avcSample.pts = lastSample.pts;
													avcSample.dts = lastSample.dts;
												} else {
													avcTrack.dropped++;
													return;
												}
											}
											if (
												!this.config.forceKeyFrameOnDiscontinuity ||
												avcSample.key === true ||
												(avcTrack.sps && (nbSamples || this.contiguous))
											) {
												avcSample.id = nbSamples;
												samples.push(avcSample);
											} else {
												avcTrack.dropped++;
											}
										}
										if (avcSample.debug.length) {
											logger["logger"].log(
												avcSample.pts +
													"/" +
													avcSample.dts +
													":" +
													avcSample.debug
											);
										}
									};
									_proto._parseAVCPES = function _parseAVCPES(pes, last) {
										var _this = this;
										var track = this._avcTrack,
											units = this._parseAVCNALu(pes.data),
											debug = false,
											expGolombDecoder,
											avcSample = this.avcSample,
											push,
											spsfound = false,
											i,
											pushAccesUnit = this.pushAccesUnit.bind(this),
											createAVCSample = function createAVCSample(
												key,
												pts,
												dts,
												debug
											) {
												return {
													key: key,
													pts: pts,
													dts: dts,
													units: [],
													debug: debug,
												};
											};
										pes.data = null;
										if (avcSample && units.length && !track.audFound) {
											pushAccesUnit(avcSample, track);
											avcSample = this.avcSample = createAVCSample(
												false,
												pes.pts,
												pes.dts,
												""
											);
										}
										units.forEach(function (unit) {
											switch (unit.type) {
												case 1:
													push = true;
													if (!avcSample) {
														avcSample = _this.avcSample = createAVCSample(
															true,
															pes.pts,
															pes.dts,
															""
														);
													}
													if (debug) {
														avcSample.debug += "NDR ";
													}
													avcSample.frame = true;
													var data = unit.data;
													if (spsfound && data.length > 4) {
														var sliceType = new exp_golomb(
															data
														).readSliceType();
														if (
															sliceType === 2 ||
															sliceType === 4 ||
															sliceType === 7 ||
															sliceType === 9
														) {
															avcSample.key = true;
														}
													}
													break;
												case 5:
													push = true;
													if (!avcSample) {
														avcSample = _this.avcSample = createAVCSample(
															true,
															pes.pts,
															pes.dts,
															""
														);
													}
													if (debug) {
														avcSample.debug += "IDR ";
													}
													avcSample.key = true;
													avcSample.frame = true;
													break;
												case 6:
													push = true;
													if (debug && avcSample) {
														avcSample.debug += "SEI ";
													}
													expGolombDecoder = new exp_golomb(
														_this.discardEPB(unit.data)
													);
													expGolombDecoder.readUByte();
													var payloadType = 0;
													var payloadSize = 0;
													var endOfCaptions = false;
													var b = 0;
													while (
														!endOfCaptions &&
														expGolombDecoder.bytesAvailable > 1
													) {
														payloadType = 0;
														do {
															b = expGolombDecoder.readUByte();
															payloadType += b;
														} while (b === 255);
														payloadSize = 0;
														do {
															b = expGolombDecoder.readUByte();
															payloadSize += b;
														} while (b === 255);
														if (
															payloadType === 4 &&
															expGolombDecoder.bytesAvailable !== 0
														) {
															endOfCaptions = true;
															var countryCode = expGolombDecoder.readUByte();
															if (countryCode === 181) {
																var providerCode =
																	expGolombDecoder.readUShort();
																if (providerCode === 49) {
																	var userStructure =
																		expGolombDecoder.readUInt();
																	if (userStructure === 1195456820) {
																		var userDataType =
																			expGolombDecoder.readUByte();
																		if (userDataType === 3) {
																			var firstByte =
																				expGolombDecoder.readUByte();
																			var secondByte =
																				expGolombDecoder.readUByte();
																			var totalCCs = 31 & firstByte;
																			var byteArray = [firstByte, secondByte];
																			for (i = 0; i < totalCCs; i++) {
																				byteArray.push(
																					expGolombDecoder.readUByte()
																				);
																				byteArray.push(
																					expGolombDecoder.readUByte()
																				);
																				byteArray.push(
																					expGolombDecoder.readUByte()
																				);
																			}
																			_this._insertSampleInOrder(
																				_this._txtTrack.samples,
																				{
																					type: 3,
																					pts: pes.pts,
																					bytes: byteArray,
																				}
																			);
																		}
																	}
																}
															}
														} else if (
															payloadType === 5 &&
															expGolombDecoder.bytesAvailable !== 0
														) {
															endOfCaptions = true;
															if (payloadSize > 16) {
																var uuidStrArray = [];
																for (i = 0; i < 16; i++) {
																	uuidStrArray.push(
																		expGolombDecoder.readUByte().toString(16)
																	);
																	if (
																		i === 3 ||
																		i === 5 ||
																		i === 7 ||
																		i === 9
																	) {
																		uuidStrArray.push("-");
																	}
																}
																var length = payloadSize - 16;
																var userDataPayloadBytes = new Uint8Array(
																	length
																);
																for (i = 0; i < length; i++) {
																	userDataPayloadBytes[i] =
																		expGolombDecoder.readUByte();
																}
																_this._insertSampleInOrder(
																	_this._txtTrack.samples,
																	{
																		pts: pes.pts,
																		payloadType: payloadType,
																		uuid: uuidStrArray.join(""),
																		userDataBytes: userDataPayloadBytes,
																		userData: Object(id3["utf8ArrayToStr"])(
																			userDataPayloadBytes.buffer
																		),
																	}
																);
															}
														} else if (
															payloadSize < expGolombDecoder.bytesAvailable
														) {
															for (i = 0; i < payloadSize; i++) {
																expGolombDecoder.readUByte();
															}
														}
													}
													break;
												case 7:
													push = true;
													spsfound = true;
													if (debug && avcSample) {
														avcSample.debug += "SPS ";
													}
													if (!track.sps) {
														expGolombDecoder = new exp_golomb(unit.data);
														var config = expGolombDecoder.readSPS();
														track.width = config.width;
														track.height = config.height;
														track.pixelRatio = config.pixelRatio;
														track.sps = [unit.data];
														track.duration = _this._duration;
														var codecarray = unit.data.subarray(1, 4);
														var codecstring = "avc1.";
														for (i = 0; i < 3; i++) {
															var h = codecarray[i].toString(16);
															if (h.length < 2) {
																h = "0" + h;
															}
															codecstring += h;
														}
														track.codec = codecstring;
													}
													break;
												case 8:
													push = true;
													if (debug && avcSample) {
														avcSample.debug += "PPS ";
													}
													if (!track.pps) {
														track.pps = [unit.data];
													}
													break;
												case 9:
													push = false;
													track.audFound = true;
													if (avcSample) {
														pushAccesUnit(avcSample, track);
													}
													avcSample = _this.avcSample = createAVCSample(
														false,
														pes.pts,
														pes.dts,
														debug ? "AUD " : ""
													);
													break;
												case 12:
													push = false;
													break;
												default:
													push = false;
													if (avcSample) {
														avcSample.debug += "unknown NAL " + unit.type + " ";
													}
													break;
											}
											if (avcSample && push) {
												var _units = avcSample.units;
												_units.push(unit);
											}
										});
										if (last && avcSample) {
											pushAccesUnit(avcSample, track);
											this.avcSample = null;
										}
									};
									_proto._insertSampleInOrder = function _insertSampleInOrder(
										arr,
										data
									) {
										var len = arr.length;
										if (len > 0) {
											if (data.pts >= arr[len - 1].pts) {
												arr.push(data);
											} else {
												for (var pos = len - 1; pos >= 0; pos--) {
													if (data.pts < arr[pos].pts) {
														arr.splice(pos, 0, data);
														break;
													}
												}
											}
										} else {
											arr.push(data);
										}
									};
									_proto._getLastNalUnit = function _getLastNalUnit() {
										var avcSample = this.avcSample,
											lastUnit;
										if (!avcSample || avcSample.units.length === 0) {
											var track = this._avcTrack,
												samples = track.samples;
											avcSample = samples[samples.length - 1];
										}
										if (avcSample) {
											var units = avcSample.units;
											lastUnit = units[units.length - 1];
										}
										return lastUnit;
									};
									_proto._parseAVCNALu = function _parseAVCNALu(array) {
										var i = 0,
											len = array.byteLength,
											value,
											overflow,
											track = this._avcTrack,
											state = track.naluState || 0,
											lastState = state;
										var units = [],
											unit,
											unitType,
											lastUnitStart = -1,
											lastUnitType;
										if (state === -1) {
											lastUnitStart = 0;
											lastUnitType = array[0] & 31;
											state = 0;
											i = 1;
										}
										while (i < len) {
											value = array[i++];
											if (!state) {
												state = value ? 0 : 1;
												continue;
											}
											if (state === 1) {
												state = value ? 0 : 2;
												continue;
											}
											if (!value) {
												state = 3;
											} else if (value === 1) {
												if (lastUnitStart >= 0) {
													unit = {
														data: array.subarray(lastUnitStart, i - state - 1),
														type: lastUnitType,
													};
													units.push(unit);
												} else {
													var lastUnit = this._getLastNalUnit();
													if (lastUnit) {
														if (lastState && i <= 4 - lastState) {
															if (lastUnit.state) {
																lastUnit.data = lastUnit.data.subarray(
																	0,
																	lastUnit.data.byteLength - lastState
																);
															}
														}
														overflow = i - state - 1;
														if (overflow > 0) {
															var tmp = new Uint8Array(
																lastUnit.data.byteLength + overflow
															);
															tmp.set(lastUnit.data, 0);
															tmp.set(
																array.subarray(0, overflow),
																lastUnit.data.byteLength
															);
															lastUnit.data = tmp;
														}
													}
												}
												if (i < len) {
													unitType = array[i] & 31;
													lastUnitStart = i;
													lastUnitType = unitType;
													state = 0;
												} else {
													state = -1;
												}
											} else {
												state = 0;
											}
										}
										if (lastUnitStart >= 0 && state >= 0) {
											unit = {
												data: array.subarray(lastUnitStart, len),
												type: lastUnitType,
												state: state,
											};
											units.push(unit);
										}
										if (units.length === 0) {
											var _lastUnit = this._getLastNalUnit();
											if (_lastUnit) {
												var _tmp = new Uint8Array(
													_lastUnit.data.byteLength + array.byteLength
												);
												_tmp.set(_lastUnit.data, 0);
												_tmp.set(array, _lastUnit.data.byteLength);
												_lastUnit.data = _tmp;
											}
										}
										track.naluState = state;
										return units;
									};
									_proto.discardEPB = function discardEPB(data) {
										var length = data.byteLength,
											EPBPositions = [],
											i = 1,
											newLength,
											newData;
										while (i < length - 2) {
											if (
												data[i] === 0 &&
												data[i + 1] === 0 &&
												data[i + 2] === 3
											) {
												EPBPositions.push(i + 2);
												i += 2;
											} else {
												i++;
											}
										}
										if (EPBPositions.length === 0) {
											return data;
										}
										newLength = length - EPBPositions.length;
										newData = new Uint8Array(newLength);
										var sourceIndex = 0;
										for (i = 0; i < newLength; sourceIndex++, i++) {
											if (sourceIndex === EPBPositions[0]) {
												sourceIndex++;
												EPBPositions.shift();
											}
											newData[i] = data[sourceIndex];
										}
										return newData;
									};
									_proto._parseAACPES = function _parseAACPES(pes) {
										var track = this._audioTrack,
											data = pes.data,
											pts = pes.pts,
											startOffset = 0,
											aacOverFlow = this.aacOverFlow,
											aacLastPTS = this.aacLastPTS,
											frameDuration,
											frameIndex,
											offset,
											stamp,
											len;
										if (aacOverFlow) {
											var tmp = new Uint8Array(
												aacOverFlow.byteLength + data.byteLength
											);
											tmp.set(aacOverFlow, 0);
											tmp.set(data, aacOverFlow.byteLength);
											data = tmp;
										}
										for (
											offset = startOffset, len = data.length;
											offset < len - 1;
											offset++
										) {
											if (isHeader(data, offset)) {
												break;
											}
										}
										if (offset) {
											var reason, fatal;
											if (offset < len - 1) {
												reason =
													"AAC PES did not start with ADTS header,offset:" +
													offset;
												fatal = false;
											} else {
												reason = "no ADTS header found in AAC PES";
												fatal = true;
											}
											logger["logger"].warn("parsing error:" + reason);
											this.observer.trigger(events["default"].ERROR, {
												type: errors["ErrorTypes"].MEDIA_ERROR,
												details: errors["ErrorDetails"].FRAG_PARSING_ERROR,
												fatal: fatal,
												reason: reason,
											});
											if (fatal) {
												return;
											}
										}
										initTrackConfig(
											track,
											this.observer,
											data,
											offset,
											this.audioCodec
										);
										frameIndex = 0;
										frameDuration = getFrameDuration(track.samplerate);
										if (aacOverFlow && aacLastPTS) {
											var newPTS = aacLastPTS + frameDuration;
											if (Math.abs(newPTS - pts) > 1) {
												logger["logger"].log(
													"AAC: align PTS for overlapping frames by " +
														Math.round((newPTS - pts) / 90)
												);
												pts = newPTS;
											}
										}
										while (offset < len) {
											if (isHeader(data, offset)) {
												if (offset + 5 < len) {
													var frame = appendFrame(
														track,
														data,
														offset,
														pts,
														frameIndex
													);
													if (frame) {
														offset += frame.length;
														stamp = frame.sample.pts;
														frameIndex++;
														continue;
													}
												}
												break;
											} else {
												offset++;
											}
										}
										if (offset < len) {
											aacOverFlow = data.subarray(offset, len);
										} else {
											aacOverFlow = null;
										}
										this.aacOverFlow = aacOverFlow;
										this.aacLastPTS = stamp;
									};
									_proto._parseMPEGPES = function _parseMPEGPES(pes) {
										var data = pes.data;
										var length = data.length;
										var frameIndex = 0;
										var offset = 0;
										var pts = pes.pts;
										while (offset < length) {
											if (mpegaudio.isHeader(data, offset)) {
												var frame = mpegaudio.appendFrame(
													this._audioTrack,
													data,
													offset,
													pts,
													frameIndex
												);
												if (frame) {
													offset += frame.length;
													frameIndex++;
												} else {
													break;
												}
											} else {
												offset++;
											}
										}
									};
									_proto._parseID3PES = function _parseID3PES(pes) {
										this._id3Track.samples.push(pes);
									};
									return TSDemuxer;
								})();
								var tsdemuxer = tsdemuxer_TSDemuxer;
								var mp3demuxer_MP3Demuxer = (function () {
									function MP3Demuxer(observer, remuxer, config) {
										this.observer = observer;
										this.config = config;
										this.remuxer = remuxer;
									}
									var _proto = MP3Demuxer.prototype;
									_proto.resetInitSegment = function resetInitSegment(
										initSegment,
										audioCodec,
										videoCodec,
										duration
									) {
										this._audioTrack = {
											container: "audio/mpeg",
											type: "audio",
											id: -1,
											sequenceNumber: 0,
											isAAC: false,
											samples: [],
											len: 0,
											manifestCodec: audioCodec,
											duration: duration,
											inputTimeScale: 9e4,
										};
									};
									_proto.resetTimeStamp = function resetTimeStamp() {};
									MP3Demuxer.probe = function probe(data) {
										var offset, length;
										var id3Data = id3["default"].getID3Data(data, 0);
										if (
											id3Data &&
											id3["default"].getTimeStamp(id3Data) !== undefined
										) {
											for (
												offset = id3Data.length,
													length = Math.min(data.length - 1, offset + 100);
												offset < length;
												offset++
											) {
												if (mpegaudio.probe(data, offset)) {
													logger["logger"].log("MPEG Audio sync word found !");
													return true;
												}
											}
										}
										return false;
									};
									_proto.append = function append(
										data,
										timeOffset,
										contiguous,
										accurateTimeOffset
									) {
										var id3Data = id3["default"].getID3Data(data, 0) || [];
										var timestamp = id3["default"].getTimeStamp(id3Data);
										var pts =
											timestamp !== undefined
												? 90 * timestamp
												: timeOffset * 9e4;
										var offset = id3Data.length;
										var length = data.length;
										var frameIndex = 0,
											stamp = 0;
										var track = this._audioTrack;
										var id3Samples = [{ pts: pts, dts: pts, data: id3Data }];
										while (offset < length) {
											if (mpegaudio.isHeader(data, offset)) {
												var frame = mpegaudio.appendFrame(
													track,
													data,
													offset,
													pts,
													frameIndex
												);
												if (frame) {
													offset += frame.length;
													stamp = frame.sample.pts;
													frameIndex++;
												} else {
													break;
												}
											} else if (id3["default"].isHeader(data, offset)) {
												id3Data = id3["default"].getID3Data(data, offset);
												id3Samples.push({
													pts: stamp,
													dts: stamp,
													data: id3Data,
												});
												offset += id3Data.length;
											} else {
												offset++;
											}
										}
										this.remuxer.remux(
											track,
											{ samples: [] },
											{ samples: id3Samples, inputTimeScale: 9e4 },
											{ samples: [] },
											timeOffset,
											contiguous,
											accurateTimeOffset
										);
									};
									_proto.destroy = function destroy() {};
									return MP3Demuxer;
								})();
								var mp3demuxer = mp3demuxer_MP3Demuxer;
								var AAC = (function () {
									function AAC() {}
									AAC.getSilentFrame = function getSilentFrame(
										codec,
										channelCount
									) {
										switch (codec) {
											case "mp4a.40.2":
												if (channelCount === 1) {
													return new Uint8Array([0, 200, 0, 128, 35, 128]);
												} else if (channelCount === 2) {
													return new Uint8Array([
														33, 0, 73, 144, 2, 25, 0, 35, 128,
													]);
												} else if (channelCount === 3) {
													return new Uint8Array([
														0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142,
													]);
												} else if (channelCount === 4) {
													return new Uint8Array([
														0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128,
														44, 128, 8, 2, 56,
													]);
												} else if (channelCount === 5) {
													return new Uint8Array([
														0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130,
														48, 4, 153, 0, 33, 144, 2, 56,
													]);
												} else if (channelCount === 6) {
													return new Uint8Array([
														0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130,
														48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224,
													]);
												}
												break;
											default:
												if (channelCount === 1) {
													return new Uint8Array([
														1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0,
														28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90,
														90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
														90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
														90, 90, 90, 90, 90, 90, 94,
													]);
												} else if (channelCount === 2) {
													return new Uint8Array([
														1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0,
														0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90,
														90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
														90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
														90, 90, 90, 90, 90, 90, 94,
													]);
												} else if (channelCount === 3) {
													return new Uint8Array([
														1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0,
														0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90,
														90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
														90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
														90, 90, 90, 90, 90, 90, 94,
													]);
												}
												break;
										}
										return null;
									};
									return AAC;
								})();
								var aac_helper = AAC;
								var UINT32_MAX = Math.pow(2, 32) - 1;
								var MP4 = (function () {
									function MP4() {}
									MP4.init = function init() {
										MP4.types = {
											avc1: [],
											avcC: [],
											btrt: [],
											dinf: [],
											dref: [],
											esds: [],
											ftyp: [],
											hdlr: [],
											mdat: [],
											mdhd: [],
											mdia: [],
											mfhd: [],
											minf: [],
											moof: [],
											moov: [],
											mp4a: [],
											".mp3": [],
											mvex: [],
											mvhd: [],
											pasp: [],
											sdtp: [],
											stbl: [],
											stco: [],
											stsc: [],
											stsd: [],
											stsz: [],
											stts: [],
											tfdt: [],
											tfhd: [],
											traf: [],
											trak: [],
											trun: [],
											trex: [],
											tkhd: [],
											vmhd: [],
											smhd: [],
										};
										var i;
										for (i in MP4.types) {
											if (MP4.types.hasOwnProperty(i)) {
												MP4.types[i] = [
													i.charCodeAt(0),
													i.charCodeAt(1),
													i.charCodeAt(2),
													i.charCodeAt(3),
												];
											}
										}
										var videoHdlr = new Uint8Array([
											0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0,
											0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110,
											100, 108, 101, 114, 0,
										]);
										var audioHdlr = new Uint8Array([
											0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0,
											0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110,
											100, 108, 101, 114, 0,
										]);
										MP4.HDLR_TYPES = { video: videoHdlr, audio: audioHdlr };
										var dref = new Uint8Array([
											0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0,
											0, 0, 1,
										]);
										var stco = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
										MP4.STTS = MP4.STSC = MP4.STCO = stco;
										MP4.STSZ = new Uint8Array([
											0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
										]);
										MP4.VMHD = new Uint8Array([
											0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
										]);
										MP4.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
										MP4.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
										var majorBrand = new Uint8Array([105, 115, 111, 109]);
										var avc1Brand = new Uint8Array([97, 118, 99, 49]);
										var minorVersion = new Uint8Array([0, 0, 0, 1]);
										MP4.FTYP = MP4.box(
											MP4.types.ftyp,
											majorBrand,
											minorVersion,
											majorBrand,
											avc1Brand
										);
										MP4.DINF = MP4.box(
											MP4.types.dinf,
											MP4.box(MP4.types.dref, dref)
										);
									};
									MP4.box = function box(type) {
										var payload = Array.prototype.slice.call(arguments, 1),
											size = 8,
											i = payload.length,
											len = i,
											result;
										while (i--) {
											size += payload[i].byteLength;
										}
										result = new Uint8Array(size);
										result[0] = (size >> 24) & 255;
										result[1] = (size >> 16) & 255;
										result[2] = (size >> 8) & 255;
										result[3] = size & 255;
										result.set(type, 4);
										for (i = 0, size = 8; i < len; i++) {
											result.set(payload[i], size);
											size += payload[i].byteLength;
										}
										return result;
									};
									MP4.hdlr = function hdlr(type) {
										return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
									};
									MP4.mdat = function mdat(data) {
										return MP4.box(MP4.types.mdat, data);
									};
									MP4.mdhd = function mdhd(timescale, duration) {
										duration *= timescale;
										var upperWordDuration = Math.floor(
											duration / (UINT32_MAX + 1)
										);
										var lowerWordDuration = Math.floor(
											duration % (UINT32_MAX + 1)
										);
										return MP4.box(
											MP4.types.mdhd,
											new Uint8Array([
												1,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												2,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												3,
												(timescale >> 24) & 255,
												(timescale >> 16) & 255,
												(timescale >> 8) & 255,
												timescale & 255,
												upperWordDuration >> 24,
												(upperWordDuration >> 16) & 255,
												(upperWordDuration >> 8) & 255,
												upperWordDuration & 255,
												lowerWordDuration >> 24,
												(lowerWordDuration >> 16) & 255,
												(lowerWordDuration >> 8) & 255,
												lowerWordDuration & 255,
												85,
												196,
												0,
												0,
											])
										);
									};
									MP4.mdia = function mdia(track) {
										return MP4.box(
											MP4.types.mdia,
											MP4.mdhd(track.timescale, track.duration),
											MP4.hdlr(track.type),
											MP4.minf(track)
										);
									};
									MP4.mfhd = function mfhd(sequenceNumber) {
										return MP4.box(
											MP4.types.mfhd,
											new Uint8Array([
												0,
												0,
												0,
												0,
												sequenceNumber >> 24,
												(sequenceNumber >> 16) & 255,
												(sequenceNumber >> 8) & 255,
												sequenceNumber & 255,
											])
										);
									};
									MP4.minf = function minf(track) {
										if (track.type === "audio") {
											return MP4.box(
												MP4.types.minf,
												MP4.box(MP4.types.smhd, MP4.SMHD),
												MP4.DINF,
												MP4.stbl(track)
											);
										} else {
											return MP4.box(
												MP4.types.minf,
												MP4.box(MP4.types.vmhd, MP4.VMHD),
												MP4.DINF,
												MP4.stbl(track)
											);
										}
									};
									MP4.moof = function moof(sn, baseMediaDecodeTime, track) {
										return MP4.box(
											MP4.types.moof,
											MP4.mfhd(sn),
											MP4.traf(track, baseMediaDecodeTime)
										);
									};
									MP4.moov = function moov(tracks) {
										var i = tracks.length,
											boxes = [];
										while (i--) {
											boxes[i] = MP4.trak(tracks[i]);
										}
										return MP4.box.apply(
											null,
											[
												MP4.types.moov,
												MP4.mvhd(tracks[0].timescale, tracks[0].duration),
											]
												.concat(boxes)
												.concat(MP4.mvex(tracks))
										);
									};
									MP4.mvex = function mvex(tracks) {
										var i = tracks.length,
											boxes = [];
										while (i--) {
											boxes[i] = MP4.trex(tracks[i]);
										}
										return MP4.box.apply(null, [MP4.types.mvex].concat(boxes));
									};
									MP4.mvhd = function mvhd(timescale, duration) {
										duration *= timescale;
										var upperWordDuration = Math.floor(
											duration / (UINT32_MAX + 1)
										);
										var lowerWordDuration = Math.floor(
											duration % (UINT32_MAX + 1)
										);
										var bytes = new Uint8Array([
											1,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											2,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											3,
											(timescale >> 24) & 255,
											(timescale >> 16) & 255,
											(timescale >> 8) & 255,
											timescale & 255,
											upperWordDuration >> 24,
											(upperWordDuration >> 16) & 255,
											(upperWordDuration >> 8) & 255,
											upperWordDuration & 255,
											lowerWordDuration >> 24,
											(lowerWordDuration >> 16) & 255,
											(lowerWordDuration >> 8) & 255,
											lowerWordDuration & 255,
											0,
											1,
											0,
											0,
											1,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											1,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											1,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											64,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											0,
											255,
											255,
											255,
											255,
										]);
										return MP4.box(MP4.types.mvhd, bytes);
									};
									MP4.sdtp = function sdtp(track) {
										var samples = track.samples || [],
											bytes = new Uint8Array(4 + samples.length),
											flags,
											i;
										for (i = 0; i < samples.length; i++) {
											flags = samples[i].flags;
											bytes[i + 4] =
												(flags.dependsOn << 4) |
												(flags.isDependedOn << 2) |
												flags.hasRedundancy;
										}
										return MP4.box(MP4.types.sdtp, bytes);
									};
									MP4.stbl = function stbl(track) {
										return MP4.box(
											MP4.types.stbl,
											MP4.stsd(track),
											MP4.box(MP4.types.stts, MP4.STTS),
											MP4.box(MP4.types.stsc, MP4.STSC),
											MP4.box(MP4.types.stsz, MP4.STSZ),
											MP4.box(MP4.types.stco, MP4.STCO)
										);
									};
									MP4.avc1 = function avc1(track) {
										var sps = [],
											pps = [],
											i,
											data,
											len;
										for (i = 0; i < track.sps.length; i++) {
											data = track.sps[i];
											len = data.byteLength;
											sps.push((len >>> 8) & 255);
											sps.push(len & 255);
											sps = sps.concat(Array.prototype.slice.call(data));
										}
										for (i = 0; i < track.pps.length; i++) {
											data = track.pps[i];
											len = data.byteLength;
											pps.push((len >>> 8) & 255);
											pps.push(len & 255);
											pps = pps.concat(Array.prototype.slice.call(data));
										}
										var avcc = MP4.box(
												MP4.types.avcC,
												new Uint8Array(
													[
														1,
														sps[3],
														sps[4],
														sps[5],
														252 | 3,
														224 | track.sps.length,
													]
														.concat(sps)
														.concat([track.pps.length])
														.concat(pps)
												)
											),
											width = track.width,
											height = track.height,
											hSpacing = track.pixelRatio[0],
											vSpacing = track.pixelRatio[1];
										return MP4.box(
											MP4.types.avc1,
											new Uint8Array([
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												1,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												(width >> 8) & 255,
												width & 255,
												(height >> 8) & 255,
												height & 255,
												0,
												72,
												0,
												0,
												0,
												72,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												1,
												18,
												100,
												97,
												105,
												108,
												121,
												109,
												111,
												116,
												105,
												111,
												110,
												47,
												104,
												108,
												115,
												46,
												106,
												115,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												24,
												17,
												17,
											]),
											avcc,
											MP4.box(
												MP4.types.btrt,
												new Uint8Array([
													0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192,
												])
											),
											MP4.box(
												MP4.types.pasp,
												new Uint8Array([
													hSpacing >> 24,
													(hSpacing >> 16) & 255,
													(hSpacing >> 8) & 255,
													hSpacing & 255,
													vSpacing >> 24,
													(vSpacing >> 16) & 255,
													(vSpacing >> 8) & 255,
													vSpacing & 255,
												])
											)
										);
									};
									MP4.esds = function esds(track) {
										var configlen = track.config.length;
										return new Uint8Array(
											[
												0,
												0,
												0,
												0,
												3,
												23 + configlen,
												0,
												1,
												0,
												4,
												15 + configlen,
												64,
												21,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												5,
											]
												.concat([configlen])
												.concat(track.config)
												.concat([6, 1, 2])
										);
									};
									MP4.mp4a = function mp4a(track) {
										var samplerate = track.samplerate;
										return MP4.box(
											MP4.types.mp4a,
											new Uint8Array([
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												1,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												track.channelCount,
												0,
												16,
												0,
												0,
												0,
												0,
												(samplerate >> 8) & 255,
												samplerate & 255,
												0,
												0,
											]),
											MP4.box(MP4.types.esds, MP4.esds(track))
										);
									};
									MP4.mp3 = function mp3(track) {
										var samplerate = track.samplerate;
										return MP4.box(
											MP4.types[".mp3"],
											new Uint8Array([
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												1,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												track.channelCount,
												0,
												16,
												0,
												0,
												0,
												0,
												(samplerate >> 8) & 255,
												samplerate & 255,
												0,
												0,
											])
										);
									};
									MP4.stsd = function stsd(track) {
										if (track.type === "audio") {
											if (!track.isAAC && track.codec === "mp3") {
												return MP4.box(
													MP4.types.stsd,
													MP4.STSD,
													MP4.mp3(track)
												);
											}
											return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
										} else {
											return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
										}
									};
									MP4.tkhd = function tkhd(track) {
										var id = track.id,
											duration = track.duration * track.timescale,
											width = track.width,
											height = track.height,
											upperWordDuration = Math.floor(
												duration / (UINT32_MAX + 1)
											),
											lowerWordDuration = Math.floor(
												duration % (UINT32_MAX + 1)
											);
										return MP4.box(
											MP4.types.tkhd,
											new Uint8Array([
												1,
												0,
												0,
												7,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												2,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												3,
												(id >> 24) & 255,
												(id >> 16) & 255,
												(id >> 8) & 255,
												id & 255,
												0,
												0,
												0,
												0,
												upperWordDuration >> 24,
												(upperWordDuration >> 16) & 255,
												(upperWordDuration >> 8) & 255,
												upperWordDuration & 255,
												lowerWordDuration >> 24,
												(lowerWordDuration >> 16) & 255,
												(lowerWordDuration >> 8) & 255,
												lowerWordDuration & 255,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												1,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												1,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												64,
												0,
												0,
												0,
												(width >> 8) & 255,
												width & 255,
												0,
												0,
												(height >> 8) & 255,
												height & 255,
												0,
												0,
											])
										);
									};
									MP4.traf = function traf(track, baseMediaDecodeTime) {
										var sampleDependencyTable = MP4.sdtp(track),
											id = track.id,
											upperWordBaseMediaDecodeTime = Math.floor(
												baseMediaDecodeTime / (UINT32_MAX + 1)
											),
											lowerWordBaseMediaDecodeTime = Math.floor(
												baseMediaDecodeTime % (UINT32_MAX + 1)
											);
										return MP4.box(
											MP4.types.traf,
											MP4.box(
												MP4.types.tfhd,
												new Uint8Array([
													0,
													0,
													0,
													0,
													id >> 24,
													(id >> 16) & 255,
													(id >> 8) & 255,
													id & 255,
												])
											),
											MP4.box(
												MP4.types.tfdt,
												new Uint8Array([
													1,
													0,
													0,
													0,
													upperWordBaseMediaDecodeTime >> 24,
													(upperWordBaseMediaDecodeTime >> 16) & 255,
													(upperWordBaseMediaDecodeTime >> 8) & 255,
													upperWordBaseMediaDecodeTime & 255,
													lowerWordBaseMediaDecodeTime >> 24,
													(lowerWordBaseMediaDecodeTime >> 16) & 255,
													(lowerWordBaseMediaDecodeTime >> 8) & 255,
													lowerWordBaseMediaDecodeTime & 255,
												])
											),
											MP4.trun(
												track,
												sampleDependencyTable.length + 16 + 20 + 8 + 16 + 8 + 8
											),
											sampleDependencyTable
										);
									};
									MP4.trak = function trak(track) {
										track.duration = track.duration || 4294967295;
										return MP4.box(
											MP4.types.trak,
											MP4.tkhd(track),
											MP4.mdia(track)
										);
									};
									MP4.trex = function trex(track) {
										var id = track.id;
										return MP4.box(
											MP4.types.trex,
											new Uint8Array([
												0,
												0,
												0,
												0,
												id >> 24,
												(id >> 16) & 255,
												(id >> 8) & 255,
												id & 255,
												0,
												0,
												0,
												1,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												0,
												1,
												0,
												1,
											])
										);
									};
									MP4.trun = function trun(track, offset) {
										var samples = track.samples || [],
											len = samples.length,
											arraylen = 12 + 16 * len,
											array = new Uint8Array(arraylen),
											i,
											sample,
											duration,
											size,
											flags,
											cts;
										offset += 8 + arraylen;
										array.set(
											[
												0,
												0,
												15,
												1,
												(len >>> 24) & 255,
												(len >>> 16) & 255,
												(len >>> 8) & 255,
												len & 255,
												(offset >>> 24) & 255,
												(offset >>> 16) & 255,
												(offset >>> 8) & 255,
												offset & 255,
											],
											0
										);
										for (i = 0; i < len; i++) {
											sample = samples[i];
											duration = sample.duration;
											size = sample.size;
											flags = sample.flags;
											cts = sample.cts;
											array.set(
												[
													(duration >>> 24) & 255,
													(duration >>> 16) & 255,
													(duration >>> 8) & 255,
													duration & 255,
													(size >>> 24) & 255,
													(size >>> 16) & 255,
													(size >>> 8) & 255,
													size & 255,
													(flags.isLeading << 2) | flags.dependsOn,
													(flags.isDependedOn << 6) |
														(flags.hasRedundancy << 4) |
														(flags.paddingValue << 1) |
														flags.isNonSync,
													flags.degradPrio & (240 << 8),
													flags.degradPrio & 15,
													(cts >>> 24) & 255,
													(cts >>> 16) & 255,
													(cts >>> 8) & 255,
													cts & 255,
												],
												12 + 16 * i
											);
										}
										return MP4.box(MP4.types.trun, array);
									};
									MP4.initSegment = function initSegment(tracks) {
										if (!MP4.types) {
											MP4.init();
										}
										var movie = MP4.moov(tracks),
											result;
										result = new Uint8Array(
											MP4.FTYP.byteLength + movie.byteLength
										);
										result.set(MP4.FTYP);
										result.set(movie, MP4.FTYP.byteLength);
										return result;
									};
									return MP4;
								})();
								var mp4_generator = MP4;
								var MPEG_TS_CLOCK_FREQ_HZ = 9e4;
								function toTimescaleFromScale(
									value,
									destScale,
									srcScale,
									round
								) {
									if (srcScale === void 0) {
										srcScale = 1;
									}
									if (round === void 0) {
										round = false;
									}
									return toTimescaleFromBase(value, destScale, 1 / srcScale);
								}
								function toTimescaleFromBase(value, destScale, srcBase, round) {
									if (srcBase === void 0) {
										srcBase = 1;
									}
									if (round === void 0) {
										round = false;
									}
									var result = value * destScale * srcBase;
									return round ? Math.round(result) : result;
								}
								function toMsFromMpegTsClock(value, round) {
									if (round === void 0) {
										round = false;
									}
									return toTimescaleFromBase(
										value,
										1e3,
										1 / MPEG_TS_CLOCK_FREQ_HZ,
										round
									);
								}
								function toMpegTsClockFromTimescale(value, srcScale) {
									if (srcScale === void 0) {
										srcScale = 1;
									}
									return toTimescaleFromBase(
										value,
										MPEG_TS_CLOCK_FREQ_HZ,
										1 / srcScale
									);
								}
								var MAX_SILENT_FRAME_DURATION_90KHZ =
									toMpegTsClockFromTimescale(10);
								var PTS_DTS_SHIFT_TOLERANCE_90KHZ =
									toMpegTsClockFromTimescale(0.2);
								var chromeVersion = null;
								var mp4_remuxer_MP4Remuxer = (function () {
									function MP4Remuxer(observer, config, typeSupported, vendor) {
										this.observer = observer;
										this.config = config;
										this.typeSupported = typeSupported;
										this.ISGenerated = false;
										if (chromeVersion === null) {
											var result = navigator.userAgent.match(/Chrome\/(\d+)/i);
											chromeVersion = result ? parseInt(result[1]) : 0;
										}
									}
									var _proto = MP4Remuxer.prototype;
									_proto.destroy = function destroy() {};
									_proto.resetTimeStamp = function resetTimeStamp(
										defaultTimeStamp
									) {
										this._initPTS = this._initDTS = defaultTimeStamp;
									};
									_proto.resetInitSegment = function resetInitSegment() {
										this.ISGenerated = false;
									};
									_proto.getVideoStartPts = function getVideoStartPts(
										videoSamples
									) {
										var rolloverDetected = false;
										var startPTS = videoSamples.reduce(function (
											minPTS,
											sample
										) {
											var delta = sample.pts - minPTS;
											if (delta < -4294967296) {
												rolloverDetected = true;
												return PTSNormalize(minPTS, sample.pts);
											} else if (delta > 0) {
												return minPTS;
											} else {
												return sample.pts;
											}
										},
										videoSamples[0].pts);
										if (rolloverDetected) {
											logger["logger"].debug("PTS rollover detected");
										}
										return startPTS;
									};
									_proto.remux = function remux(
										audioTrack,
										videoTrack,
										id3Track,
										textTrack,
										timeOffset,
										contiguous,
										accurateTimeOffset
									) {
										if (!this.ISGenerated) {
											this.generateIS(audioTrack, videoTrack, timeOffset);
										}
										if (this.ISGenerated) {
											var nbAudioSamples = audioTrack.samples.length;
											var nbVideoSamples = videoTrack.samples.length;
											var audioTimeOffset = timeOffset;
											var videoTimeOffset = timeOffset;
											if (nbAudioSamples && nbVideoSamples) {
												var startPTS = this.getVideoStartPts(
													videoTrack.samples
												);
												var tsDelta =
													PTSNormalize(audioTrack.samples[0].pts, startPTS) -
													startPTS;
												var audiovideoTimestampDelta =
													tsDelta / videoTrack.inputTimeScale;
												audioTimeOffset += Math.max(
													0,
													audiovideoTimestampDelta
												);
												videoTimeOffset += Math.max(
													0,
													-audiovideoTimestampDelta
												);
											}
											if (nbAudioSamples) {
												if (!audioTrack.timescale) {
													logger["logger"].warn(
														"regenerate InitSegment as audio detected"
													);
													this.generateIS(audioTrack, videoTrack, timeOffset);
												}
												var audioData = this.remuxAudio(
													audioTrack,
													audioTimeOffset,
													contiguous,
													accurateTimeOffset
												);
												if (nbVideoSamples) {
													var audioTrackLength;
													if (audioData) {
														audioTrackLength =
															audioData.endPTS - audioData.startPTS;
													}
													if (!videoTrack.timescale) {
														logger["logger"].warn(
															"regenerate InitSegment as video detected"
														);
														this.generateIS(audioTrack, videoTrack, timeOffset);
													}
													this.remuxVideo(
														videoTrack,
														videoTimeOffset,
														contiguous,
														audioTrackLength
													);
												}
											} else {
												if (nbVideoSamples) {
													var videoData = this.remuxVideo(
														videoTrack,
														videoTimeOffset,
														contiguous,
														0,
														accurateTimeOffset
													);
													if (videoData && audioTrack.codec) {
														this.remuxEmptyAudio(
															audioTrack,
															audioTimeOffset,
															contiguous,
															videoData
														);
													}
												}
											}
										}
										if (id3Track.samples.length) {
											this.remuxID3(id3Track, timeOffset);
										}
										if (textTrack.samples.length) {
											this.remuxText(textTrack, timeOffset);
										}
										this.observer.trigger(events["default"].FRAG_PARSED);
									};
									_proto.generateIS = function generateIS(
										audioTrack,
										videoTrack,
										timeOffset
									) {
										var observer = this.observer,
											audioSamples = audioTrack.samples,
											videoSamples = videoTrack.samples,
											typeSupported = this.typeSupported,
											container = "audio/mp4",
											tracks = {},
											data = { tracks: tracks },
											computePTSDTS = this._initPTS === undefined,
											initPTS,
											initDTS;
										if (computePTSDTS) {
											initPTS = initDTS = Infinity;
										}
										if (audioTrack.config && audioSamples.length) {
											audioTrack.timescale = audioTrack.samplerate;
											logger["logger"].log(
												"audio sampling rate : " + audioTrack.samplerate
											);
											if (!audioTrack.isAAC) {
												if (typeSupported.mpeg) {
													container = "audio/mpeg";
													audioTrack.codec = "";
												} else if (typeSupported.mp3) {
													audioTrack.codec = "mp3";
												}
											}
											tracks.audio = {
												container: container,
												codec: audioTrack.codec,
												initSegment:
													!audioTrack.isAAC && typeSupported.mpeg
														? new Uint8Array()
														: mp4_generator.initSegment([audioTrack]),
												metadata: { channelCount: audioTrack.channelCount },
											};
											if (computePTSDTS) {
												initPTS = initDTS =
													audioSamples[0].pts -
													Math.round(audioTrack.inputTimeScale * timeOffset);
											}
										}
										if (
											videoTrack.sps &&
											videoTrack.pps &&
											videoSamples.length
										) {
											var inputTimeScale = videoTrack.inputTimeScale;
											videoTrack.timescale = inputTimeScale;
											tracks.video = {
												container: "video/mp4",
												codec: videoTrack.codec,
												initSegment: mp4_generator.initSegment([videoTrack]),
												metadata: {
													width: videoTrack.width,
													height: videoTrack.height,
												},
											};
											if (computePTSDTS) {
												var startPTS = this.getVideoStartPts(videoSamples);
												var startOffset = Math.round(
													inputTimeScale * timeOffset
												);
												initDTS = Math.min(
													initDTS,
													PTSNormalize(videoSamples[0].dts, startPTS) -
														startOffset
												);
												initPTS = Math.min(initPTS, startPTS - startOffset);
												this.observer.trigger(
													events["default"].INIT_PTS_FOUND,
													{ initPTS: initPTS }
												);
											}
										} else if (computePTSDTS && tracks.audio) {
											this.observer.trigger(events["default"].INIT_PTS_FOUND, {
												initPTS: initPTS,
											});
										}
										if (Object.keys(tracks).length) {
											observer.trigger(
												events["default"].FRAG_PARSING_INIT_SEGMENT,
												data
											);
											this.ISGenerated = true;
											if (computePTSDTS) {
												this._initPTS = initPTS;
												this._initDTS = initDTS;
											}
										} else {
											observer.trigger(events["default"].ERROR, {
												type: errors["ErrorTypes"].MEDIA_ERROR,
												details: errors["ErrorDetails"].FRAG_PARSING_ERROR,
												fatal: false,
												reason: "no audio/video samples found",
											});
										}
									};
									_proto.remuxVideo = function remuxVideo(
										track,
										timeOffset,
										contiguous,
										audioTrackLength
									) {
										var timeScale = track.timescale;
										var inputSamples = track.samples;
										var outputSamples = [];
										var nbSamples = inputSamples.length;
										var initPTS = this._initPTS;
										var offset = 8;
										var mp4SampleDuration;
										var mdat;
										var moof;
										var firstDTS;
										var lastDTS;
										var minPTS = Number.POSITIVE_INFINITY;
										var maxPTS = Number.NEGATIVE_INFINITY;
										var ptsDtsShift = 0;
										var sortSamples = false;
										var nextAvcDts = this.nextAvcDts;
										if (nbSamples === 0) {
											return;
										}
										if (!contiguous) {
											var pts = timeOffset * timeScale;
											var cts =
												inputSamples[0].pts -
												PTSNormalize(inputSamples[0].dts, inputSamples[0].pts);
											nextAvcDts = pts - cts;
										}
										for (var i = 0; i < nbSamples; i++) {
											var sample = inputSamples[i];
											sample.pts = PTSNormalize(
												sample.pts - initPTS,
												nextAvcDts
											);
											sample.dts = PTSNormalize(
												sample.dts - initPTS,
												nextAvcDts
											);
											if (sample.dts > sample.pts) {
												ptsDtsShift = Math.max(
													Math.min(ptsDtsShift, sample.pts - sample.dts),
													-1 * PTS_DTS_SHIFT_TOLERANCE_90KHZ
												);
											}
											if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {
												sortSamples = true;
											}
										}
										if (sortSamples) {
											inputSamples.sort(function (a, b) {
												var deltadts = a.dts - b.dts;
												var deltapts = a.pts - b.pts;
												return deltadts || deltapts || a.id - b.id;
											});
										}
										firstDTS = inputSamples[0].dts;
										lastDTS = inputSamples[nbSamples - 1].dts;
										var averageSampleDuration = Math.round(
											(lastDTS - firstDTS) / (nbSamples - 1)
										);
										if (ptsDtsShift < 0) {
											if (ptsDtsShift < averageSampleDuration * -2) {
												logger["logger"].warn(
													"PTS < DTS detected in video samples, offsetting DTS from PTS by " +
														toMsFromMpegTsClock(-averageSampleDuration, true) +
														" ms"
												);
												var lastDts = ptsDtsShift;
												for (var _i = 0; _i < nbSamples; _i++) {
													inputSamples[_i].dts = lastDts = Math.max(
														lastDts,
														inputSamples[_i].pts - averageSampleDuration
													);
													inputSamples[_i].pts = Math.max(
														lastDts,
														inputSamples[_i].pts
													);
												}
											} else {
												logger["logger"].warn(
													"PTS < DTS detected in video samples, shifting DTS by " +
														toMsFromMpegTsClock(ptsDtsShift, true) +
														" ms to overcome this issue"
												);
												for (var _i2 = 0; _i2 < nbSamples; _i2++) {
													inputSamples[_i2].dts =
														inputSamples[_i2].dts + ptsDtsShift;
												}
											}
											firstDTS = inputSamples[0].dts;
											lastDTS = inputSamples[nbSamples - 1].dts;
										}
										if (contiguous) {
											var delta = firstDTS - nextAvcDts;
											var foundHole = delta > averageSampleDuration;
											var foundOverlap = delta < -1;
											if (foundHole || foundOverlap) {
												if (foundHole) {
													logger["logger"].warn(
														"AVC: " +
															toMsFromMpegTsClock(delta, true) +
															" ms (" +
															delta +
															"dts) hole between fragments detected, filling it"
													);
												} else {
													logger["logger"].warn(
														"AVC: " +
															toMsFromMpegTsClock(-delta, true) +
															" ms (" +
															delta +
															"dts) overlapping between fragments detected"
													);
												}
												firstDTS = nextAvcDts;
												var firstPTS = inputSamples[0].pts - delta;
												inputSamples[0].dts = firstDTS;
												inputSamples[0].pts = firstPTS;
												logger["logger"].log(
													"Video: First PTS/DTS adjusted: " +
														toMsFromMpegTsClock(firstPTS, true) +
														"/" +
														toMsFromMpegTsClock(firstDTS, true) +
														", delta: " +
														toMsFromMpegTsClock(delta, true) +
														" ms"
												);
											}
										}
										if (chromeVersion && chromeVersion < 75) {
											firstDTS = Math.max(0, firstDTS);
										}
										var nbNalu = 0;
										var naluLen = 0;
										for (var _i3 = 0; _i3 < nbSamples; _i3++) {
											var _sample = inputSamples[_i3];
											var units = _sample.units;
											var nbUnits = units.length;
											var sampleLen = 0;
											for (var j = 0; j < nbUnits; j++) {
												sampleLen += units[j].data.length;
											}
											naluLen += sampleLen;
											nbNalu += nbUnits;
											_sample.length = sampleLen;
											_sample.dts = Math.max(_sample.dts, firstDTS);
											_sample.pts = Math.max(_sample.pts, _sample.dts, 0);
											minPTS = Math.min(_sample.pts, minPTS);
											maxPTS = Math.max(_sample.pts, maxPTS);
										}
										lastDTS = inputSamples[nbSamples - 1].dts;
										var mdatSize = naluLen + 4 * nbNalu + 8;
										try {
											mdat = new Uint8Array(mdatSize);
										} catch (err) {
											this.observer.trigger(events["default"].ERROR, {
												type: errors["ErrorTypes"].MUX_ERROR,
												details: errors["ErrorDetails"].REMUX_ALLOC_ERROR,
												fatal: false,
												bytes: mdatSize,
												reason: "fail allocating video mdat " + mdatSize,
											});
											return;
										}
										var view = new DataView(mdat.buffer);
										view.setUint32(0, mdatSize);
										mdat.set(mp4_generator.types.mdat, 4);
										for (var _i4 = 0; _i4 < nbSamples; _i4++) {
											var avcSample = inputSamples[_i4];
											var avcSampleUnits = avcSample.units;
											var mp4SampleLength = 0;
											var compositionTimeOffset = void 0;
											for (
												var _j = 0, _nbUnits = avcSampleUnits.length;
												_j < _nbUnits;
												_j++
											) {
												var unit = avcSampleUnits[_j];
												var unitData = unit.data;
												var unitDataLen = unit.data.byteLength;
												view.setUint32(offset, unitDataLen);
												offset += 4;
												mdat.set(unitData, offset);
												offset += unitDataLen;
												mp4SampleLength += 4 + unitDataLen;
											}
											if (_i4 < nbSamples - 1) {
												mp4SampleDuration =
													inputSamples[_i4 + 1].dts - avcSample.dts;
											} else {
												var config = this.config;
												var lastFrameDuration =
													avcSample.dts -
													inputSamples[_i4 > 0 ? _i4 - 1 : _i4].dts;
												if (config.stretchShortVideoTrack) {
													var maxBufferHole = config.maxBufferHole;
													var gapTolerance = Math.floor(
														maxBufferHole * timeScale
													);
													var deltaToFrameEnd =
														(audioTrackLength
															? minPTS + audioTrackLength * timeScale
															: this.nextAudioPts) - avcSample.pts;
													if (deltaToFrameEnd > gapTolerance) {
														mp4SampleDuration =
															deltaToFrameEnd - lastFrameDuration;
														if (mp4SampleDuration < 0) {
															mp4SampleDuration = lastFrameDuration;
														}
														logger["logger"].log(
															"It is approximately " +
																toMsFromMpegTsClock(deltaToFrameEnd, false) +
																" ms to the next segment; using duration " +
																toMsFromMpegTsClock(mp4SampleDuration, false) +
																" ms for the last video frame."
														);
													} else {
														mp4SampleDuration = lastFrameDuration;
													}
												} else {
													mp4SampleDuration = lastFrameDuration;
												}
											}
											compositionTimeOffset = Math.round(
												avcSample.pts - avcSample.dts
											);
											outputSamples.push({
												size: mp4SampleLength,
												duration: mp4SampleDuration,
												cts: compositionTimeOffset,
												flags: {
													isLeading: 0,
													isDependedOn: 0,
													hasRedundancy: 0,
													degradPrio: 0,
													dependsOn: avcSample.key ? 2 : 1,
													isNonSync: avcSample.key ? 0 : 1,
												},
											});
										}
										this.nextAvcDts = lastDTS + mp4SampleDuration;
										var dropped = track.dropped;
										track.nbNalu = 0;
										track.dropped = 0;
										if (
											outputSamples.length &&
											navigator.userAgent.toLowerCase().indexOf("chrome") > -1
										) {
											var flags = outputSamples[0].flags;
											flags.dependsOn = 2;
											flags.isNonSync = 0;
										}
										track.samples = outputSamples;
										moof = mp4_generator.moof(
											track.sequenceNumber++,
											firstDTS,
											track
										);
										track.samples = [];
										var data = {
											data1: moof,
											data2: mdat,
											startPTS: minPTS / timeScale,
											endPTS: (maxPTS + mp4SampleDuration) / timeScale,
											startDTS: firstDTS / timeScale,
											endDTS: this.nextAvcDts / timeScale,
											type: "video",
											hasAudio: false,
											hasVideo: true,
											nb: outputSamples.length,
											dropped: dropped,
										};
										this.observer.trigger(
											events["default"].FRAG_PARSING_DATA,
											data
										);
										return data;
									};
									_proto.remuxAudio = function remuxAudio(
										track,
										timeOffset,
										contiguous,
										accurateTimeOffset
									) {
										var inputTimeScale = track.inputTimeScale;
										var mp4timeScale = track.timescale;
										var scaleFactor = inputTimeScale / mp4timeScale;
										var mp4SampleDuration = track.isAAC ? 1024 : 1152;
										var inputSampleDuration = mp4SampleDuration * scaleFactor;
										var initPTS = this._initPTS;
										var rawMPEG = !track.isAAC && this.typeSupported.mpeg;
										var mp4Sample;
										var fillFrame;
										var mdat;
										var moof;
										var firstPTS;
										var lastPTS;
										var offset = rawMPEG ? 0 : 8;
										var inputSamples = track.samples;
										var outputSamples = [];
										var nextAudioPts = this.nextAudioPts;
										contiguous |=
											inputSamples.length &&
											nextAudioPts &&
											((accurateTimeOffset &&
												Math.abs(timeOffset - nextAudioPts / inputTimeScale) <
													0.1) ||
												Math.abs(inputSamples[0].pts - nextAudioPts - initPTS) <
													20 * inputSampleDuration);
										inputSamples.forEach(function (sample) {
											sample.pts = sample.dts = PTSNormalize(
												sample.pts - initPTS,
												timeOffset * inputTimeScale
											);
										});
										inputSamples = inputSamples.filter(function (sample) {
											return sample.pts >= 0;
										});
										if (inputSamples.length === 0) {
											return;
										}
										if (!contiguous) {
											if (!accurateTimeOffset) {
												nextAudioPts = inputSamples[0].pts;
											} else {
												nextAudioPts = Math.max(0, timeOffset * inputTimeScale);
											}
										}
										if (track.isAAC) {
											var maxAudioFramesDrift = this.config.maxAudioFramesDrift;
											for (
												var i = 0, nextPts = nextAudioPts;
												i < inputSamples.length;

											) {
												var sample = inputSamples[i];
												var pts = sample.pts;
												var delta = pts - nextPts;
												if (
													delta <=
													-maxAudioFramesDrift * inputSampleDuration
												) {
													if (contiguous || i > 0) {
														logger["logger"].warn(
															"Dropping 1 audio frame @ " +
																toMsFromMpegTsClock(nextPts, true) / 1e3 +
																"s due to " +
																toMsFromMpegTsClock(delta, true) +
																" ms overlap."
														);
														inputSamples.splice(i, 1);
													} else {
														logger["logger"].warn(
															"Audio frame @ " +
																toMsFromMpegTsClock(pts, true) / 1e3 +
																"s overlaps nextAudioPts by " +
																toMsFromMpegTsClock(delta, true) +
																" ms."
														);
														nextPts = pts + inputSampleDuration;
														i++;
													}
												} else if (
													delta >= maxAudioFramesDrift * inputSampleDuration &&
													delta < MAX_SILENT_FRAME_DURATION_90KHZ &&
													nextPts
												) {
													var missing = Math.round(delta / inputSampleDuration);
													logger["logger"].warn(
														"Injecting " +
															missing +
															" audio frames @ " +
															toMsFromMpegTsClock(nextPts, true) / 1e3 +
															"s due to " +
															toMsFromMpegTsClock(delta, true) +
															" ms gap."
													);
													for (var j = 0; j < missing; j++) {
														var newStamp = Math.max(nextPts, 0);
														fillFrame = aac_helper.getSilentFrame(
															track.manifestCodec || track.codec,
															track.channelCount
														);
														if (!fillFrame) {
															logger["logger"].log(
																"Unable to get silent frame for given audio codec; duplicating last frame instead."
															);
															fillFrame = sample.unit.subarray();
														}
														inputSamples.splice(i, 0, {
															unit: fillFrame,
															pts: newStamp,
															dts: newStamp,
														});
														nextPts += inputSampleDuration;
														i++;
													}
													sample.pts = sample.dts = nextPts;
													nextPts += inputSampleDuration;
													i++;
												} else {
													if (Math.abs(delta) > 0.1 * inputSampleDuration) {
													}
													sample.pts = sample.dts = nextPts;
													nextPts += inputSampleDuration;
													i++;
												}
											}
										}
										var nbSamples = inputSamples.length;
										var mdatSize = 0;
										while (nbSamples--) {
											mdatSize += inputSamples[nbSamples].unit.byteLength;
										}
										for (
											var _j2 = 0, _nbSamples = inputSamples.length;
											_j2 < _nbSamples;
											_j2++
										) {
											var audioSample = inputSamples[_j2];
											var unit = audioSample.unit;
											var _pts = audioSample.pts;
											if (lastPTS !== undefined && mp4Sample) {
												mp4Sample.duration = Math.round(
													(_pts - lastPTS) / scaleFactor
												);
											} else {
												var _delta = _pts - nextAudioPts;
												var numMissingFrames = 0;
												if (contiguous && track.isAAC) {
													if (_delta) {
														if (
															_delta > 0 &&
															_delta < MAX_SILENT_FRAME_DURATION_90KHZ
														) {
															numMissingFrames = Math.round(
																(_pts - nextAudioPts) / inputSampleDuration
															);
															logger["logger"].log(
																toMsFromMpegTsClock(_delta, true) +
																	" ms hole between AAC samples detected,filling it"
															);
															if (numMissingFrames > 0) {
																fillFrame = aac_helper.getSilentFrame(
																	track.manifestCodec || track.codec,
																	track.channelCount
																);
																if (!fillFrame) {
																	fillFrame = unit.subarray();
																}
																mdatSize += numMissingFrames * fillFrame.length;
															}
														} else if (_delta < -12) {
															logger["logger"].log(
																"drop overlapping AAC sample, expected/parsed/delta: " +
																	toMsFromMpegTsClock(nextAudioPts, true) +
																	" ms / " +
																	toMsFromMpegTsClock(_pts, true) +
																	" ms / " +
																	toMsFromMpegTsClock(-_delta, true) +
																	" ms"
															);
															mdatSize -= unit.byteLength;
															continue;
														}
														_pts = nextAudioPts;
													}
												}
												firstPTS = _pts;
												if (mdatSize > 0) {
													mdatSize += offset;
													try {
														mdat = new Uint8Array(mdatSize);
													} catch (err) {
														this.observer.trigger(events["default"].ERROR, {
															type: errors["ErrorTypes"].MUX_ERROR,
															details: errors["ErrorDetails"].REMUX_ALLOC_ERROR,
															fatal: false,
															bytes: mdatSize,
															reason: "fail allocating audio mdat " + mdatSize,
														});
														return;
													}
													if (!rawMPEG) {
														var view = new DataView(mdat.buffer);
														view.setUint32(0, mdatSize);
														mdat.set(mp4_generator.types.mdat, 4);
													}
												} else {
													return;
												}
												for (var _i5 = 0; _i5 < numMissingFrames; _i5++) {
													fillFrame = aac_helper.getSilentFrame(
														track.manifestCodec || track.codec,
														track.channelCount
													);
													if (!fillFrame) {
														logger["logger"].log(
															"Unable to get silent frame for given audio codec; duplicating this frame instead."
														);
														fillFrame = unit.subarray();
													}
													mdat.set(fillFrame, offset);
													offset += fillFrame.byteLength;
													mp4Sample = {
														size: fillFrame.byteLength,
														cts: 0,
														duration: 1024,
														flags: {
															isLeading: 0,
															isDependedOn: 0,
															hasRedundancy: 0,
															degradPrio: 0,
															dependsOn: 1,
														},
													};
													outputSamples.push(mp4Sample);
												}
											}
											mdat.set(unit, offset);
											var unitLen = unit.byteLength;
											offset += unitLen;
											mp4Sample = {
												size: unitLen,
												cts: 0,
												duration: 0,
												flags: {
													isLeading: 0,
													isDependedOn: 0,
													hasRedundancy: 0,
													degradPrio: 0,
													dependsOn: 1,
												},
											};
											outputSamples.push(mp4Sample);
											lastPTS = _pts;
										}
										var lastSampleDuration = 0;
										nbSamples = outputSamples.length;
										if (nbSamples >= 2) {
											lastSampleDuration =
												outputSamples[nbSamples - 2].duration;
											mp4Sample.duration = lastSampleDuration;
										}
										if (nbSamples) {
											this.nextAudioPts = nextAudioPts =
												lastPTS + scaleFactor * lastSampleDuration;
											track.samples = outputSamples;
											if (rawMPEG) {
												moof = new Uint8Array();
											} else {
												moof = mp4_generator.moof(
													track.sequenceNumber++,
													firstPTS / scaleFactor,
													track
												);
											}
											track.samples = [];
											var start = firstPTS / inputTimeScale;
											var end = nextAudioPts / inputTimeScale;
											var audioData = {
												data1: moof,
												data2: mdat,
												startPTS: start,
												endPTS: end,
												startDTS: start,
												endDTS: end,
												type: "audio",
												hasAudio: true,
												hasVideo: false,
												nb: nbSamples,
											};
											this.observer.trigger(
												events["default"].FRAG_PARSING_DATA,
												audioData
											);
											return audioData;
										}
										return null;
									};
									_proto.remuxEmptyAudio = function remuxEmptyAudio(
										track,
										timeOffset,
										contiguous,
										videoData
									) {
										var inputTimeScale = track.inputTimeScale;
										var mp4timeScale = track.samplerate
											? track.samplerate
											: inputTimeScale;
										var scaleFactor = inputTimeScale / mp4timeScale;
										var nextAudioPts = this.nextAudioPts;
										var startDTS =
											(nextAudioPts !== undefined
												? nextAudioPts
												: videoData.startDTS * inputTimeScale) + this._initDTS;
										var endDTS =
											videoData.endDTS * inputTimeScale + this._initDTS;
										var sampleDuration = 1024;
										var frameDuration = scaleFactor * sampleDuration;
										var nbSamples = Math.ceil(
											(endDTS - startDTS) / frameDuration
										);
										var silentFrame = aac_helper.getSilentFrame(
											track.manifestCodec || track.codec,
											track.channelCount
										);
										logger["logger"].warn("remux empty Audio");
										if (!silentFrame) {
											logger["logger"].trace(
												"Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!"
											);
											return;
										}
										var samples = [];
										for (var i = 0; i < nbSamples; i++) {
											var stamp = startDTS + i * frameDuration;
											samples.push({
												unit: silentFrame,
												pts: stamp,
												dts: stamp,
											});
										}
										track.samples = samples;
										this.remuxAudio(track, timeOffset, contiguous);
									};
									_proto.remuxID3 = function remuxID3(track, timeOffset) {
										var length = track.samples.length;
										if (!length) {
											return;
										}
										var inputTimeScale = track.inputTimeScale;
										var initPTS = this._initPTS;
										var initDTS = this._initDTS;
										for (var index = 0; index < length; index++) {
											var sample = track.samples[index];
											sample.pts =
												PTSNormalize(
													sample.pts - initPTS,
													timeOffset * inputTimeScale
												) / inputTimeScale;
											sample.dts =
												PTSNormalize(
													sample.dts - initDTS,
													timeOffset * inputTimeScale
												) / inputTimeScale;
										}
										this.observer.trigger(
											events["default"].FRAG_PARSING_METADATA,
											{ samples: track.samples }
										);
										track.samples = [];
									};
									_proto.remuxText = function remuxText(track, timeOffset) {
										var length = track.samples.length;
										var inputTimeScale = track.inputTimeScale;
										var initPTS = this._initPTS;
										if (length) {
											for (var index = 0; index < length; index++) {
												var sample = track.samples[index];
												sample.pts =
													PTSNormalize(
														sample.pts - initPTS,
														timeOffset * inputTimeScale
													) / inputTimeScale;
											}
											track.samples.sort(function (a, b) {
												return a.pts - b.pts;
											});
											this.observer.trigger(
												events["default"].FRAG_PARSING_USERDATA,
												{ samples: track.samples }
											);
										}
										track.samples = [];
									};
									return MP4Remuxer;
								})();
								function PTSNormalize(value, reference) {
									var offset;
									if (reference === undefined) {
										return value;
									}
									if (reference < value) {
										offset = -8589934592;
									} else {
										offset = 8589934592;
									}
									while (Math.abs(value - reference) > 4294967296) {
										value += offset;
									}
									return value;
								}
								var mp4_remuxer = mp4_remuxer_MP4Remuxer;
								var passthrough_remuxer_PassThroughRemuxer = (function () {
									function PassThroughRemuxer(observer) {
										this.observer = observer;
									}
									var _proto = PassThroughRemuxer.prototype;
									_proto.destroy = function destroy() {};
									_proto.resetTimeStamp = function resetTimeStamp() {};
									_proto.resetInitSegment = function resetInitSegment() {};
									_proto.remux = function remux(
										audioTrack,
										videoTrack,
										id3Track,
										textTrack,
										timeOffset,
										contiguous,
										accurateTimeOffset,
										rawData
									) {
										var observer = this.observer;
										var streamType = "";
										if (audioTrack) {
											streamType += "audio";
										}
										if (videoTrack) {
											streamType += "video";
										}
										observer.trigger(events["default"].FRAG_PARSING_DATA, {
											data1: rawData,
											startPTS: timeOffset,
											startDTS: timeOffset,
											type: streamType,
											hasAudio: !!audioTrack,
											hasVideo: !!videoTrack,
											nb: 1,
											dropped: 0,
										});
										observer.trigger(events["default"].FRAG_PARSED);
									};
									return PassThroughRemuxer;
								})();
								var passthrough_remuxer =
									passthrough_remuxer_PassThroughRemuxer;
								var global = Object(get_self_scope["getSelfScope"])();
								var now;
								try {
									now = global.performance.now.bind(global.performance);
								} catch (err) {
									logger["logger"].debug(
										"Unable to use Performance API on this environment"
									);
									now = global.Date.now;
								}
								var demuxer_inline_DemuxerInline = (function () {
									function DemuxerInline(
										observer,
										typeSupported,
										config,
										vendor
									) {
										this.observer = observer;
										this.typeSupported = typeSupported;
										this.config = config;
										this.vendor = vendor;
									}
									var _proto = DemuxerInline.prototype;
									_proto.destroy = function destroy() {
										var demuxer = this.demuxer;
										if (demuxer) {
											demuxer.destroy();
										}
									};
									_proto.push = function push(
										data,
										decryptdata,
										initSegment,
										audioCodec,
										videoCodec,
										timeOffset,
										discontinuity,
										trackSwitch,
										contiguous,
										duration,
										accurateTimeOffset,
										defaultInitPTS
									) {
										var _this = this;
										if (
											data.byteLength > 0 &&
											decryptdata != null &&
											decryptdata.key != null &&
											decryptdata.method === "AES-128"
										) {
											var decrypter = this.decrypter;
											if (decrypter == null) {
												decrypter = this.decrypter = new crypt_decrypter[
													"default"
												](this.observer, this.config);
											}
											var startTime = now();
											decrypter.decrypt(
												data,
												decryptdata.key.buffer,
												decryptdata.iv.buffer,
												function (decryptedData) {
													var endTime = now();
													_this.observer.trigger(
														events["default"].FRAG_DECRYPTED,
														{ stats: { tstart: startTime, tdecrypt: endTime } }
													);
													_this.pushDecrypted(
														new Uint8Array(decryptedData),
														decryptdata,
														new Uint8Array(initSegment),
														audioCodec,
														videoCodec,
														timeOffset,
														discontinuity,
														trackSwitch,
														contiguous,
														duration,
														accurateTimeOffset,
														defaultInitPTS
													);
												}
											);
										} else {
											this.pushDecrypted(
												new Uint8Array(data),
												decryptdata,
												new Uint8Array(initSegment),
												audioCodec,
												videoCodec,
												timeOffset,
												discontinuity,
												trackSwitch,
												contiguous,
												duration,
												accurateTimeOffset,
												defaultInitPTS
											);
										}
									};
									_proto.pushDecrypted = function pushDecrypted(
										data,
										decryptdata,
										initSegment,
										audioCodec,
										videoCodec,
										timeOffset,
										discontinuity,
										trackSwitch,
										contiguous,
										duration,
										accurateTimeOffset,
										defaultInitPTS
									) {
										var demuxer = this.demuxer;
										var remuxer = this.remuxer;
										if (!demuxer || discontinuity || trackSwitch) {
											var observer = this.observer;
											var typeSupported = this.typeSupported;
											var config = this.config;
											var muxConfig = [
												{ demux: tsdemuxer, remux: mp4_remuxer },
												{
													demux: mp4demuxer["default"],
													remux: passthrough_remuxer,
												},
												{ demux: aacdemuxer, remux: mp4_remuxer },
												{ demux: mp3demuxer, remux: mp4_remuxer },
											];
											var mux;
											for (var i = 0, len = muxConfig.length; i < len; i++) {
												mux = muxConfig[i];
												if (mux.demux.probe(data)) {
													break;
												}
											}
											if (!mux) {
												observer.trigger(events["default"].ERROR, {
													type: errors["ErrorTypes"].MEDIA_ERROR,
													details: errors["ErrorDetails"].FRAG_PARSING_ERROR,
													fatal: true,
													reason: "no demux matching with content found",
												});
												return;
											}
											if (!remuxer || !(remuxer instanceof mux.remux)) {
												remuxer = new mux.remux(
													observer,
													config,
													typeSupported,
													this.vendor
												);
											}
											if (!demuxer || !(demuxer instanceof mux.demux)) {
												demuxer = new mux.demux(
													observer,
													remuxer,
													config,
													typeSupported
												);
												this.probe = mux.demux.probe;
											}
											this.demuxer = demuxer;
											this.remuxer = remuxer;
										}
										if (discontinuity || trackSwitch) {
											demuxer.resetInitSegment(
												initSegment,
												audioCodec,
												videoCodec,
												duration
											);
											remuxer.resetInitSegment();
										}
										if (discontinuity) {
											demuxer.resetTimeStamp(defaultInitPTS);
											remuxer.resetTimeStamp(defaultInitPTS);
										}
										if (typeof demuxer.setDecryptData === "function") {
											demuxer.setDecryptData(decryptdata);
										}
										demuxer.append(
											data,
											timeOffset,
											contiguous,
											accurateTimeOffset
										);
									};
									return DemuxerInline;
								})();
								var demuxer_inline = (__webpack_exports__["default"] =
									demuxer_inline_DemuxerInline);
							},
							"./src/demux/demuxer-worker.js": function (
								module,
								__webpack_exports__,
								__webpack_require__
							) {
								"use strict";
								__webpack_require__.r(__webpack_exports__);
								var _demux_demuxer_inline__WEBPACK_IMPORTED_MODULE_0__ =
									__webpack_require__("./src/demux/demuxer-inline.js");
								var _events__WEBPACK_IMPORTED_MODULE_1__ =
									__webpack_require__("./src/events.js");
								var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ =
									__webpack_require__("./src/utils/logger.js");
								var eventemitter3__WEBPACK_IMPORTED_MODULE_3__ =
									__webpack_require__("./node_modules/eventemitter3/index.js");
								var eventemitter3__WEBPACK_IMPORTED_MODULE_3___default =
									__webpack_require__.n(
										eventemitter3__WEBPACK_IMPORTED_MODULE_3__
									);
								var DemuxerWorker = function DemuxerWorker(self) {
									var observer = new eventemitter3__WEBPACK_IMPORTED_MODULE_3__[
										"EventEmitter"
									]();
									observer.trigger = function trigger(event) {
										for (
											var _len = arguments.length,
												data = new Array(_len > 1 ? _len - 1 : 0),
												_key = 1;
											_key < _len;
											_key++
										) {
											data[_key - 1] = arguments[_key];
										}
										observer.emit.apply(observer, [event, event].concat(data));
									};
									observer.off = function off(event) {
										for (
											var _len2 = arguments.length,
												data = new Array(_len2 > 1 ? _len2 - 1 : 0),
												_key2 = 1;
											_key2 < _len2;
											_key2++
										) {
											data[_key2 - 1] = arguments[_key2];
										}
										observer.removeListener.apply(
											observer,
											[event].concat(data)
										);
									};
									var forwardMessage = function forwardMessage(ev, data) {
										self.postMessage({ event: ev, data: data });
									};
									self.addEventListener("message", function (ev) {
										var data = ev.data;
										switch (data.cmd) {
											case "init":
												var config = JSON.parse(data.config);
												self.demuxer =
													new _demux_demuxer_inline__WEBPACK_IMPORTED_MODULE_0__[
														"default"
													](observer, data.typeSupported, config, data.vendor);
												Object(
													_utils_logger__WEBPACK_IMPORTED_MODULE_2__[
														"enableLogs"
													]
												)(config.debug);
												forwardMessage("init", null);
												break;
											case "demux":
												self.demuxer.push(
													data.data,
													data.decryptdata,
													data.initSegment,
													data.audioCodec,
													data.videoCodec,
													data.timeOffset,
													data.discontinuity,
													data.trackSwitch,
													data.contiguous,
													data.duration,
													data.accurateTimeOffset,
													data.defaultInitPTS
												);
												break;
											default:
												break;
										}
									});
									observer.on(
										_events__WEBPACK_IMPORTED_MODULE_1__["default"]
											.FRAG_DECRYPTED,
										forwardMessage
									);
									observer.on(
										_events__WEBPACK_IMPORTED_MODULE_1__["default"]
											.FRAG_PARSING_INIT_SEGMENT,
										forwardMessage
									);
									observer.on(
										_events__WEBPACK_IMPORTED_MODULE_1__["default"].FRAG_PARSED,
										forwardMessage
									);
									observer.on(
										_events__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR,
										forwardMessage
									);
									observer.on(
										_events__WEBPACK_IMPORTED_MODULE_1__["default"]
											.FRAG_PARSING_METADATA,
										forwardMessage
									);
									observer.on(
										_events__WEBPACK_IMPORTED_MODULE_1__["default"]
											.FRAG_PARSING_USERDATA,
										forwardMessage
									);
									observer.on(
										_events__WEBPACK_IMPORTED_MODULE_1__["default"]
											.INIT_PTS_FOUND,
										forwardMessage
									);
									observer.on(
										_events__WEBPACK_IMPORTED_MODULE_1__["default"]
											.FRAG_PARSING_DATA,
										function (ev, data) {
											var transferable = [];
											var message = { event: ev, data: data };
											if (data.data1) {
												message.data1 = data.data1.buffer;
												transferable.push(data.data1.buffer);
												delete data.data1;
											}
											if (data.data2) {
												message.data2 = data.data2.buffer;
												transferable.push(data.data2.buffer);
												delete data.data2;
											}
											self.postMessage(message, transferable);
										}
									);
								};
								__webpack_exports__["default"] = DemuxerWorker;
							},
							"./src/demux/id3.js": function (
								module,
								__webpack_exports__,
								__webpack_require__
							) {
								"use strict";
								__webpack_require__.r(__webpack_exports__);
								__webpack_require__.d(
									__webpack_exports__,
									"utf8ArrayToStr",
									function () {
										return utf8ArrayToStr;
									}
								);
								var _utils_get_self_scope__WEBPACK_IMPORTED_MODULE_0__ =
									__webpack_require__("./src/utils/get-self-scope.js");
								var ID3 = (function () {
									function ID3() {}
									ID3.isHeader = function isHeader(data, offset) {
										if (offset + 10 <= data.length) {
											if (
												data[offset] === 73 &&
												data[offset + 1] === 68 &&
												data[offset + 2] === 51
											) {
												if (data[offset + 3] < 255 && data[offset + 4] < 255) {
													if (
														data[offset + 6] < 128 &&
														data[offset + 7] < 128 &&
														data[offset + 8] < 128 &&
														data[offset + 9] < 128
													) {
														return true;
													}
												}
											}
										}
										return false;
									};
									ID3.isFooter = function isFooter(data, offset) {
										if (offset + 10 <= data.length) {
											if (
												data[offset] === 51 &&
												data[offset + 1] === 68 &&
												data[offset + 2] === 73
											) {
												if (data[offset + 3] < 255 && data[offset + 4] < 255) {
													if (
														data[offset + 6] < 128 &&
														data[offset + 7] < 128 &&
														data[offset + 8] < 128 &&
														data[offset + 9] < 128
													) {
														return true;
													}
												}
											}
										}
										return false;
									};
									ID3.getID3Data = function getID3Data(data, offset) {
										var front = offset;
										var length = 0;
										while (ID3.isHeader(data, offset)) {
											length += 10;
											var size = ID3._readSize(data, offset + 6);
											length += size;
											if (ID3.isFooter(data, offset + 10)) {
												length += 10;
											}
											offset += length;
										}
										if (length > 0) {
											return data.subarray(front, front + length);
										}
										return undefined;
									};
									ID3._readSize = function _readSize(data, offset) {
										var size = 0;
										size = (data[offset] & 127) << 21;
										size |= (data[offset + 1] & 127) << 14;
										size |= (data[offset + 2] & 127) << 7;
										size |= data[offset + 3] & 127;
										return size;
									};
									ID3.getTimeStamp = function getTimeStamp(data) {
										var frames = ID3.getID3Frames(data);
										for (var i = 0; i < frames.length; i++) {
											var frame = frames[i];
											if (ID3.isTimeStampFrame(frame)) {
												return ID3._readTimeStamp(frame);
											}
										}
										return undefined;
									};
									ID3.isTimeStampFrame = function isTimeStampFrame(frame) {
										return (
											frame &&
											frame.key === "PRIV" &&
											frame.info ===
												"com.apple.streaming.transportStreamTimestamp"
										);
									};
									ID3._getFrameData = function _getFrameData(data) {
										var type = String.fromCharCode(
											data[0],
											data[1],
											data[2],
											data[3]
										);
										var size = ID3._readSize(data, 4);
										var offset = 10;
										return {
											type: type,
											size: size,
											data: data.subarray(offset, offset + size),
										};
									};
									ID3.getID3Frames = function getID3Frames(id3Data) {
										var offset = 0;
										var frames = [];
										while (ID3.isHeader(id3Data, offset)) {
											var size = ID3._readSize(id3Data, offset + 6);
											offset += 10;
											var end = offset + size;
											while (offset + 8 < end) {
												var frameData = ID3._getFrameData(
													id3Data.subarray(offset)
												);
												var frame = ID3._decodeFrame(frameData);
												if (frame) {
													frames.push(frame);
												}
												offset += frameData.size + 10;
											}
											if (ID3.isFooter(id3Data, offset)) {
												offset += 10;
											}
										}
										return frames;
									};
									ID3._decodeFrame = function _decodeFrame(frame) {
										if (frame.type === "PRIV") {
											return ID3._decodePrivFrame(frame);
										} else if (frame.type[0] === "W") {
											return ID3._decodeURLFrame(frame);
										}
										return ID3._decodeTextFrame(frame);
									};
									ID3._readTimeStamp = function _readTimeStamp(timeStampFrame) {
										if (timeStampFrame.data.byteLength === 8) {
											var data = new Uint8Array(timeStampFrame.data);
											var pts33Bit = data[3] & 1;
											var timestamp =
												(data[4] << 23) +
												(data[5] << 15) +
												(data[6] << 7) +
												data[7];
											timestamp /= 45;
											if (pts33Bit) {
												timestamp += 47721858.84;
											}
											return Math.round(timestamp);
										}
										return undefined;
									};
									ID3._decodePrivFrame = function _decodePrivFrame(frame) {
										if (frame.size < 2) {
											return undefined;
										}
										var owner = ID3._utf8ArrayToStr(frame.data, true);
										var privateData = new Uint8Array(
											frame.data.subarray(owner.length + 1)
										);
										return {
											key: frame.type,
											info: owner,
											data: privateData.buffer,
										};
									};
									ID3._decodeTextFrame = function _decodeTextFrame(frame) {
										if (frame.size < 2) {
											return undefined;
										}
										if (frame.type === "TXXX") {
											var index = 1;
											var description = ID3._utf8ArrayToStr(
												frame.data.subarray(index),
												true
											);
											index += description.length + 1;
											var value = ID3._utf8ArrayToStr(
												frame.data.subarray(index)
											);
											return {
												key: frame.type,
												info: description,
												data: value,
											};
										} else {
											var text = ID3._utf8ArrayToStr(frame.data.subarray(1));
											return { key: frame.type, data: text };
										}
									};
									ID3._decodeURLFrame = function _decodeURLFrame(frame) {
										if (frame.type === "WXXX") {
											if (frame.size < 2) {
												return undefined;
											}
											var index = 1;
											var description = ID3._utf8ArrayToStr(
												frame.data.subarray(index),
												true
											);
											index += description.length + 1;
											var value = ID3._utf8ArrayToStr(
												frame.data.subarray(index)
											);
											return {
												key: frame.type,
												info: description,
												data: value,
											};
										} else {
											var url = ID3._utf8ArrayToStr(frame.data);
											return { key: frame.type, data: url };
										}
									};
									ID3._utf8ArrayToStr = function _utf8ArrayToStr(
										array,
										exitOnNull
									) {
										if (exitOnNull === void 0) {
											exitOnNull = false;
										}
										var decoder = getTextDecoder();
										if (decoder) {
											var decoded = decoder.decode(array);
											if (exitOnNull) {
												var idx = decoded.indexOf("\0");
												return idx !== -1 ? decoded.substring(0, idx) : decoded;
											}
											return decoded.replace(/\0/g, "");
										}
										var len = array.length;
										var c;
										var char2;
										var char3;
										var out = "";
										var i = 0;
										while (i < len) {
											c = array[i++];
											if (c === 0 && exitOnNull) {
												return out;
											} else if (c === 0 || c === 3) {
												continue;
											}
											switch (c >> 4) {
												case 0:
												case 1:
												case 2:
												case 3:
												case 4:
												case 5:
												case 6:
												case 7:
													out += String.fromCharCode(c);
													break;
												case 12:
												case 13:
													char2 = array[i++];
													out += String.fromCharCode(
														((c & 31) << 6) | (char2 & 63)
													);
													break;
												case 14:
													char2 = array[i++];
													char3 = array[i++];
													out += String.fromCharCode(
														((c & 15) << 12) |
															((char2 & 63) << 6) |
															((char3 & 63) << 0)
													);
													break;
												default:
											}
										}
										return out;
									};
									return ID3;
								})();
								var decoder;
								function getTextDecoder() {
									var global = Object(
										_utils_get_self_scope__WEBPACK_IMPORTED_MODULE_0__[
											"getSelfScope"
										]
									)();
									if (!decoder && typeof global.TextDecoder !== "undefined") {
										decoder = new global.TextDecoder("utf-8");
									}
									return decoder;
								}
								var utf8ArrayToStr = ID3._utf8ArrayToStr;
								__webpack_exports__["default"] = ID3;
							},
							"./src/demux/mp4demuxer.js": function (
								module,
								__webpack_exports__,
								__webpack_require__
							) {
								"use strict";
								__webpack_require__.r(__webpack_exports__);
								var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ =
									__webpack_require__("./src/utils/logger.js");
								var _events__WEBPACK_IMPORTED_MODULE_1__ =
									__webpack_require__("./src/events.js");
								var UINT32_MAX = Math.pow(2, 32) - 1;
								var MP4Demuxer = (function () {
									function MP4Demuxer(observer, remuxer) {
										this.observer = observer;
										this.remuxer = remuxer;
									}
									var _proto = MP4Demuxer.prototype;
									_proto.resetTimeStamp = function resetTimeStamp(initPTS) {
										this.initPTS = initPTS;
									};
									_proto.resetInitSegment = function resetInitSegment(
										initSegment,
										audioCodec,
										videoCodec,
										duration
									) {
										if (initSegment && initSegment.byteLength) {
											var initData = (this.initData =
												MP4Demuxer.parseInitSegment(initSegment));
											if (audioCodec == null) {
												audioCodec = "mp4a.40.5";
											}
											if (videoCodec == null) {
												videoCodec = "avc1.42e01e";
											}
											var tracks = {};
											if (initData.audio && initData.video) {
												tracks.audiovideo = {
													container: "video/mp4",
													codec: audioCodec + "," + videoCodec,
													initSegment: duration ? initSegment : null,
												};
											} else {
												if (initData.audio) {
													tracks.audio = {
														container: "audio/mp4",
														codec: audioCodec,
														initSegment: duration ? initSegment : null,
													};
												}
												if (initData.video) {
													tracks.video = {
														container: "video/mp4",
														codec: videoCodec,
														initSegment: duration ? initSegment : null,
													};
												}
											}
											this.observer.trigger(
												_events__WEBPACK_IMPORTED_MODULE_1__["default"]
													.FRAG_PARSING_INIT_SEGMENT,
												{ tracks: tracks }
											);
										} else {
											if (audioCodec) {
												this.audioCodec = audioCodec;
											}
											if (videoCodec) {
												this.videoCodec = videoCodec;
											}
										}
									};
									MP4Demuxer.probe = function probe(data) {
										return (
											MP4Demuxer.findBox(
												{
													data: data,
													start: 0,
													end: Math.min(data.length, 16384),
												},
												["moof"]
											).length > 0
										);
									};
									MP4Demuxer.bin2str = function bin2str(buffer) {
										return String.fromCharCode.apply(null, buffer);
									};
									MP4Demuxer.readUint16 = function readUint16(buffer, offset) {
										if (buffer.data) {
											offset += buffer.start;
											buffer = buffer.data;
										}
										var val = (buffer[offset] << 8) | buffer[offset + 1];
										return val < 0 ? 65536 + val : val;
									};
									MP4Demuxer.readUint32 = function readUint32(buffer, offset) {
										if (buffer.data) {
											offset += buffer.start;
											buffer = buffer.data;
										}
										var val =
											(buffer[offset] << 24) |
											(buffer[offset + 1] << 16) |
											(buffer[offset + 2] << 8) |
											buffer[offset + 3];
										return val < 0 ? 4294967296 + val : val;
									};
									MP4Demuxer.writeUint32 = function writeUint32(
										buffer,
										offset,
										value
									) {
										if (buffer.data) {
											offset += buffer.start;
											buffer = buffer.data;
										}
										buffer[offset] = value >> 24;
										buffer[offset + 1] = (value >> 16) & 255;
										buffer[offset + 2] = (value >> 8) & 255;
										buffer[offset + 3] = value & 255;
									};
									MP4Demuxer.findBox = function findBox(data, path) {
										var results = [],
											i,
											size,
											type,
											end,
											subresults,
											start,
											endbox;
										if (data.data) {
											start = data.start;
											end = data.end;
											data = data.data;
										} else {
											start = 0;
											end = data.byteLength;
										}
										if (!path.length) {
											return null;
										}
										for (i = start; i < end; ) {
											size = MP4Demuxer.readUint32(data, i);
											type = MP4Demuxer.bin2str(data.subarray(i + 4, i + 8));
											endbox = size > 1 ? i + size : end;
											if (type === path[0]) {
												if (path.length === 1) {
													results.push({
														data: data,
														start: i + 8,
														end: endbox,
													});
												} else {
													subresults = MP4Demuxer.findBox(
														{ data: data, start: i + 8, end: endbox },
														path.slice(1)
													);
													if (subresults.length) {
														results = results.concat(subresults);
													}
												}
											}
											i = endbox;
										}
										return results;
									};
									MP4Demuxer.parseSegmentIndex = function parseSegmentIndex(
										initSegment
									) {
										var moov = MP4Demuxer.findBox(initSegment, ["moov"])[0];
										var moovEndOffset = moov ? moov.end : null;
										var index = 0;
										var sidx = MP4Demuxer.findBox(initSegment, ["sidx"]);
										var references;
										if (!sidx || !sidx[0]) {
											return null;
										}
										references = [];
										sidx = sidx[0];
										var version = sidx.data[0];
										index = version === 0 ? 8 : 16;
										var timescale = MP4Demuxer.readUint32(sidx, index);
										index += 4;
										var earliestPresentationTime = 0;
										var firstOffset = 0;
										if (version === 0) {
											index += 8;
										} else {
											index += 16;
										}
										index += 2;
										var startByte = sidx.end + firstOffset;
										var referencesCount = MP4Demuxer.readUint16(sidx, index);
										index += 2;
										for (var i = 0; i < referencesCount; i++) {
											var referenceIndex = index;
											var referenceInfo = MP4Demuxer.readUint32(
												sidx,
												referenceIndex
											);
											referenceIndex += 4;
											var referenceSize = referenceInfo & 2147483647;
											var referenceType = (referenceInfo & 2147483648) >>> 31;
											if (referenceType === 1) {
												console.warn(
													"SIDX has hierarchical references (not supported)"
												);
												return;
											}
											var subsegmentDuration = MP4Demuxer.readUint32(
												sidx,
												referenceIndex
											);
											referenceIndex += 4;
											references.push({
												referenceSize: referenceSize,
												subsegmentDuration: subsegmentDuration,
												info: {
													duration: subsegmentDuration / timescale,
													start: startByte,
													end: startByte + referenceSize - 1,
												},
											});
											startByte += referenceSize;
											referenceIndex += 4;
											index = referenceIndex;
										}
										return {
											earliestPresentationTime: earliestPresentationTime,
											timescale: timescale,
											version: version,
											referencesCount: referencesCount,
											references: references,
											moovEndOffset: moovEndOffset,
										};
									};
									MP4Demuxer.parseInitSegment = function parseInitSegment(
										initSegment
									) {
										var result = [];
										var traks = MP4Demuxer.findBox(initSegment, [
											"moov",
											"trak",
										]);
										traks.forEach(function (trak) {
											var tkhd = MP4Demuxer.findBox(trak, ["tkhd"])[0];
											if (tkhd) {
												var version = tkhd.data[tkhd.start];
												var index = version === 0 ? 12 : 20;
												var trackId = MP4Demuxer.readUint32(tkhd, index);
												var mdhd = MP4Demuxer.findBox(trak, [
													"mdia",
													"mdhd",
												])[0];
												if (mdhd) {
													version = mdhd.data[mdhd.start];
													index = version === 0 ? 12 : 20;
													var timescale = MP4Demuxer.readUint32(mdhd, index);
													var hdlr = MP4Demuxer.findBox(trak, [
														"mdia",
														"hdlr",
													])[0];
													if (hdlr) {
														var hdlrType = MP4Demuxer.bin2str(
															hdlr.data.subarray(
																hdlr.start + 8,
																hdlr.start + 12
															)
														);
														var type = { soun: "audio", vide: "video" }[
															hdlrType
														];
														if (type) {
															var codecBox = MP4Demuxer.findBox(trak, [
																"mdia",
																"minf",
																"stbl",
																"stsd",
															]);
															if (codecBox.length) {
																codecBox = codecBox[0];
																var codecType = MP4Demuxer.bin2str(
																	codecBox.data.subarray(
																		codecBox.start + 12,
																		codecBox.start + 16
																	)
																);
																_utils_logger__WEBPACK_IMPORTED_MODULE_0__[
																	"logger"
																].log(
																	"MP4Demuxer:" +
																		type +
																		":" +
																		codecType +
																		" found"
																);
															}
															result[trackId] = {
																timescale: timescale,
																type: type,
															};
															result[type] = {
																timescale: timescale,
																id: trackId,
															};
														}
													}
												}
											}
										});
										return result;
									};
									MP4Demuxer.getStartDTS = function getStartDTS(
										initData,
										fragment
									) {
										var trafs, baseTimes, result;
										trafs = MP4Demuxer.findBox(fragment, ["moof", "traf"]);
										baseTimes = [].concat.apply(
											[],
											trafs.map(function (traf) {
												return MP4Demuxer.findBox(traf, ["tfhd"]).map(function (
													tfhd
												) {
													var id, scale, baseTime;
													id = MP4Demuxer.readUint32(tfhd, 4);
													scale = initData[id].timescale || 9e4;
													baseTime = MP4Demuxer.findBox(traf, ["tfdt"]).map(
														function (tfdt) {
															var version, result;
															version = tfdt.data[tfdt.start];
															result = MP4Demuxer.readUint32(tfdt, 4);
															if (version === 1) {
																result *= Math.pow(2, 32);
																result += MP4Demuxer.readUint32(tfdt, 8);
															}
															return result;
														}
													)[0];
													return baseTime / scale;
												});
											})
										);
										result = Math.min.apply(null, baseTimes);
										return isFinite(result) ? result : 0;
									};
									MP4Demuxer.offsetStartDTS = function offsetStartDTS(
										initData,
										fragment,
										timeOffset
									) {
										MP4Demuxer.findBox(fragment, ["moof", "traf"]).map(
											function (traf) {
												return MP4Demuxer.findBox(traf, ["tfhd"]).map(function (
													tfhd
												) {
													var id = MP4Demuxer.readUint32(tfhd, 4);
													var timescale = initData[id].timescale || 9e4;
													MP4Demuxer.findBox(traf, ["tfdt"]).map(function (
														tfdt
													) {
														var version = tfdt.data[tfdt.start];
														var baseMediaDecodeTime = MP4Demuxer.readUint32(
															tfdt,
															4
														);
														if (version === 0) {
															MP4Demuxer.writeUint32(
																tfdt,
																4,
																baseMediaDecodeTime - timeOffset * timescale
															);
														} else {
															baseMediaDecodeTime *= Math.pow(2, 32);
															baseMediaDecodeTime += MP4Demuxer.readUint32(
																tfdt,
																8
															);
															baseMediaDecodeTime -= timeOffset * timescale;
															baseMediaDecodeTime = Math.max(
																baseMediaDecodeTime,
																0
															);
															var upper = Math.floor(
																baseMediaDecodeTime / (UINT32_MAX + 1)
															);
															var lower = Math.floor(
																baseMediaDecodeTime % (UINT32_MAX + 1)
															);
															MP4Demuxer.writeUint32(tfdt, 4, upper);
															MP4Demuxer.writeUint32(tfdt, 8, lower);
														}
													});
												});
											}
										);
									};
									_proto.append = function append(
										data,
										timeOffset,
										contiguous,
										accurateTimeOffset
									) {
										var initData = this.initData;
										if (!initData) {
											this.resetInitSegment(
												data,
												this.audioCodec,
												this.videoCodec,
												false
											);
											initData = this.initData;
										}
										var startDTS,
											initPTS = this.initPTS;
										if (initPTS === undefined) {
											var _startDTS = MP4Demuxer.getStartDTS(initData, data);
											this.initPTS = initPTS = _startDTS - timeOffset;
											this.observer.trigger(
												_events__WEBPACK_IMPORTED_MODULE_1__["default"]
													.INIT_PTS_FOUND,
												{ initPTS: initPTS }
											);
										}
										MP4Demuxer.offsetStartDTS(initData, data, initPTS);
										startDTS = MP4Demuxer.getStartDTS(initData, data);
										this.remuxer.remux(
											initData.audio,
											initData.video,
											null,
											null,
											startDTS,
											contiguous,
											accurateTimeOffset,
											data
										);
									};
									_proto.destroy = function destroy() {};
									return MP4Demuxer;
								})();
								__webpack_exports__["default"] = MP4Demuxer;
							},
							"./src/errors.ts": function (
								module,
								__webpack_exports__,
								__webpack_require__
							) {
								"use strict";
								__webpack_require__.r(__webpack_exports__);
								__webpack_require__.d(
									__webpack_exports__,
									"ErrorTypes",
									function () {
										return ErrorTypes;
									}
								);
								__webpack_require__.d(
									__webpack_exports__,
									"ErrorDetails",
									function () {
										return ErrorDetails;
									}
								);
								var ErrorTypes;
								(function (ErrorTypes) {
									ErrorTypes["NETWORK_ERROR"] = "networkError";
									ErrorTypes["MEDIA_ERROR"] = "mediaError";
									ErrorTypes["KEY_SYSTEM_ERROR"] = "keySystemError";
									ErrorTypes["MUX_ERROR"] = "muxError";
									ErrorTypes["OTHER_ERROR"] = "otherError";
								})(ErrorTypes || (ErrorTypes = {}));
								var ErrorDetails;
								(function (ErrorDetails) {
									ErrorDetails["KEY_SYSTEM_NO_KEYS"] = "keySystemNoKeys";
									ErrorDetails["KEY_SYSTEM_NO_ACCESS"] = "keySystemNoAccess";
									ErrorDetails["KEY_SYSTEM_NO_SESSION"] = "keySystemNoSession";
									ErrorDetails["KEY_SYSTEM_LICENSE_REQUEST_FAILED"] =
										"keySystemLicenseRequestFailed";
									ErrorDetails["KEY_SYSTEM_NO_INIT_DATA"] =
										"keySystemNoInitData";
									ErrorDetails["MANIFEST_LOAD_ERROR"] = "manifestLoadError";
									ErrorDetails["MANIFEST_LOAD_TIMEOUT"] = "manifestLoadTimeOut";
									ErrorDetails["MANIFEST_PARSING_ERROR"] =
										"manifestParsingError";
									ErrorDetails["MANIFEST_INCOMPATIBLE_CODECS_ERROR"] =
										"manifestIncompatibleCodecsError";
									ErrorDetails["LEVEL_EMPTY_ERROR"] = "levelEmptyError";
									ErrorDetails["LEVEL_LOAD_ERROR"] = "levelLoadError";
									ErrorDetails["LEVEL_LOAD_TIMEOUT"] = "levelLoadTimeOut";
									ErrorDetails["LEVEL_SWITCH_ERROR"] = "levelSwitchError";
									ErrorDetails["AUDIO_TRACK_LOAD_ERROR"] =
										"audioTrackLoadError";
									ErrorDetails["AUDIO_TRACK_LOAD_TIMEOUT"] =
										"audioTrackLoadTimeOut";
									ErrorDetails["FRAG_LOAD_ERROR"] = "fragLoadError";
									ErrorDetails["FRAG_LOAD_TIMEOUT"] = "fragLoadTimeOut";
									ErrorDetails["FRAG_DECRYPT_ERROR"] = "fragDecryptError";
									ErrorDetails["FRAG_PARSING_ERROR"] = "fragParsingError";
									ErrorDetails["REMUX_ALLOC_ERROR"] = "remuxAllocError";
									ErrorDetails["KEY_LOAD_ERROR"] = "keyLoadError";
									ErrorDetails["KEY_LOAD_TIMEOUT"] = "keyLoadTimeOut";
									ErrorDetails["BUFFER_ADD_CODEC_ERROR"] =
										"bufferAddCodecError";
									ErrorDetails["BUFFER_APPEND_ERROR"] = "bufferAppendError";
									ErrorDetails["BUFFER_APPENDING_ERROR"] =
										"bufferAppendingError";
									ErrorDetails["BUFFER_STALLED_ERROR"] = "bufferStalledError";
									ErrorDetails["BUFFER_FULL_ERROR"] = "bufferFullError";
									ErrorDetails["BUFFER_SEEK_OVER_HOLE"] = "bufferSeekOverHole";
									ErrorDetails["BUFFER_NUDGE_ON_STALL"] = "bufferNudgeOnStall";
									ErrorDetails["INTERNAL_EXCEPTION"] = "internalException";
								})(ErrorDetails || (ErrorDetails = {}));
							},
							"./src/events.js": function (
								module,
								__webpack_exports__,
								__webpack_require__
							) {
								"use strict";
								__webpack_require__.r(__webpack_exports__);
								var HlsEvents = {
									MEDIA_ATTACHING: "hlsMediaAttaching",
									MEDIA_ATTACHED: "hlsMediaAttached",
									MEDIA_DETACHING: "hlsMediaDetaching",
									MEDIA_DETACHED: "hlsMediaDetached",
									BUFFER_RESET: "hlsBufferReset",
									BUFFER_CODECS: "hlsBufferCodecs",
									BUFFER_CREATED: "hlsBufferCreated",
									BUFFER_APPENDING: "hlsBufferAppending",
									BUFFER_APPENDED: "hlsBufferAppended",
									BUFFER_EOS: "hlsBufferEos",
									BUFFER_FLUSHING: "hlsBufferFlushing",
									BUFFER_FLUSHED: "hlsBufferFlushed",
									MANIFEST_LOADING: "hlsManifestLoading",
									MANIFEST_LOADED: "hlsManifestLoaded",
									MANIFEST_PARSED: "hlsManifestParsed",
									LEVEL_SWITCHING: "hlsLevelSwitching",
									LEVEL_SWITCHED: "hlsLevelSwitched",
									LEVEL_LOADING: "hlsLevelLoading",
									LEVEL_LOADED: "hlsLevelLoaded",
									LEVEL_UPDATED: "hlsLevelUpdated",
									LEVEL_PTS_UPDATED: "hlsLevelPtsUpdated",
									LEVELS_UPDATED: "hlsLevelsUpdated",
									AUDIO_TRACKS_UPDATED: "hlsAudioTracksUpdated",
									AUDIO_TRACK_SWITCHING: "hlsAudioTrackSwitching",
									AUDIO_TRACK_SWITCHED: "hlsAudioTrackSwitched",
									AUDIO_TRACK_LOADING: "hlsAudioTrackLoading",
									AUDIO_TRACK_LOADED: "hlsAudioTrackLoaded",
									SUBTITLE_TRACKS_UPDATED: "hlsSubtitleTracksUpdated",
									SUBTITLE_TRACK_SWITCH: "hlsSubtitleTrackSwitch",
									SUBTITLE_TRACK_LOADING: "hlsSubtitleTrackLoading",
									SUBTITLE_TRACK_LOADED: "hlsSubtitleTrackLoaded",
									SUBTITLE_FRAG_PROCESSED: "hlsSubtitleFragProcessed",
									CUES_PARSED: "hlsCuesParsed",
									NON_NATIVE_TEXT_TRACKS_FOUND: "hlsNonNativeTextTracksFound",
									INIT_PTS_FOUND: "hlsInitPtsFound",
									FRAG_LOADING: "hlsFragLoading",
									FRAG_LOAD_PROGRESS: "hlsFragLoadProgress",
									FRAG_LOAD_EMERGENCY_ABORTED: "hlsFragLoadEmergencyAborted",
									FRAG_LOADED: "hlsFragLoaded",
									FRAG_DECRYPTED: "hlsFragDecrypted",
									FRAG_PARSING_INIT_SEGMENT: "hlsFragParsingInitSegment",
									FRAG_PARSING_USERDATA: "hlsFragParsingUserdata",
									FRAG_PARSING_METADATA: "hlsFragParsingMetadata",
									FRAG_PARSING_DATA: "hlsFragParsingData",
									FRAG_PARSED: "hlsFragParsed",
									FRAG_BUFFERED: "hlsFragBuffered",
									FRAG_CHANGED: "hlsFragChanged",
									FPS_DROP: "hlsFpsDrop",
									FPS_DROP_LEVEL_CAPPING: "hlsFpsDropLevelCapping",
									ERROR: "hlsError",
									DESTROYING: "hlsDestroying",
									KEY_LOADING: "hlsKeyLoading",
									KEY_LOADED: "hlsKeyLoaded",
									STREAM_STATE_TRANSITION: "hlsStreamStateTransition",
									LIVE_BACK_BUFFER_REACHED: "hlsLiveBackBufferReached",
								};
								__webpack_exports__["default"] = HlsEvents;
							},
							"./src/hls.ts": function (
								module,
								__webpack_exports__,
								__webpack_require__
							) {
								"use strict";
								__webpack_require__.r(__webpack_exports__);
								__webpack_require__.d(
									__webpack_exports__,
									"default",
									function () {
										return hls_Hls;
									}
								);
								var cues_namespaceObject = {};
								__webpack_require__.r(cues_namespaceObject);
								__webpack_require__.d(
									cues_namespaceObject,
									"newCue",
									function () {
										return newCue;
									}
								);
								var url_toolkit = __webpack_require__(
									"./node_modules/url-toolkit/src/url-toolkit.js"
								);
								var errors = __webpack_require__("./src/errors.ts");
								var number = __webpack_require__("./src/polyfills/number.js");
								var events = __webpack_require__("./src/events.js");
								var logger = __webpack_require__("./src/utils/logger.js");
								var FORBIDDEN_EVENT_NAMES = {
									hlsEventGeneric: true,
									hlsHandlerDestroying: true,
									hlsHandlerDestroyed: true,
								};
								var event_handler_EventHandler = (function () {
									function EventHandler(hls) {
										this.hls = void 0;
										this.handledEvents = void 0;
										this.useGenericHandler = void 0;
										this.hls = hls;
										this.onEvent = this.onEvent.bind(this);
										for (
											var _len = arguments.length,
												events = new Array(_len > 1 ? _len - 1 : 0),
												_key = 1;
											_key < _len;
											_key++
										) {
											events[_key - 1] = arguments[_key];
										}
										this.handledEvents = events;
										this.useGenericHandler = true;
										this.registerListeners();
									}
									var _proto = EventHandler.prototype;
									_proto.destroy = function destroy() {
										this.onHandlerDestroying();
										this.unregisterListeners();
										this.onHandlerDestroyed();
									};
									_proto.onHandlerDestroying =
										function onHandlerDestroying() {};
									_proto.onHandlerDestroyed = function onHandlerDestroyed() {};
									_proto.isEventHandler = function isEventHandler() {
										return (
											typeof this.handledEvents === "object" &&
											this.handledEvents.length &&
											typeof this.onEvent === "function"
										);
									};
									_proto.registerListeners = function registerListeners() {
										if (this.isEventHandler()) {
											this.handledEvents.forEach(function (event) {
												if (FORBIDDEN_EVENT_NAMES[event]) {
													throw new Error("Forbidden event-name: " + event);
												}
												this.hls.on(event, this.onEvent);
											}, this);
										}
									};
									_proto.unregisterListeners = function unregisterListeners() {
										if (this.isEventHandler()) {
											this.handledEvents.forEach(function (event) {
												this.hls.off(event, this.onEvent);
											}, this);
										}
									};
									_proto.onEvent = function onEvent(event, data) {
										this.onEventGeneric(event, data);
									};
									_proto.onEventGeneric = function onEventGeneric(event, data) {
										var eventToFunction = function eventToFunction(
											event,
											data
										) {
											var funcName = "on" + event.replace("hls", "");
											if (typeof this[funcName] !== "function") {
												throw new Error(
													"Event " +
														event +
														" has no generic handler in this " +
														this.constructor.name +
														" class (tried " +
														funcName +
														")"
												);
											}
											return this[funcName].bind(this, data);
										};
										try {
											eventToFunction.call(this, event, data).call();
										} catch (err) {
											logger["logger"].error(
												"An internal error happened while handling event " +
													event +
													'. Error message: "' +
													err.message +
													'". Here is a stacktrace:',
												err
											);
											this.hls.trigger(events["default"].ERROR, {
												type: errors["ErrorTypes"].OTHER_ERROR,
												details: errors["ErrorDetails"].INTERNAL_EXCEPTION,
												fatal: false,
												event: event,
												err: err,
											});
										}
									};
									return EventHandler;
								})();
								var event_handler = event_handler_EventHandler;
								var PlaylistContextType;
								(function (PlaylistContextType) {
									PlaylistContextType["MANIFEST"] = "manifest";
									PlaylistContextType["LEVEL"] = "level";
									PlaylistContextType["AUDIO_TRACK"] = "audioTrack";
									PlaylistContextType["SUBTITLE_TRACK"] = "subtitleTrack";
								})(PlaylistContextType || (PlaylistContextType = {}));
								var PlaylistLevelType;
								(function (PlaylistLevelType) {
									PlaylistLevelType["MAIN"] = "main";
									PlaylistLevelType["AUDIO"] = "audio";
									PlaylistLevelType["SUBTITLE"] = "subtitle";
								})(PlaylistLevelType || (PlaylistLevelType = {}));
								var mp4demuxer = __webpack_require__(
									"./src/demux/mp4demuxer.js"
								);
								function _defineProperties(target, props) {
									for (var i = 0; i < props.length; i++) {
										var descriptor = props[i];
										descriptor.enumerable = descriptor.enumerable || false;
										descriptor.configurable = true;
										if ("value" in descriptor) descriptor.writable = true;
										Object.defineProperty(target, descriptor.key, descriptor);
									}
								}
								function _createClass(Constructor, protoProps, staticProps) {
									if (protoProps)
										_defineProperties(Constructor.prototype, protoProps);
									if (staticProps) _defineProperties(Constructor, staticProps);
									return Constructor;
								}
								var level_key_LevelKey = (function () {
									function LevelKey(baseURI, relativeURI) {
										this._uri = null;
										this.baseuri = void 0;
										this.reluri = void 0;
										this.method = null;
										this.key = null;
										this.iv = null;
										this.baseuri = baseURI;
										this.reluri = relativeURI;
									}
									_createClass(LevelKey, [
										{
											key: "uri",
											get: function get() {
												if (!this._uri && this.reluri) {
													this._uri = Object(url_toolkit["buildAbsoluteURL"])(
														this.baseuri,
														this.reluri,
														{ alwaysNormalize: true }
													);
												}
												return this._uri;
											},
										},
									]);
									return LevelKey;
								})();
								function fragment_defineProperties(target, props) {
									for (var i = 0; i < props.length; i++) {
										var descriptor = props[i];
										descriptor.enumerable = descriptor.enumerable || false;
										descriptor.configurable = true;
										if ("value" in descriptor) descriptor.writable = true;
										Object.defineProperty(target, descriptor.key, descriptor);
									}
								}
								function fragment_createClass(
									Constructor,
									protoProps,
									staticProps
								) {
									if (protoProps)
										fragment_defineProperties(
											Constructor.prototype,
											protoProps
										);
									if (staticProps)
										fragment_defineProperties(Constructor, staticProps);
									return Constructor;
								}
								var ElementaryStreamTypes;
								(function (ElementaryStreamTypes) {
									ElementaryStreamTypes["AUDIO"] = "audio";
									ElementaryStreamTypes["VIDEO"] = "video";
								})(ElementaryStreamTypes || (ElementaryStreamTypes = {}));
								var fragment_Fragment = (function () {
									function Fragment() {
										var _this$_elementaryStre;
										this._url = null;
										this._byteRange = null;
										this._decryptdata = null;
										this._elementaryStreams =
											((_this$_elementaryStre = {}),
											(_this$_elementaryStre[
												ElementaryStreamTypes.AUDIO
											] = false),
											(_this$_elementaryStre[
												ElementaryStreamTypes.VIDEO
											] = false),
											_this$_elementaryStre);
										this.deltaPTS = 0;
										this.rawProgramDateTime = null;
										this.programDateTime = null;
										this.title = null;
										this.tagList = [];
										this.cc = void 0;
										this.type = void 0;
										this.relurl = void 0;
										this.baseurl = void 0;
										this.duration = void 0;
										this.start = void 0;
										this.sn = 0;
										this.urlId = 0;
										this.level = 0;
										this.levelkey = void 0;
										this.loader = void 0;
									}
									var _proto = Fragment.prototype;
									_proto.setByteRange = function setByteRange(
										value,
										previousFrag
									) {
										var params = value.split("@", 2);
										var byteRange = [];
										if (params.length === 1) {
											byteRange[0] = previousFrag
												? previousFrag.byteRangeEndOffset
												: 0;
										} else {
											byteRange[0] = parseInt(params[1]);
										}
										byteRange[1] = parseInt(params[0]) + byteRange[0];
										this._byteRange = byteRange;
									};
									_proto.addElementaryStream = function addElementaryStream(
										type
									) {
										this._elementaryStreams[type] = true;
									};
									_proto.hasElementaryStream = function hasElementaryStream(
										type
									) {
										return this._elementaryStreams[type] === true;
									};
									_proto.createInitializationVector =
										function createInitializationVector(segmentNumber) {
											var uint8View = new Uint8Array(16);
											for (var i = 12; i < 16; i++) {
												uint8View[i] = (segmentNumber >> (8 * (15 - i))) & 255;
											}
											return uint8View;
										};
									_proto.setDecryptDataFromLevelKey =
										function setDecryptDataFromLevelKey(
											levelkey,
											segmentNumber
										) {
											var decryptdata = levelkey;
											if (
												(levelkey === null || levelkey === void 0
													? void 0
													: levelkey.method) &&
												levelkey.uri &&
												!levelkey.iv
											) {
												decryptdata = new level_key_LevelKey(
													levelkey.baseuri,
													levelkey.reluri
												);
												decryptdata.method = levelkey.method;
												decryptdata.iv =
													this.createInitializationVector(segmentNumber);
											}
											return decryptdata;
										};
									fragment_createClass(Fragment, [
										{
											key: "url",
											get: function get() {
												if (!this._url && this.relurl) {
													this._url = Object(url_toolkit["buildAbsoluteURL"])(
														this.baseurl,
														this.relurl,
														{ alwaysNormalize: true }
													);
												}
												return this._url;
											},
											set: function set(value) {
												this._url = value;
											},
										},
										{
											key: "byteRange",
											get: function get() {
												if (!this._byteRange) {
													return [];
												}
												return this._byteRange;
											},
										},
										{
											key: "byteRangeStartOffset",
											get: function get() {
												return this.byteRange[0];
											},
										},
										{
											key: "byteRangeEndOffset",
											get: function get() {
												return this.byteRange[1];
											},
										},
										{
											key: "decryptdata",
											get: function get() {
												if (!this.levelkey && !this._decryptdata) {
													return null;
												}
												if (!this._decryptdata && this.levelkey) {
													var sn = this.sn;
													if (typeof sn !== "number") {
														if (
															this.levelkey &&
															this.levelkey.method === "AES-128" &&
															!this.levelkey.iv
														) {
															logger["logger"].warn(
																'missing IV for initialization segment with method="' +
																	this.levelkey.method +
																	'" - compliance issue'
															);
														}
														sn = 0;
													}
													this._decryptdata = this.setDecryptDataFromLevelKey(
														this.levelkey,
														sn
													);
												}
												return this._decryptdata;
											},
										},
										{
											key: "endProgramDateTime",
											get: function get() {
												if (this.programDateTime === null) {
													return null;
												}
												if (
													!Object(number["isFiniteNumber"])(
														this.programDateTime
													)
												) {
													return null;
												}
												var duration = !Object(number["isFiniteNumber"])(
													this.duration
												)
													? 0
													: this.duration;
												return this.programDateTime + duration * 1e3;
											},
										},
										{
											key: "encrypted",
											get: function get() {
												return !!(
													this.decryptdata &&
													this.decryptdata.uri !== null &&
													this.decryptdata.key === null
												);
											},
										},
									]);
									return Fragment;
								})();
								function level_defineProperties(target, props) {
									for (var i = 0; i < props.length; i++) {
										var descriptor = props[i];
										descriptor.enumerable = descriptor.enumerable || false;
										descriptor.configurable = true;
										if ("value" in descriptor) descriptor.writable = true;
										Object.defineProperty(target, descriptor.key, descriptor);
									}
								}
								function level_createClass(
									Constructor,
									protoProps,
									staticProps
								) {
									if (protoProps)
										level_defineProperties(Constructor.prototype, protoProps);
									if (staticProps)
										level_defineProperties(Constructor, staticProps);
									return Constructor;
								}
								var level_Level = (function () {
									function Level(baseUrl) {
										this.endCC = 0;
										this.endSN = 0;
										this.fragments = [];
										this.initSegment = null;
										this.live = true;
										this.needSidxRanges = false;
										this.startCC = 0;
										this.startSN = 0;
										this.startTimeOffset = null;
										this.targetduration = 0;
										this.totalduration = 0;
										this.type = null;
										this.url = baseUrl;
										this.version = null;
									}
									level_createClass(Level, [
										{
											key: "hasProgramDateTime",
											get: function get() {
												return !!(
													this.fragments[0] &&
													Object(number["isFiniteNumber"])(
														this.fragments[0].programDateTime
													)
												);
											},
										},
									]);
									return Level;
								})();
								var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
								var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;
								var AttrList = (function () {
									function AttrList(attrs) {
										if (typeof attrs === "string") {
											attrs = AttrList.parseAttrList(attrs);
										}
										for (var attr in attrs) {
											if (attrs.hasOwnProperty(attr)) {
												this[attr] = attrs[attr];
											}
										}
									}
									var _proto = AttrList.prototype;
									_proto.decimalInteger = function decimalInteger(attrName) {
										var intValue = parseInt(this[attrName], 10);
										if (intValue > Number.MAX_SAFE_INTEGER) {
											return Infinity;
										}
										return intValue;
									};
									_proto.hexadecimalInteger = function hexadecimalInteger(
										attrName
									) {
										if (this[attrName]) {
											var stringValue = (this[attrName] || "0x").slice(2);
											stringValue =
												(stringValue.length & 1 ? "0" : "") + stringValue;
											var value = new Uint8Array(stringValue.length / 2);
											for (var i = 0; i < stringValue.length / 2; i++) {
												value[i] = parseInt(
													stringValue.slice(i * 2, i * 2 + 2),
													16
												);
											}
											return value;
										} else {
											return null;
										}
									};
									_proto.hexadecimalIntegerAsNumber =
										function hexadecimalIntegerAsNumber(attrName) {
											var intValue = parseInt(this[attrName], 16);
											if (intValue > Number.MAX_SAFE_INTEGER) {
												return Infinity;
											}
											return intValue;
										};
									_proto.decimalFloatingPoint = function decimalFloatingPoint(
										attrName
									) {
										return parseFloat(this[attrName]);
									};
									_proto.enumeratedString = function enumeratedString(
										attrName
									) {
										return this[attrName];
									};
									_proto.decimalResolution = function decimalResolution(
										attrName
									) {
										var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
										if (res === null) {
											return undefined;
										}
										return {
											width: parseInt(res[1], 10),
											height: parseInt(res[2], 10),
										};
									};
									AttrList.parseAttrList = function parseAttrList(input) {
										var match,
											attrs = {};
										ATTR_LIST_REGEX.lastIndex = 0;
										while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
											var value = match[2],
												quote = '"';
											if (
												value.indexOf(quote) === 0 &&
												value.lastIndexOf(quote) === value.length - 1
											) {
												value = value.slice(1, -1);
											}
											attrs[match[1]] = value;
										}
										return attrs;
									};
									return AttrList;
								})();
								var attr_list = AttrList;
								var sampleEntryCodesISO = {
									audio: {
										a3ds: true,
										"ac-3": true,
										"ac-4": true,
										alac: true,
										alaw: true,
										dra1: true,
										"dts+": true,
										"dts-": true,
										dtsc: true,
										dtse: true,
										dtsh: true,
										"ec-3": true,
										enca: true,
										g719: true,
										g726: true,
										m4ae: true,
										mha1: true,
										mha2: true,
										mhm1: true,
										mhm2: true,
										mlpa: true,
										mp4a: true,
										"raw ": true,
										Opus: true,
										samr: true,
										sawb: true,
										sawp: true,
										sevc: true,
										sqcp: true,
										ssmv: true,
										twos: true,
										ulaw: true,
									},
									video: {
										avc1: true,
										avc2: true,
										avc3: true,
										avc4: true,
										avcp: true,
										drac: true,
										dvav: true,
										dvhe: true,
										encv: true,
										hev1: true,
										hvc1: true,
										mjp2: true,
										mp4v: true,
										mvc1: true,
										mvc2: true,
										mvc3: true,
										mvc4: true,
										resv: true,
										rv60: true,
										s263: true,
										svc1: true,
										svc2: true,
										"vc-1": true,
										vp08: true,
										vp09: true,
									},
								};
								function isCodecType(codec, type) {
									var typeCodes = sampleEntryCodesISO[type];
									return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;
								}
								function isCodecSupportedInMp4(codec, type) {
									return MediaSource.isTypeSupported(
										(type || "video") + '/mp4;codecs="' + codec + '"'
									);
								}
								var MASTER_PLAYLIST_REGEX =
									/(?:#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)|#EXT-X-SESSION-DATA:([^\n\r]*)[\r\n]+)/g;
								var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
								var LEVEL_PLAYLIST_REGEX_FAST = new RegExp(
									[
										/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
										/|(?!#)([\S+ ?]+)/.source,
										/|#EXT-X-BYTERANGE:*(.+)/.source,
										/|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
										/|#.*/.source,
									].join(""),
									"g"
								);
								var LEVEL_PLAYLIST_REGEX_SLOW =
									/(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)([^:]*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;
								var MP4_REGEX_SUFFIX = /\.(mp4|m4s|m4v|m4a)$/i;
								var m3u8_parser_M3U8Parser = (function () {
									function M3U8Parser() {}
									M3U8Parser.findGroup = function findGroup(
										groups,
										mediaGroupId
									) {
										for (var i = 0; i < groups.length; i++) {
											var group = groups[i];
											if (group.id === mediaGroupId) {
												return group;
											}
										}
									};
									M3U8Parser.convertAVC1ToAVCOTI = function convertAVC1ToAVCOTI(
										codec
									) {
										var avcdata = codec.split(".");
										var result;
										if (avcdata.length > 2) {
											result = avcdata.shift() + ".";
											result += parseInt(avcdata.shift()).toString(16);
											result += (
												"000" + parseInt(avcdata.shift()).toString(16)
											).substr(-4);
										} else {
											result = codec;
										}
										return result;
									};
									M3U8Parser.resolve = function resolve(url, baseUrl) {
										return url_toolkit["buildAbsoluteURL"](baseUrl, url, {
											alwaysNormalize: true,
										});
									};
									M3U8Parser.parseMasterPlaylist = function parseMasterPlaylist(
										string,
										baseurl
									) {
										var levels = [];
										var sessionData = {};
										var hasSessionData = false;
										MASTER_PLAYLIST_REGEX.lastIndex = 0;
										function setCodecs(codecs, level) {
											["video", "audio"].forEach(function (type) {
												var filtered = codecs.filter(function (codec) {
													return isCodecType(codec, type);
												});
												if (filtered.length) {
													var preferred = filtered.filter(function (codec) {
														return (
															codec.lastIndexOf("avc1", 0) === 0 ||
															codec.lastIndexOf("mp4a", 0) === 0
														);
													});
													level[type + "Codec"] =
														preferred.length > 0 ? preferred[0] : filtered[0];
													codecs = codecs.filter(function (codec) {
														return filtered.indexOf(codec) === -1;
													});
												}
											});
											level.unknownCodecs = codecs;
										}
										var result;
										while (
											(result = MASTER_PLAYLIST_REGEX.exec(string)) != null
										) {
											if (result[1]) {
												var level = {};
												var attrs = (level.attrs = new attr_list(result[1]));
												level.url = M3U8Parser.resolve(result[2], baseurl);
												var resolution = attrs.decimalResolution("RESOLUTION");
												if (resolution) {
													level.width = resolution.width;
													level.height = resolution.height;
												}
												level.bitrate =
													attrs.decimalInteger("AVERAGE-BANDWIDTH") ||
													attrs.decimalInteger("BANDWIDTH");
												level.name = attrs.NAME;
												setCodecs(
													[].concat((attrs.CODECS || "").split(/[ ,]+/)),
													level
												);
												if (
													level.videoCodec &&
													level.videoCodec.indexOf("avc1") !== -1
												) {
													level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(
														level.videoCodec
													);
												}
												levels.push(level);
											} else if (result[3]) {
												var sessionAttrs = new attr_list(result[3]);
												if (sessionAttrs["DATA-ID"]) {
													hasSessionData = true;
													sessionData[sessionAttrs["DATA-ID"]] = sessionAttrs;
												}
											}
										}
										return {
											levels: levels,
											sessionData: hasSessionData ? sessionData : null,
										};
									};
									M3U8Parser.parseMasterPlaylistMedia =
										function parseMasterPlaylistMedia(
											string,
											baseurl,
											type,
											audioGroups
										) {
											if (audioGroups === void 0) {
												audioGroups = [];
											}
											var result;
											var medias = [];
											var id = 0;
											MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
											while (
												(result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !==
												null
											) {
												var attrs = new attr_list(result[1]);
												if (attrs.TYPE === type) {
													var media = {
														attrs: attrs,
														id: id++,
														groupId: attrs["GROUP-ID"],
														instreamId: attrs["INSTREAM-ID"],
														name: attrs.NAME || attrs.LANGUAGE,
														type: type,
														default: attrs.DEFAULT === "YES",
														autoselect: attrs.AUTOSELECT === "YES",
														forced: attrs.FORCED === "YES",
														lang: attrs.LANGUAGE,
													};
													if (attrs.URI) {
														media.url = M3U8Parser.resolve(attrs.URI, baseurl);
													}
													if (audioGroups.length) {
														var groupCodec = M3U8Parser.findGroup(
															audioGroups,
															media.groupId
														);
														media.audioCodec = groupCodec
															? groupCodec.codec
															: audioGroups[0].codec;
													}
													medias.push(media);
												}
											}
											return medias;
										};
									M3U8Parser.parseLevelPlaylist = function parseLevelPlaylist(
										string,
										baseurl,
										id,
										type,
										levelUrlId
									) {
										var currentSN = 0;
										var totalduration = 0;
										var level = new level_Level(baseurl);
										var discontinuityCounter = 0;
										var prevFrag = null;
										var frag = new fragment_Fragment();
										var result;
										var i;
										var levelkey;
										var firstPdtIndex = null;
										LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
										while (
											(result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null
										) {
											var duration = result[1];
											if (duration) {
												frag.duration = parseFloat(duration);
												var title = (" " + result[2]).slice(1);
												frag.title = title || null;
												frag.tagList.push(
													title ? ["INF", duration, title] : ["INF", duration]
												);
											} else if (result[3]) {
												if (Object(number["isFiniteNumber"])(frag.duration)) {
													var sn = currentSN++;
													frag.type = type;
													frag.start = totalduration;
													if (levelkey) {
														frag.levelkey = levelkey;
													}
													frag.sn = sn;
													frag.level = id;
													frag.cc = discontinuityCounter;
													frag.urlId = levelUrlId;
													frag.baseurl = baseurl;
													frag.relurl = (" " + result[3]).slice(1);
													assignProgramDateTime(frag, prevFrag);
													level.fragments.push(frag);
													prevFrag = frag;
													totalduration += frag.duration;
													frag = new fragment_Fragment();
												}
											} else if (result[4]) {
												var data = (" " + result[4]).slice(1);
												if (prevFrag) {
													frag.setByteRange(data, prevFrag);
												} else {
													frag.setByteRange(data);
												}
											} else if (result[5]) {
												frag.rawProgramDateTime = (" " + result[5]).slice(1);
												frag.tagList.push([
													"PROGRAM-DATE-TIME",
													frag.rawProgramDateTime,
												]);
												if (firstPdtIndex === null) {
													firstPdtIndex = level.fragments.length;
												}
											} else {
												result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
												if (!result) {
													logger["logger"].warn(
														"No matches on slow regex match for level playlist!"
													);
													continue;
												}
												for (i = 1; i < result.length; i++) {
													if (typeof result[i] !== "undefined") {
														break;
													}
												}
												var value1 = (" " + result[i + 1]).slice(1);
												var value2 = (" " + result[i + 2]).slice(1);
												switch (result[i]) {
													case "#":
														frag.tagList.push(
															value2 ? [value1, value2] : [value1]
														);
														break;
													case "PLAYLIST-TYPE":
														level.type = value1.toUpperCase();
														break;
													case "MEDIA-SEQUENCE":
														currentSN = level.startSN = parseInt(value1);
														break;
													case "TARGETDURATION":
														level.targetduration = parseFloat(value1);
														break;
													case "VERSION":
														level.version = parseInt(value1);
														break;
													case "EXTM3U":
														break;
													case "ENDLIST":
														level.live = false;
														break;
													case "DIS":
														discontinuityCounter++;
														frag.tagList.push(["DIS"]);
														break;
													case "DISCONTINUITY-SEQ":
														discontinuityCounter = parseInt(value1);
														break;
													case "KEY": {
														var decryptparams = value1;
														var keyAttrs = new attr_list(decryptparams);
														var decryptmethod =
															keyAttrs.enumeratedString("METHOD");
														var decrypturi = keyAttrs.URI;
														var decryptiv = keyAttrs.hexadecimalInteger("IV");
														var decryptkeyformat =
															keyAttrs.KEYFORMAT || "identity";
														if (
															decryptkeyformat ===
															"com.apple.streamingkeydelivery"
														) {
															logger["logger"].warn(
																"Keyformat com.apple.streamingkeydelivery is not supported"
															);
															continue;
														}
														if (decryptmethod) {
															levelkey = new level_key_LevelKey(
																baseurl,
																decrypturi
															);
															if (
																decrypturi &&
																[
																	"AES-128",
																	"SAMPLE-AES",
																	"SAMPLE-AES-CENC",
																].indexOf(decryptmethod) >= 0
															) {
																levelkey.method = decryptmethod;
																levelkey.key = null;
																levelkey.iv = decryptiv;
															}
														}
														break;
													}
													case "START": {
														var startAttrs = new attr_list(value1);
														var startTimeOffset =
															startAttrs.decimalFloatingPoint("TIME-OFFSET");
														if (
															Object(number["isFiniteNumber"])(startTimeOffset)
														) {
															level.startTimeOffset = startTimeOffset;
														}
														break;
													}
													case "MAP": {
														var mapAttrs = new attr_list(value1);
														frag.relurl = mapAttrs.URI;
														if (mapAttrs.BYTERANGE) {
															frag.setByteRange(mapAttrs.BYTERANGE);
														}
														frag.baseurl = baseurl;
														frag.level = id;
														frag.type = type;
														frag.sn = "initSegment";
														level.initSegment = frag;
														frag = new fragment_Fragment();
														frag.rawProgramDateTime =
															level.initSegment.rawProgramDateTime;
														break;
													}
													default:
														logger["logger"].warn(
															"line parsed but not handled: " + result
														);
														break;
												}
											}
										}
										frag = prevFrag;
										if (frag && !frag.relurl) {
											level.fragments.pop();
											totalduration -= frag.duration;
										}
										level.totalduration = totalduration;
										level.averagetargetduration =
											totalduration / level.fragments.length;
										level.endSN = currentSN - 1;
										level.startCC = level.fragments[0]
											? level.fragments[0].cc
											: 0;
										level.endCC = discontinuityCounter;
										if (!level.initSegment && level.fragments.length) {
											if (
												level.fragments.every(function (frag) {
													return MP4_REGEX_SUFFIX.test(frag.relurl);
												})
											) {
												logger["logger"].warn(
													"MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX"
												);
												frag = new fragment_Fragment();
												frag.relurl = level.fragments[0].relurl;
												frag.baseurl = baseurl;
												frag.level = id;
												frag.type = type;
												frag.sn = "initSegment";
												level.initSegment = frag;
												level.needSidxRanges = true;
											}
										}
										if (firstPdtIndex) {
											backfillProgramDateTimes(level.fragments, firstPdtIndex);
										}
										return level;
									};
									return M3U8Parser;
								})();
								function backfillProgramDateTimes(fragments, startIndex) {
									var fragPrev = fragments[startIndex];
									for (var i = startIndex - 1; i >= 0; i--) {
										var frag = fragments[i];
										frag.programDateTime =
											fragPrev.programDateTime - frag.duration * 1e3;
										fragPrev = frag;
									}
								}
								function assignProgramDateTime(frag, prevFrag) {
									if (frag.rawProgramDateTime) {
										frag.programDateTime = Date.parse(frag.rawProgramDateTime);
									} else if (
										prevFrag === null || prevFrag === void 0
											? void 0
											: prevFrag.programDateTime
									) {
										frag.programDateTime = prevFrag.endProgramDateTime;
									}
									if (!Object(number["isFiniteNumber"])(frag.programDateTime)) {
										frag.programDateTime = null;
										frag.rawProgramDateTime = null;
									}
								}
								function _inheritsLoose(subClass, superClass) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var _window = window,
									performance = _window.performance;
								var playlist_loader_PlaylistLoader = (function (_EventHandler) {
									_inheritsLoose(PlaylistLoader, _EventHandler);
									function PlaylistLoader(hls) {
										var _this;
										_this =
											_EventHandler.call(
												this,
												hls,
												events["default"].MANIFEST_LOADING,
												events["default"].LEVEL_LOADING,
												events["default"].AUDIO_TRACK_LOADING,
												events["default"].SUBTITLE_TRACK_LOADING
											) || this;
										_this.loaders = {};
										return _this;
									}
									PlaylistLoader.canHaveQualityLevels =
										function canHaveQualityLevels(type) {
											return (
												type !== PlaylistContextType.AUDIO_TRACK &&
												type !== PlaylistContextType.SUBTITLE_TRACK
											);
										};
									PlaylistLoader.mapContextToLevelType =
										function mapContextToLevelType(context) {
											var type = context.type;
											switch (type) {
												case PlaylistContextType.AUDIO_TRACK:
													return PlaylistLevelType.AUDIO;
												case PlaylistContextType.SUBTITLE_TRACK:
													return PlaylistLevelType.SUBTITLE;
												default:
													return PlaylistLevelType.MAIN;
											}
										};
									PlaylistLoader.getResponseUrl = function getResponseUrl(
										response,
										context
									) {
										var url = response.url;
										if (url === undefined || url.indexOf("data:") === 0) {
											url = context.url;
										}
										return url;
									};
									var _proto = PlaylistLoader.prototype;
									_proto.createInternalLoader = function createInternalLoader(
										context
									) {
										var config = this.hls.config;
										var PLoader = config.pLoader;
										var Loader = config.loader;
										var InternalLoader = PLoader || Loader;
										var loader = new InternalLoader(config);
										context.loader = loader;
										this.loaders[context.type] = loader;
										return loader;
									};
									_proto.getInternalLoader = function getInternalLoader(
										context
									) {
										return this.loaders[context.type];
									};
									_proto.resetInternalLoader = function resetInternalLoader(
										contextType
									) {
										if (this.loaders[contextType]) {
											delete this.loaders[contextType];
										}
									};
									_proto.destroyInternalLoaders =
										function destroyInternalLoaders() {
											for (var contextType in this.loaders) {
												var loader = this.loaders[contextType];
												if (loader) {
													loader.destroy();
												}
												this.resetInternalLoader(contextType);
											}
										};
									_proto.destroy = function destroy() {
										this.destroyInternalLoaders();
										_EventHandler.prototype.destroy.call(this);
									};
									_proto.onManifestLoading = function onManifestLoading(data) {
										this.load({
											url: data.url,
											type: PlaylistContextType.MANIFEST,
											level: 0,
											id: null,
											responseType: "text",
										});
									};
									_proto.onLevelLoading = function onLevelLoading(data) {
										this.load({
											url: data.url,
											type: PlaylistContextType.LEVEL,
											level: data.level,
											id: data.id,
											responseType: "text",
										});
									};
									_proto.onAudioTrackLoading = function onAudioTrackLoading(
										data
									) {
										this.load({
											url: data.url,
											type: PlaylistContextType.AUDIO_TRACK,
											level: null,
											id: data.id,
											responseType: "text",
										});
									};
									_proto.onSubtitleTrackLoading =
										function onSubtitleTrackLoading(data) {
											this.load({
												url: data.url,
												type: PlaylistContextType.SUBTITLE_TRACK,
												level: null,
												id: data.id,
												responseType: "text",
											});
										};
									_proto.load = function load(context) {
										var config = this.hls.config;
										logger["logger"].debug(
											"Loading playlist of type " +
												context.type +
												", level: " +
												context.level +
												", id: " +
												context.id
										);
										var loader = this.getInternalLoader(context);
										if (loader) {
											var loaderContext = loader.context;
											if (loaderContext && loaderContext.url === context.url) {
												logger["logger"].trace("playlist request ongoing");
												return false;
											} else {
												logger["logger"].warn(
													"aborting previous loader for type: " + context.type
												);
												loader.abort();
											}
										}
										var maxRetry;
										var timeout;
										var retryDelay;
										var maxRetryDelay;
										switch (context.type) {
											case PlaylistContextType.MANIFEST:
												maxRetry = config.manifestLoadingMaxRetry;
												timeout = config.manifestLoadingTimeOut;
												retryDelay = config.manifestLoadingRetryDelay;
												maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
												break;
											case PlaylistContextType.LEVEL:
												maxRetry = 0;
												maxRetryDelay = 0;
												retryDelay = 0;
												timeout = config.levelLoadingTimeOut;
												break;
											default:
												maxRetry = config.levelLoadingMaxRetry;
												timeout = config.levelLoadingTimeOut;
												retryDelay = config.levelLoadingRetryDelay;
												maxRetryDelay = config.levelLoadingMaxRetryTimeout;
												break;
										}
										loader = this.createInternalLoader(context);
										var loaderConfig = {
											timeout: timeout,
											maxRetry: maxRetry,
											retryDelay: retryDelay,
											maxRetryDelay: maxRetryDelay,
										};
										var loaderCallbacks = {
											onSuccess: this.loadsuccess.bind(this),
											onError: this.loaderror.bind(this),
											onTimeout: this.loadtimeout.bind(this),
										};
										logger["logger"].debug(
											"Calling internal loader delegate for URL: " + context.url
										);
										loader.load(context, loaderConfig, loaderCallbacks);
										return true;
									};
									_proto.loadsuccess = function loadsuccess(
										response,
										stats,
										context,
										networkDetails
									) {
										if (networkDetails === void 0) {
											networkDetails = null;
										}
										if (context.isSidxRequest) {
											this._handleSidxRequest(response, context);
											this._handlePlaylistLoaded(
												response,
												stats,
												context,
												networkDetails
											);
											return;
										}
										this.resetInternalLoader(context.type);
										if (typeof response.data !== "string") {
											throw new Error(
												'expected responseType of "text" for PlaylistLoader'
											);
										}
										var string = response.data;
										stats.tload = performance.now();
										if (string.indexOf("#EXTM3U") !== 0) {
											this._handleManifestParsingError(
												response,
												context,
												"no EXTM3U delimiter",
												networkDetails
											);
											return;
										}
										if (
											string.indexOf("#EXTINF:") > 0 ||
											string.indexOf("#EXT-X-TARGETDURATION:") > 0
										) {
											this._handleTrackOrLevelPlaylist(
												response,
												stats,
												context,
												networkDetails
											);
										} else {
											this._handleMasterPlaylist(
												response,
												stats,
												context,
												networkDetails
											);
										}
									};
									_proto.loaderror = function loaderror(
										response,
										context,
										networkDetails
									) {
										if (networkDetails === void 0) {
											networkDetails = null;
										}
										this._handleNetworkError(
											context,
											networkDetails,
											false,
											response
										);
									};
									_proto.loadtimeout = function loadtimeout(
										stats,
										context,
										networkDetails
									) {
										if (networkDetails === void 0) {
											networkDetails = null;
										}
										this._handleNetworkError(context, networkDetails, true);
									};
									_proto._handleMasterPlaylist = function _handleMasterPlaylist(
										response,
										stats,
										context,
										networkDetails
									) {
										var hls = this.hls;
										var string = response.data;
										var url = PlaylistLoader.getResponseUrl(response, context);
										var _M3U8Parser$parseMast =
												m3u8_parser_M3U8Parser.parseMasterPlaylist(string, url),
											levels = _M3U8Parser$parseMast.levels,
											sessionData = _M3U8Parser$parseMast.sessionData;
										if (!levels.length) {
											this._handleManifestParsingError(
												response,
												context,
												"no level found in manifest",
												networkDetails
											);
											return;
										}
										var audioGroups = levels.map(function (level) {
											return { id: level.attrs.AUDIO, codec: level.audioCodec };
										});
										var audioTracks =
											m3u8_parser_M3U8Parser.parseMasterPlaylistMedia(
												string,
												url,
												"AUDIO",
												audioGroups
											);
										var subtitles =
											m3u8_parser_M3U8Parser.parseMasterPlaylistMedia(
												string,
												url,
												"SUBTITLES"
											);
										var captions =
											m3u8_parser_M3U8Parser.parseMasterPlaylistMedia(
												string,
												url,
												"CLOSED-CAPTIONS"
											);
										if (audioTracks.length) {
											var embeddedAudioFound = false;
											audioTracks.forEach(function (audioTrack) {
												if (!audioTrack.url) {
													embeddedAudioFound = true;
												}
											});
											if (
												embeddedAudioFound === false &&
												levels[0].audioCodec &&
												!levels[0].attrs.AUDIO
											) {
												logger["logger"].log(
													"audio codec signaled in quality level, but no embedded audio track signaled, create one"
												);
												audioTracks.unshift({
													type: "main",
													name: "main",
													default: false,
													autoselect: false,
													forced: false,
													id: -1,
													attrs: {},
													url: "",
												});
											}
										}
										hls.trigger(events["default"].MANIFEST_LOADED, {
											levels: levels,
											audioTracks: audioTracks,
											subtitles: subtitles,
											captions: captions,
											url: url,
											stats: stats,
											networkDetails: networkDetails,
											sessionData: sessionData,
										});
									};
									_proto._handleTrackOrLevelPlaylist =
										function _handleTrackOrLevelPlaylist(
											response,
											stats,
											context,
											networkDetails
										) {
											var hls = this.hls;
											var id = context.id,
												level = context.level,
												type = context.type;
											var url = PlaylistLoader.getResponseUrl(
												response,
												context
											);
											var levelUrlId = Object(number["isFiniteNumber"])(id)
												? id
												: 0;
											var levelId = Object(number["isFiniteNumber"])(level)
												? level
												: levelUrlId;
											var levelType =
												PlaylistLoader.mapContextToLevelType(context);
											var levelDetails =
												m3u8_parser_M3U8Parser.parseLevelPlaylist(
													response.data,
													url,
													levelId,
													levelType,
													levelUrlId
												);
											levelDetails.tload = stats.tload;
											if (!levelDetails.fragments.length) {
												hls.trigger(events["default"].ERROR, {
													type: errors["ErrorTypes"].NETWORK_ERROR,
													details: errors["ErrorDetails"].LEVEL_EMPTY_ERROR,
													fatal: false,
													url: url,
													reason: "no fragments found in level",
													level:
														typeof context.level === "number"
															? context.level
															: undefined,
												});
												return;
											}
											if (type === PlaylistContextType.MANIFEST) {
												var singleLevel = { url: url, details: levelDetails };
												hls.trigger(events["default"].MANIFEST_LOADED, {
													levels: [singleLevel],
													audioTracks: [],
													url: url,
													stats: stats,
													networkDetails: networkDetails,
													sessionData: null,
												});
											}
											stats.tparsed = performance.now();
											if (levelDetails.needSidxRanges) {
												var sidxUrl = levelDetails.initSegment.url;
												this.load({
													url: sidxUrl,
													isSidxRequest: true,
													type: type,
													level: level,
													levelDetails: levelDetails,
													id: id,
													rangeStart: 0,
													rangeEnd: 2048,
													responseType: "arraybuffer",
												});
												return;
											}
											context.levelDetails = levelDetails;
											this._handlePlaylistLoaded(
												response,
												stats,
												context,
												networkDetails
											);
										};
									_proto._handleSidxRequest = function _handleSidxRequest(
										response,
										context
									) {
										if (typeof response.data === "string") {
											throw new Error(
												"sidx request must be made with responseType of array buffer"
											);
										}
										var sidxInfo = mp4demuxer["default"].parseSegmentIndex(
											new Uint8Array(response.data)
										);
										if (!sidxInfo) {
											return;
										}
										var sidxReferences = sidxInfo.references;
										var levelDetails = context.levelDetails;
										sidxReferences.forEach(function (segmentRef, index) {
											var segRefInfo = segmentRef.info;
											if (!levelDetails) {
												return;
											}
											var frag = levelDetails.fragments[index];
											if (frag.byteRange.length === 0) {
												frag.setByteRange(
													String(1 + segRefInfo.end - segRefInfo.start) +
														"@" +
														String(segRefInfo.start)
												);
											}
										});
										if (levelDetails) {
											levelDetails.initSegment.setByteRange(
												String(sidxInfo.moovEndOffset) + "@0"
											);
										}
									};
									_proto._handleManifestParsingError =
										function _handleManifestParsingError(
											response,
											context,
											reason,
											networkDetails
										) {
											this.hls.trigger(events["default"].ERROR, {
												type: errors["ErrorTypes"].NETWORK_ERROR,
												details: errors["ErrorDetails"].MANIFEST_PARSING_ERROR,
												fatal: true,
												url: response.url,
												reason: reason,
												networkDetails: networkDetails,
											});
										};
									_proto._handleNetworkError = function _handleNetworkError(
										context,
										networkDetails,
										timeout,
										response
									) {
										if (timeout === void 0) {
											timeout = false;
										}
										if (response === void 0) {
											response = null;
										}
										logger["logger"].info(
											"A network error occured while loading a " +
												context.type +
												"-type playlist"
										);
										var details;
										var fatal;
										var loader = this.getInternalLoader(context);
										switch (context.type) {
											case PlaylistContextType.MANIFEST:
												details = timeout
													? errors["ErrorDetails"].MANIFEST_LOAD_TIMEOUT
													: errors["ErrorDetails"].MANIFEST_LOAD_ERROR;
												fatal = true;
												break;
											case PlaylistContextType.LEVEL:
												details = timeout
													? errors["ErrorDetails"].LEVEL_LOAD_TIMEOUT
													: errors["ErrorDetails"].LEVEL_LOAD_ERROR;
												fatal = false;
												break;
											case PlaylistContextType.AUDIO_TRACK:
												details = timeout
													? errors["ErrorDetails"].AUDIO_TRACK_LOAD_TIMEOUT
													: errors["ErrorDetails"].AUDIO_TRACK_LOAD_ERROR;
												fatal = false;
												break;
											default:
												fatal = false;
										}
										if (loader) {
											loader.abort();
											this.resetInternalLoader(context.type);
										}
										var errorData = {
											type: errors["ErrorTypes"].NETWORK_ERROR,
											details: details,
											fatal: fatal,
											url: context.url,
											loader: loader,
											context: context,
											networkDetails: networkDetails,
										};
										if (response) {
											errorData.response = response;
										}
										this.hls.trigger(events["default"].ERROR, errorData);
									};
									_proto._handlePlaylistLoaded = function _handlePlaylistLoaded(
										response,
										stats,
										context,
										networkDetails
									) {
										var type = context.type,
											level = context.level,
											id = context.id,
											levelDetails = context.levelDetails;
										if (!levelDetails || !levelDetails.targetduration) {
											this._handleManifestParsingError(
												response,
												context,
												"invalid target duration",
												networkDetails
											);
											return;
										}
										var canHaveLevels = PlaylistLoader.canHaveQualityLevels(
											context.type
										);
										if (canHaveLevels) {
											this.hls.trigger(events["default"].LEVEL_LOADED, {
												details: levelDetails,
												level: level || 0,
												id: id || 0,
												stats: stats,
												networkDetails: networkDetails,
											});
										} else {
											switch (type) {
												case PlaylistContextType.AUDIO_TRACK:
													this.hls.trigger(
														events["default"].AUDIO_TRACK_LOADED,
														{
															details: levelDetails,
															id: id,
															stats: stats,
															networkDetails: networkDetails,
														}
													);
													break;
												case PlaylistContextType.SUBTITLE_TRACK:
													this.hls.trigger(
														events["default"].SUBTITLE_TRACK_LOADED,
														{
															details: levelDetails,
															id: id,
															stats: stats,
															networkDetails: networkDetails,
														}
													);
													break;
											}
										}
									};
									return PlaylistLoader;
								})(event_handler);
								var playlist_loader = playlist_loader_PlaylistLoader;
								function fragment_loader_inheritsLoose(subClass, superClass) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var fragment_loader_FragmentLoader = (function (_EventHandler) {
									fragment_loader_inheritsLoose(FragmentLoader, _EventHandler);
									function FragmentLoader(hls) {
										var _this;
										_this =
											_EventHandler.call(
												this,
												hls,
												events["default"].FRAG_LOADING
											) || this;
										_this.loaders = {};
										return _this;
									}
									var _proto = FragmentLoader.prototype;
									_proto.destroy = function destroy() {
										var loaders = this.loaders;
										for (var loaderName in loaders) {
											var loader = loaders[loaderName];
											if (loader) {
												loader.destroy();
											}
										}
										this.loaders = {};
										_EventHandler.prototype.destroy.call(this);
									};
									_proto.onFragLoading = function onFragLoading(data) {
										var frag = data.frag,
											type = frag.type,
											loaders = this.loaders,
											config = this.hls.config,
											FragmentILoader = config.fLoader,
											DefaultILoader = config.loader;
										frag.loaded = 0;
										var loader = loaders[type];
										if (loader) {
											logger["logger"].warn(
												"abort previous fragment loader for type: " + type
											);
											loader.abort();
										}
										loader =
											loaders[type] =
											frag.loader =
												config.fLoader
													? new FragmentILoader(config)
													: new DefaultILoader(config);
										var loaderContext, loaderConfig, loaderCallbacks;
										loaderContext = {
											url: frag.url,
											frag: frag,
											responseType: "arraybuffer",
											progressData: false,
										};
										var start = frag.byteRangeStartOffset,
											end = frag.byteRangeEndOffset;
										if (
											Object(number["isFiniteNumber"])(start) &&
											Object(number["isFiniteNumber"])(end)
										) {
											loaderContext.rangeStart = start;
											loaderContext.rangeEnd = end;
										}
										loaderConfig = {
											timeout: config.fragLoadingTimeOut,
											maxRetry: 0,
											retryDelay: 0,
											maxRetryDelay: config.fragLoadingMaxRetryTimeout,
										};
										loaderCallbacks = {
											onSuccess: this.loadsuccess.bind(this),
											onError: this.loaderror.bind(this),
											onTimeout: this.loadtimeout.bind(this),
											onProgress: this.loadprogress.bind(this),
										};
										loader.load(loaderContext, loaderConfig, loaderCallbacks);
									};
									_proto.loadsuccess = function loadsuccess(
										response,
										stats,
										context,
										networkDetails
									) {
										if (networkDetails === void 0) {
											networkDetails = null;
										}
										var payload = response.data,
											frag = context.frag;
										frag.loader = undefined;
										this.loaders[frag.type] = undefined;
										this.hls.trigger(events["default"].FRAG_LOADED, {
											payload: payload,
											frag: frag,
											stats: stats,
											networkDetails: networkDetails,
										});
									};
									_proto.loaderror = function loaderror(
										response,
										context,
										networkDetails
									) {
										if (networkDetails === void 0) {
											networkDetails = null;
										}
										var frag = context.frag;
										var loader = frag.loader;
										if (loader) {
											loader.abort();
										}
										this.loaders[frag.type] = undefined;
										this.hls.trigger(events["default"].ERROR, {
											type: errors["ErrorTypes"].NETWORK_ERROR,
											details: errors["ErrorDetails"].FRAG_LOAD_ERROR,
											fatal: false,
											frag: context.frag,
											response: response,
											networkDetails: networkDetails,
										});
									};
									_proto.loadtimeout = function loadtimeout(
										stats,
										context,
										networkDetails
									) {
										if (networkDetails === void 0) {
											networkDetails = null;
										}
										var frag = context.frag;
										var loader = frag.loader;
										if (loader) {
											loader.abort();
										}
										this.loaders[frag.type] = undefined;
										this.hls.trigger(events["default"].ERROR, {
											type: errors["ErrorTypes"].NETWORK_ERROR,
											details: errors["ErrorDetails"].FRAG_LOAD_TIMEOUT,
											fatal: false,
											frag: context.frag,
											networkDetails: networkDetails,
										});
									};
									_proto.loadprogress = function loadprogress(
										stats,
										context,
										data,
										networkDetails
									) {
										if (networkDetails === void 0) {
											networkDetails = null;
										}
										var frag = context.frag;
										frag.loaded = stats.loaded;
										this.hls.trigger(events["default"].FRAG_LOAD_PROGRESS, {
											frag: frag,
											stats: stats,
											networkDetails: networkDetails,
										});
									};
									return FragmentLoader;
								})(event_handler);
								var fragment_loader = fragment_loader_FragmentLoader;
								function key_loader_inheritsLoose(subClass, superClass) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var key_loader_KeyLoader = (function (_EventHandler) {
									key_loader_inheritsLoose(KeyLoader, _EventHandler);
									function KeyLoader(hls) {
										var _this;
										_this =
											_EventHandler.call(
												this,
												hls,
												events["default"].KEY_LOADING
											) || this;
										_this.loaders = {};
										_this.decryptkey = null;
										_this.decrypturl = null;
										return _this;
									}
									var _proto = KeyLoader.prototype;
									_proto.destroy = function destroy() {
										for (var loaderName in this.loaders) {
											var loader = this.loaders[loaderName];
											if (loader) {
												loader.destroy();
											}
										}
										this.loaders = {};
										_EventHandler.prototype.destroy.call(this);
									};
									_proto.onKeyLoading = function onKeyLoading(data) {
										var frag = data.frag;
										var type = frag.type;
										var loader = this.loaders[type];
										if (!frag.decryptdata) {
											logger["logger"].warn(
												"Missing decryption data on fragment in onKeyLoading"
											);
											return;
										}
										var uri = frag.decryptdata.uri;
										if (uri !== this.decrypturl || this.decryptkey === null) {
											var config = this.hls.config;
											if (loader) {
												logger["logger"].warn(
													"abort previous key loader for type:" + type
												);
												loader.abort();
											}
											if (!uri) {
												logger["logger"].warn("key uri is falsy");
												return;
											}
											frag.loader = this.loaders[type] = new config.loader(
												config
											);
											this.decrypturl = uri;
											this.decryptkey = null;
											var loaderContext = {
												url: uri,
												frag: frag,
												responseType: "arraybuffer",
											};
											var loaderConfig = {
												timeout: config.fragLoadingTimeOut,
												maxRetry: 0,
												retryDelay: config.fragLoadingRetryDelay,
												maxRetryDelay: config.fragLoadingMaxRetryTimeout,
											};
											var loaderCallbacks = {
												onSuccess: this.loadsuccess.bind(this),
												onError: this.loaderror.bind(this),
												onTimeout: this.loadtimeout.bind(this),
											};
											frag.loader.load(
												loaderContext,
												loaderConfig,
												loaderCallbacks
											);
										} else if (this.decryptkey) {
											frag.decryptdata.key = this.decryptkey;
											this.hls.trigger(events["default"].KEY_LOADED, {
												frag: frag,
											});
										}
									};
									_proto.loadsuccess = function loadsuccess(
										response,
										stats,
										context
									) {
										var frag = context.frag;
										if (!frag.decryptdata) {
											logger["logger"].error(
												"after key load, decryptdata unset"
											);
											return;
										}
										this.decryptkey = frag.decryptdata.key = new Uint8Array(
											response.data
										);
										frag.loader = undefined;
										delete this.loaders[frag.type];
										this.hls.trigger(events["default"].KEY_LOADED, {
											frag: frag,
										});
									};
									_proto.loaderror = function loaderror(response, context) {
										var frag = context.frag;
										var loader = frag.loader;
										if (loader) {
											loader.abort();
										}
										delete this.loaders[frag.type];
										this.hls.trigger(events["default"].ERROR, {
											type: errors["ErrorTypes"].NETWORK_ERROR,
											details: errors["ErrorDetails"].KEY_LOAD_ERROR,
											fatal: false,
											frag: frag,
											response: response,
										});
									};
									_proto.loadtimeout = function loadtimeout(stats, context) {
										var frag = context.frag;
										var loader = frag.loader;
										if (loader) {
											loader.abort();
										}
										delete this.loaders[frag.type];
										this.hls.trigger(events["default"].ERROR, {
											type: errors["ErrorTypes"].NETWORK_ERROR,
											details: errors["ErrorDetails"].KEY_LOAD_TIMEOUT,
											fatal: false,
											frag: frag,
										});
									};
									return KeyLoader;
								})(event_handler);
								var key_loader = key_loader_KeyLoader;
								function fragment_tracker_inheritsLoose(subClass, superClass) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var FragmentState = {
									NOT_LOADED: "NOT_LOADED",
									APPENDING: "APPENDING",
									PARTIAL: "PARTIAL",
									OK: "OK",
								};
								var fragment_tracker_FragmentTracker = (function (
									_EventHandler
								) {
									fragment_tracker_inheritsLoose(
										FragmentTracker,
										_EventHandler
									);
									function FragmentTracker(hls) {
										var _this;
										_this =
											_EventHandler.call(
												this,
												hls,
												events["default"].BUFFER_APPENDED,
												events["default"].FRAG_BUFFERED,
												events["default"].FRAG_LOADED
											) || this;
										_this.bufferPadding = 0.2;
										_this.fragments = Object.create(null);
										_this.timeRanges = Object.create(null);
										_this.config = hls.config;
										return _this;
									}
									var _proto = FragmentTracker.prototype;
									_proto.destroy = function destroy() {
										this.fragments = Object.create(null);
										this.timeRanges = Object.create(null);
										this.config = null;
										event_handler.prototype.destroy.call(this);
										_EventHandler.prototype.destroy.call(this);
									};
									_proto.getBufferedFrag = function getBufferedFrag(
										position,
										levelType
									) {
										var fragments = this.fragments;
										var bufferedFrags = Object.keys(fragments).filter(function (
											key
										) {
											var fragmentEntity = fragments[key];
											if (fragmentEntity.body.type !== levelType) {
												return false;
											}
											if (!fragmentEntity.buffered) {
												return false;
											}
											var frag = fragmentEntity.body;
											return (
												frag.startPTS <= position && position <= frag.endPTS
											);
										});
										if (bufferedFrags.length === 0) {
											return null;
										} else {
											var bufferedFragKey = bufferedFrags.pop();
											return fragments[bufferedFragKey].body;
										}
									};
									_proto.detectEvictedFragments =
										function detectEvictedFragments(
											elementaryStream,
											timeRange
										) {
											var _this2 = this;
											Object.keys(this.fragments).forEach(function (key) {
												var fragmentEntity = _this2.fragments[key];
												if (!fragmentEntity || !fragmentEntity.buffered) {
													return;
												}
												var esData = fragmentEntity.range[elementaryStream];
												if (!esData) {
													return;
												}
												var fragmentTimes = esData.time;
												for (var i = 0; i < fragmentTimes.length; i++) {
													var time = fragmentTimes[i];
													if (
														!_this2.isTimeBuffered(
															time.startPTS,
															time.endPTS,
															timeRange
														)
													) {
														_this2.removeFragment(fragmentEntity.body);
														break;
													}
												}
											});
										};
									_proto.detectPartialFragments =
										function detectPartialFragments(fragment) {
											var _this3 = this;
											var fragKey = this.getFragmentKey(fragment);
											var fragmentEntity = this.fragments[fragKey];
											if (fragmentEntity) {
												fragmentEntity.buffered = true;
												Object.keys(this.timeRanges).forEach(function (
													elementaryStream
												) {
													if (fragment.hasElementaryStream(elementaryStream)) {
														var timeRange = _this3.timeRanges[elementaryStream];
														fragmentEntity.range[elementaryStream] =
															_this3.getBufferedTimes(
																fragment.startPTS,
																fragment.endPTS,
																timeRange
															);
													}
												});
											}
										};
									_proto.getBufferedTimes = function getBufferedTimes(
										startPTS,
										endPTS,
										timeRange
									) {
										var fragmentTimes = [];
										var startTime, endTime;
										var fragmentPartial = false;
										for (var i = 0; i < timeRange.length; i++) {
											startTime = timeRange.start(i) - this.bufferPadding;
											endTime = timeRange.end(i) + this.bufferPadding;
											if (startPTS >= startTime && endPTS <= endTime) {
												fragmentTimes.push({
													startPTS: Math.max(startPTS, timeRange.start(i)),
													endPTS: Math.min(endPTS, timeRange.end(i)),
												});
												break;
											} else if (startPTS < endTime && endPTS > startTime) {
												fragmentTimes.push({
													startPTS: Math.max(startPTS, timeRange.start(i)),
													endPTS: Math.min(endPTS, timeRange.end(i)),
												});
												fragmentPartial = true;
											} else if (endPTS <= startTime) {
												break;
											}
										}
										return { time: fragmentTimes, partial: fragmentPartial };
									};
									_proto.getFragmentKey = function getFragmentKey(fragment) {
										return (
											fragment.type +
											"_" +
											fragment.level +
											"_" +
											fragment.urlId +
											"_" +
											fragment.sn
										);
									};
									_proto.getPartialFragment = function getPartialFragment(
										time
									) {
										var _this4 = this;
										var timePadding, startTime, endTime;
										var bestFragment = null;
										var bestOverlap = 0;
										Object.keys(this.fragments).forEach(function (key) {
											var fragmentEntity = _this4.fragments[key];
											if (_this4.isPartial(fragmentEntity)) {
												startTime =
													fragmentEntity.body.startPTS - _this4.bufferPadding;
												endTime =
													fragmentEntity.body.endPTS + _this4.bufferPadding;
												if (time >= startTime && time <= endTime) {
													timePadding = Math.min(
														time - startTime,
														endTime - time
													);
													if (bestOverlap <= timePadding) {
														bestFragment = fragmentEntity.body;
														bestOverlap = timePadding;
													}
												}
											}
										});
										return bestFragment;
									};
									_proto.getState = function getState(fragment) {
										var fragKey = this.getFragmentKey(fragment);
										var fragmentEntity = this.fragments[fragKey];
										var state = FragmentState.NOT_LOADED;
										if (fragmentEntity !== undefined) {
											if (!fragmentEntity.buffered) {
												state = FragmentState.APPENDING;
											} else if (this.isPartial(fragmentEntity) === true) {
												state = FragmentState.PARTIAL;
											} else {
												state = FragmentState.OK;
											}
										}
										return state;
									};
									_proto.isPartial = function isPartial(fragmentEntity) {
										return (
											fragmentEntity.buffered === true &&
											((fragmentEntity.range.video !== undefined &&
												fragmentEntity.range.video.partial === true) ||
												(fragmentEntity.range.audio !== undefined &&
													fragmentEntity.range.audio.partial === true))
										);
									};
									_proto.isTimeBuffered = function isTimeBuffered(
										startPTS,
										endPTS,
										timeRange
									) {
										var startTime, endTime;
										for (var i = 0; i < timeRange.length; i++) {
											startTime = timeRange.start(i) - this.bufferPadding;
											endTime = timeRange.end(i) + this.bufferPadding;
											if (startPTS >= startTime && endPTS <= endTime) {
												return true;
											}
											if (endPTS <= startTime) {
												return false;
											}
										}
										return false;
									};
									_proto.onFragLoaded = function onFragLoaded(e) {
										var fragment = e.frag;
										if (
											!Object(number["isFiniteNumber"])(fragment.sn) ||
											fragment.bitrateTest
										) {
											return;
										}
										this.fragments[this.getFragmentKey(fragment)] = {
											body: fragment,
											range: Object.create(null),
											buffered: false,
										};
									};
									_proto.onBufferAppended = function onBufferAppended(e) {
										var _this5 = this;
										this.timeRanges = e.timeRanges;
										Object.keys(this.timeRanges).forEach(function (
											elementaryStream
										) {
											var timeRange = _this5.timeRanges[elementaryStream];
											_this5.detectEvictedFragments(
												elementaryStream,
												timeRange
											);
										});
									};
									_proto.onFragBuffered = function onFragBuffered(e) {
										this.detectPartialFragments(e.frag);
									};
									_proto.hasFragment = function hasFragment(fragment) {
										var fragKey = this.getFragmentKey(fragment);
										return this.fragments[fragKey] !== undefined;
									};
									_proto.removeFragment = function removeFragment(fragment) {
										var fragKey = this.getFragmentKey(fragment);
										delete this.fragments[fragKey];
									};
									_proto.removeAllFragments = function removeAllFragments() {
										this.fragments = Object.create(null);
									};
									return FragmentTracker;
								})(event_handler);
								var BinarySearch = {
									search: function search(list, comparisonFn) {
										var minIndex = 0;
										var maxIndex = list.length - 1;
										var currentIndex = null;
										var currentElement = null;
										while (minIndex <= maxIndex) {
											currentIndex = ((minIndex + maxIndex) / 2) | 0;
											currentElement = list[currentIndex];
											var comparisonResult = comparisonFn(currentElement);
											if (comparisonResult > 0) {
												minIndex = currentIndex + 1;
											} else if (comparisonResult < 0) {
												maxIndex = currentIndex - 1;
											} else {
												return currentElement;
											}
										}
										return null;
									},
								};
								var binary_search = BinarySearch;
								var BufferHelper = (function () {
									function BufferHelper() {}
									BufferHelper.isBuffered = function isBuffered(
										media,
										position
									) {
										try {
											if (media) {
												var buffered = media.buffered;
												for (var i = 0; i < buffered.length; i++) {
													if (
														position >= buffered.start(i) &&
														position <= buffered.end(i)
													) {
														return true;
													}
												}
											}
										} catch (error) {}
										return false;
									};
									BufferHelper.bufferInfo = function bufferInfo(
										media,
										pos,
										maxHoleDuration
									) {
										try {
											if (media) {
												var vbuffered = media.buffered;
												var buffered = [];
												var i;
												for (i = 0; i < vbuffered.length; i++) {
													buffered.push({
														start: vbuffered.start(i),
														end: vbuffered.end(i),
													});
												}
												return this.bufferedInfo(
													buffered,
													pos,
													maxHoleDuration
												);
											}
										} catch (error) {}
										return {
											len: 0,
											start: pos,
											end: pos,
											nextStart: undefined,
										};
									};
									BufferHelper.bufferedInfo = function bufferedInfo(
										buffered,
										pos,
										maxHoleDuration
									) {
										buffered.sort(function (a, b) {
											var diff = a.start - b.start;
											if (diff) {
												return diff;
											} else {
												return b.end - a.end;
											}
										});
										var buffered2 = [];
										if (maxHoleDuration) {
											for (var i = 0; i < buffered.length; i++) {
												var buf2len = buffered2.length;
												if (buf2len) {
													var buf2end = buffered2[buf2len - 1].end;
													if (buffered[i].start - buf2end < maxHoleDuration) {
														if (buffered[i].end > buf2end) {
															buffered2[buf2len - 1].end = buffered[i].end;
														}
													} else {
														buffered2.push(buffered[i]);
													}
												} else {
													buffered2.push(buffered[i]);
												}
											}
										} else {
											buffered2 = buffered;
										}
										var bufferLen = 0;
										var bufferStartNext;
										var bufferStart = pos;
										var bufferEnd = pos;
										for (var _i = 0; _i < buffered2.length; _i++) {
											var start = buffered2[_i].start,
												end = buffered2[_i].end;
											if (pos + maxHoleDuration >= start && pos < end) {
												bufferStart = start;
												bufferEnd = end;
												bufferLen = bufferEnd - pos;
											} else if (pos + maxHoleDuration < start) {
												bufferStartNext = start;
												break;
											}
										}
										return {
											len: bufferLen,
											start: bufferStart,
											end: bufferEnd,
											nextStart: bufferStartNext,
										};
									};
									return BufferHelper;
								})();
								var eventemitter3 = __webpack_require__(
									"./node_modules/eventemitter3/index.js"
								);
								var webworkify_webpack = __webpack_require__(
									"./node_modules/webworkify-webpack/index.js"
								);
								var demuxer_inline = __webpack_require__(
									"./src/demux/demuxer-inline.js"
								);
								function getMediaSource() {
									return window.MediaSource || window.WebKitMediaSource;
								}
								var get_self_scope = __webpack_require__(
									"./src/utils/get-self-scope.js"
								);
								function observer_inheritsLoose(subClass, superClass) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var Observer = (function (_EventEmitter) {
									observer_inheritsLoose(Observer, _EventEmitter);
									function Observer() {
										return _EventEmitter.apply(this, arguments) || this;
									}
									var _proto = Observer.prototype;
									_proto.trigger = function trigger(event) {
										for (
											var _len = arguments.length,
												data = new Array(_len > 1 ? _len - 1 : 0),
												_key = 1;
											_key < _len;
											_key++
										) {
											data[_key - 1] = arguments[_key];
										}
										this.emit.apply(this, [event, event].concat(data));
									};
									return Observer;
								})(eventemitter3["EventEmitter"]);
								var global = Object(get_self_scope["getSelfScope"])();
								var demuxer_MediaSource = getMediaSource() || {
									isTypeSupported: function isTypeSupported() {
										return false;
									},
								};
								var demuxer_Demuxer = (function () {
									function Demuxer(hls, id) {
										var _this = this;
										this.hls = hls;
										this.id = id;
										var observer = (this.observer = new Observer());
										var config = hls.config;
										var forwardMessage = function forwardMessage(ev, data) {
											data = data || {};
											data.frag = _this.frag;
											data.id = _this.id;
											hls.trigger(ev, data);
										};
										observer.on(
											events["default"].FRAG_DECRYPTED,
											forwardMessage
										);
										observer.on(
											events["default"].FRAG_PARSING_INIT_SEGMENT,
											forwardMessage
										);
										observer.on(
											events["default"].FRAG_PARSING_DATA,
											forwardMessage
										);
										observer.on(events["default"].FRAG_PARSED, forwardMessage);
										observer.on(events["default"].ERROR, forwardMessage);
										observer.on(
											events["default"].FRAG_PARSING_METADATA,
											forwardMessage
										);
										observer.on(
											events["default"].FRAG_PARSING_USERDATA,
											forwardMessage
										);
										observer.on(
											events["default"].INIT_PTS_FOUND,
											forwardMessage
										);
										var typeSupported = {
											mp4: demuxer_MediaSource.isTypeSupported("video/mp4"),
											mpeg: demuxer_MediaSource.isTypeSupported("audio/mpeg"),
											mp3: demuxer_MediaSource.isTypeSupported(
												'audio/mp4; codecs="mp3"'
											),
										};
										var vendor = navigator.vendor;
										if (config.enableWorker && typeof Worker !== "undefined") {
											logger["logger"].log("demuxing in webworker");
											var w;
											try {
												w = this.w = webworkify_webpack(
													"./src/demux/demuxer-worker.js"
												);
												this.onwmsg = this.onWorkerMessage.bind(this);
												w.addEventListener("message", this.onwmsg);
												w.onerror = function (event) {
													hls.trigger(events["default"].ERROR, {
														type: errors["ErrorTypes"].OTHER_ERROR,
														details: errors["ErrorDetails"].INTERNAL_EXCEPTION,
														fatal: true,
														event: "demuxerWorker",
														err: {
															message:
																event.message +
																" (" +
																event.filename +
																":" +
																event.lineno +
																")",
														},
													});
												};
												w.postMessage({
													cmd: "init",
													typeSupported: typeSupported,
													vendor: vendor,
													id: id,
													config: JSON.stringify(config),
												});
											} catch (err) {
												logger["logger"].warn("Error in worker:", err);
												logger["logger"].error(
													"Error while initializing DemuxerWorker, fallback on DemuxerInline"
												);
												if (w) {
													global.URL.revokeObjectURL(w.objectURL);
												}
												this.demuxer = new demuxer_inline["default"](
													observer,
													typeSupported,
													config,
													vendor
												);
												this.w = undefined;
											}
										} else {
											this.demuxer = new demuxer_inline["default"](
												observer,
												typeSupported,
												config,
												vendor
											);
										}
									}
									var _proto = Demuxer.prototype;
									_proto.destroy = function destroy() {
										var w = this.w;
										if (w) {
											w.removeEventListener("message", this.onwmsg);
											w.terminate();
											this.w = null;
										} else {
											var demuxer = this.demuxer;
											if (demuxer) {
												demuxer.destroy();
												this.demuxer = null;
											}
										}
										var observer = this.observer;
										if (observer) {
											observer.removeAllListeners();
											this.observer = null;
										}
									};
									_proto.push = function push(
										data,
										initSegment,
										audioCodec,
										videoCodec,
										frag,
										duration,
										accurateTimeOffset,
										defaultInitPTS
									) {
										var w = this.w;
										var timeOffset = Object(number["isFiniteNumber"])(
											frag.startPTS
										)
											? frag.startPTS
											: frag.start;
										var decryptdata = frag.decryptdata;
										var lastFrag = this.frag;
										var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
										var trackSwitch = !(
											lastFrag && frag.level === lastFrag.level
										);
										var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;
										var contiguous = !trackSwitch && nextSN;
										if (discontinuity) {
											logger["logger"].log(this.id + ":discontinuity detected");
										}
										if (trackSwitch) {
											logger["logger"].log(this.id + ":switch detected");
										}
										this.frag = frag;
										if (w) {
											w.postMessage(
												{
													cmd: "demux",
													data: data,
													decryptdata: decryptdata,
													initSegment: initSegment,
													audioCodec: audioCodec,
													videoCodec: videoCodec,
													timeOffset: timeOffset,
													discontinuity: discontinuity,
													trackSwitch: trackSwitch,
													contiguous: contiguous,
													duration: duration,
													accurateTimeOffset: accurateTimeOffset,
													defaultInitPTS: defaultInitPTS,
												},
												data instanceof ArrayBuffer ? [data] : []
											);
										} else {
											var demuxer = this.demuxer;
											if (demuxer) {
												demuxer.push(
													data,
													decryptdata,
													initSegment,
													audioCodec,
													videoCodec,
													timeOffset,
													discontinuity,
													trackSwitch,
													contiguous,
													duration,
													accurateTimeOffset,
													defaultInitPTS
												);
											}
										}
									};
									_proto.onWorkerMessage = function onWorkerMessage(ev) {
										var data = ev.data,
											hls = this.hls;
										switch (data.event) {
											case "init":
												global.URL.revokeObjectURL(this.w.objectURL);
												break;
											case events["default"].FRAG_PARSING_DATA:
												data.data.data1 = new Uint8Array(data.data1);
												if (data.data2) {
													data.data.data2 = new Uint8Array(data.data2);
												}
											default:
												data.data = data.data || {};
												data.data.frag = this.frag;
												data.data.id = this.id;
												hls.trigger(data.event, data.data);
												break;
										}
									};
									return Demuxer;
								})();
								var demux_demuxer = demuxer_Demuxer;
								function addGroupId(level, type, id) {
									switch (type) {
										case "audio":
											if (!level.audioGroupIds) {
												level.audioGroupIds = [];
											}
											level.audioGroupIds.push(id);
											break;
										case "text":
											if (!level.textGroupIds) {
												level.textGroupIds = [];
											}
											level.textGroupIds.push(id);
											break;
									}
								}
								function updatePTS(fragments, fromIdx, toIdx) {
									var fragFrom = fragments[fromIdx],
										fragTo = fragments[toIdx],
										fragToPTS = fragTo.startPTS;
									if (Object(number["isFiniteNumber"])(fragToPTS)) {
										if (toIdx > fromIdx) {
											fragFrom.duration = fragToPTS - fragFrom.start;
											if (fragFrom.duration < 0) {
												logger["logger"].warn(
													"negative duration computed for frag " +
														fragFrom.sn +
														",level " +
														fragFrom.level +
														", there should be some duration drift between playlist and fragment!"
												);
											}
										} else {
											fragTo.duration = fragFrom.start - fragToPTS;
											if (fragTo.duration < 0) {
												logger["logger"].warn(
													"negative duration computed for frag " +
														fragTo.sn +
														",level " +
														fragTo.level +
														", there should be some duration drift between playlist and fragment!"
												);
											}
										}
									} else {
										if (toIdx > fromIdx) {
											var contiguous = fragFrom.cc === fragTo.cc;
											fragTo.start =
												fragFrom.start +
												(contiguous && fragFrom.minEndPTS
													? fragFrom.minEndPTS - fragFrom.start
													: fragFrom.duration);
										} else {
											fragTo.start = Math.max(
												fragFrom.start - fragTo.duration,
												0
											);
										}
									}
								}
								function updateFragPTSDTS(
									details,
									frag,
									startPTS,
									endPTS,
									startDTS,
									endDTS
								) {
									var maxStartPTS = startPTS;
									var minEndPTS = endPTS;
									if (Object(number["isFiniteNumber"])(frag.startPTS)) {
										var deltaPTS = Math.abs(frag.startPTS - startPTS);
										if (!Object(number["isFiniteNumber"])(frag.deltaPTS)) {
											frag.deltaPTS = deltaPTS;
										} else {
											frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
										}
										maxStartPTS = Math.max(startPTS, frag.startPTS);
										startPTS = Math.min(startPTS, frag.startPTS);
										minEndPTS = Math.min(endPTS, frag.endPTS);
										endPTS = Math.max(endPTS, frag.endPTS);
										startDTS = Math.min(startDTS, frag.startDTS);
										endDTS = Math.max(endDTS, frag.endDTS);
									}
									var drift = startPTS - frag.start;
									frag.start = frag.startPTS = startPTS;
									frag.maxStartPTS = maxStartPTS;
									frag.endPTS = endPTS;
									frag.minEndPTS = minEndPTS;
									frag.startDTS = startDTS;
									frag.endDTS = endDTS;
									frag.duration = endPTS - startPTS;
									var sn = frag.sn;
									if (!details || sn < details.startSN || sn > details.endSN) {
										return 0;
									}
									var fragIdx, fragments, i;
									fragIdx = sn - details.startSN;
									fragments = details.fragments;
									fragments[fragIdx] = frag;
									for (i = fragIdx; i > 0; i--) {
										updatePTS(fragments, i, i - 1);
									}
									for (i = fragIdx; i < fragments.length - 1; i++) {
										updatePTS(fragments, i, i + 1);
									}
									details.PTSKnown = true;
									return drift;
								}
								function mergeDetails(oldDetails, newDetails) {
									if (newDetails.initSegment && oldDetails.initSegment) {
										newDetails.initSegment = oldDetails.initSegment;
									}
									var ccOffset = 0;
									var PTSFrag;
									mapFragmentIntersection(
										oldDetails,
										newDetails,
										function (oldFrag, newFrag) {
											ccOffset = oldFrag.cc - newFrag.cc;
											if (Object(number["isFiniteNumber"])(oldFrag.startPTS)) {
												newFrag.start = newFrag.startPTS = oldFrag.startPTS;
												newFrag.endPTS = oldFrag.endPTS;
												newFrag.duration = oldFrag.duration;
												newFrag.backtracked = oldFrag.backtracked;
												newFrag.dropped = oldFrag.dropped;
												PTSFrag = newFrag;
											}
											newDetails.PTSKnown = true;
										}
									);
									if (!newDetails.PTSKnown) {
										return;
									}
									if (ccOffset) {
										logger["logger"].log(
											"discontinuity sliding from playlist, take drift into account"
										);
										var newFragments = newDetails.fragments;
										for (var i = 0; i < newFragments.length; i++) {
											newFragments[i].cc += ccOffset;
										}
									}
									if (PTSFrag) {
										updateFragPTSDTS(
											newDetails,
											PTSFrag,
											PTSFrag.startPTS,
											PTSFrag.endPTS,
											PTSFrag.startDTS,
											PTSFrag.endDTS
										);
									} else {
										adjustSliding(oldDetails, newDetails);
									}
									newDetails.PTSKnown = oldDetails.PTSKnown;
								}
								function mergeSubtitlePlaylists(
									oldPlaylist,
									newPlaylist,
									referenceStart
								) {
									if (referenceStart === void 0) {
										referenceStart = 0;
									}
									var lastIndex = -1;
									mapFragmentIntersection(
										oldPlaylist,
										newPlaylist,
										function (oldFrag, newFrag, index) {
											newFrag.start = oldFrag.start;
											lastIndex = index;
										}
									);
									var frags = newPlaylist.fragments;
									if (lastIndex < 0) {
										frags.forEach(function (frag) {
											frag.start += referenceStart;
										});
										return;
									}
									for (var i = lastIndex + 1; i < frags.length; i++) {
										frags[i].start = frags[i - 1].start + frags[i - 1].duration;
									}
								}
								function mapFragmentIntersection(
									oldPlaylist,
									newPlaylist,
									intersectionFn
								) {
									if (!oldPlaylist || !newPlaylist) {
										return;
									}
									var start =
										Math.max(oldPlaylist.startSN, newPlaylist.startSN) -
										newPlaylist.startSN;
									var end =
										Math.min(oldPlaylist.endSN, newPlaylist.endSN) -
										newPlaylist.startSN;
									var delta = newPlaylist.startSN - oldPlaylist.startSN;
									for (var i = start; i <= end; i++) {
										var oldFrag = oldPlaylist.fragments[delta + i];
										var newFrag = newPlaylist.fragments[i];
										if (!oldFrag || !newFrag) {
											break;
										}
										intersectionFn(oldFrag, newFrag, i);
									}
								}
								function adjustSliding(oldPlaylist, newPlaylist) {
									var delta = newPlaylist.startSN - oldPlaylist.startSN;
									var oldFragments = oldPlaylist.fragments;
									var newFragments = newPlaylist.fragments;
									if (delta < 0 || delta > oldFragments.length) {
										return;
									}
									for (var i = 0; i < newFragments.length; i++) {
										newFragments[i].start += oldFragments[delta].start;
									}
								}
								function computeReloadInterval(
									currentPlaylist,
									newPlaylist,
									lastRequestTime
								) {
									var reloadInterval =
										1e3 *
										(newPlaylist.averagetargetduration
											? newPlaylist.averagetargetduration
											: newPlaylist.targetduration);
									var minReloadInterval = reloadInterval / 2;
									if (
										currentPlaylist &&
										newPlaylist.endSN === currentPlaylist.endSN
									) {
										reloadInterval = minReloadInterval;
									}
									if (lastRequestTime) {
										reloadInterval = Math.max(
											minReloadInterval,
											reloadInterval -
												(window.performance.now() - lastRequestTime)
										);
									}
									return Math.round(reloadInterval);
								}
								var TimeRanges = {
									toString: function toString(r) {
										var log = "";
										var len = r.length;
										for (var i = 0; i < len; i++) {
											log +=
												"[" +
												r.start(i).toFixed(3) +
												"," +
												r.end(i).toFixed(3) +
												"]";
										}
										return log;
									},
								};
								var time_ranges = TimeRanges;
								function findFirstFragWithCC(fragments, cc) {
									var firstFrag = null;
									for (var i = 0; i < fragments.length; i += 1) {
										var currentFrag = fragments[i];
										if (currentFrag && currentFrag.cc === cc) {
											firstFrag = currentFrag;
											break;
										}
									}
									return firstFrag;
								}
								function findFragWithCC(fragments, CC) {
									return binary_search.search(fragments, function (candidate) {
										if (candidate.cc < CC) {
											return 1;
										} else if (candidate.cc > CC) {
											return -1;
										} else {
											return 0;
										}
									});
								}
								function shouldAlignOnDiscontinuities(
									lastFrag,
									lastLevel,
									details
								) {
									var shouldAlign = false;
									if (lastLevel && lastLevel.details && details) {
										if (
											details.endCC > details.startCC ||
											(lastFrag && lastFrag.cc < details.startCC)
										) {
											shouldAlign = true;
										}
									}
									return shouldAlign;
								}
								function findDiscontinuousReferenceFrag(
									prevDetails,
									curDetails
								) {
									var prevFrags = prevDetails.fragments;
									var curFrags = curDetails.fragments;
									if (!curFrags.length || !prevFrags.length) {
										logger["logger"].log("No fragments to align");
										return;
									}
									var prevStartFrag = findFirstFragWithCC(
										prevFrags,
										curFrags[0].cc
									);
									if (
										!prevStartFrag ||
										(prevStartFrag && !prevStartFrag.startPTS)
									) {
										logger["logger"].log(
											"No frag in previous level to align on"
										);
										return;
									}
									return prevStartFrag;
								}
								function adjustPts(sliding, details) {
									details.fragments.forEach(function (frag) {
										if (frag) {
											var start = frag.start + sliding;
											frag.start = frag.startPTS = start;
											frag.endPTS = start + frag.duration;
										}
									});
									details.PTSKnown = true;
								}
								function alignStream(lastFrag, lastLevel, details) {
									alignDiscontinuities(lastFrag, details, lastLevel);
									if (!details.PTSKnown && lastLevel) {
										alignPDT(details, lastLevel.details);
									}
								}
								function alignDiscontinuities(lastFrag, details, lastLevel) {
									if (
										shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)
									) {
										var referenceFrag = findDiscontinuousReferenceFrag(
											lastLevel.details,
											details
										);
										if (referenceFrag) {
											logger["logger"].log(
												"Adjusting PTS using last level due to CC increase within current level"
											);
											adjustPts(referenceFrag.start, details);
										}
									}
								}
								function alignPDT(details, lastDetails) {
									if (lastDetails && lastDetails.fragments.length) {
										if (
											!details.hasProgramDateTime ||
											!lastDetails.hasProgramDateTime
										) {
											return;
										}
										var lastPDT = lastDetails.fragments[0].programDateTime;
										var newPDT = details.fragments[0].programDateTime;
										var sliding =
											(newPDT - lastPDT) / 1e3 + lastDetails.fragments[0].start;
										if (Object(number["isFiniteNumber"])(sliding)) {
											logger["logger"].log(
												"adjusting PTS using programDateTime delta, sliding:" +
													sliding.toFixed(3)
											);
											adjustPts(sliding, details);
										}
									}
								}
								function findFragmentByPDT(
									fragments,
									PDTValue,
									maxFragLookUpTolerance
								) {
									if (
										PDTValue === null ||
										!Array.isArray(fragments) ||
										!fragments.length ||
										!Object(number["isFiniteNumber"])(PDTValue)
									) {
										return null;
									}
									var startPDT = fragments[0].programDateTime;
									if (PDTValue < (startPDT || 0)) {
										return null;
									}
									var endPDT =
										fragments[fragments.length - 1].endProgramDateTime;
									if (PDTValue >= (endPDT || 0)) {
										return null;
									}
									maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
									for (var seg = 0; seg < fragments.length; ++seg) {
										var frag = fragments[seg];
										if (
											pdtWithinToleranceTest(
												PDTValue,
												maxFragLookUpTolerance,
												frag
											)
										) {
											return frag;
										}
									}
									return null;
								}
								function findFragmentByPTS(
									fragPrevious,
									fragments,
									bufferEnd,
									maxFragLookUpTolerance
								) {
									if (bufferEnd === void 0) {
										bufferEnd = 0;
									}
									if (maxFragLookUpTolerance === void 0) {
										maxFragLookUpTolerance = 0;
									}
									var fragNext = null;
									if (fragPrevious) {
										fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1];
									} else if (bufferEnd === 0 && fragments[0].start === 0) {
										fragNext = fragments[0];
									}
									if (
										fragNext &&
										fragmentWithinToleranceTest(
											bufferEnd,
											maxFragLookUpTolerance,
											fragNext
										) === 0
									) {
										return fragNext;
									}
									var foundFragment = binary_search.search(
										fragments,
										fragmentWithinToleranceTest.bind(
											null,
											bufferEnd,
											maxFragLookUpTolerance
										)
									);
									if (foundFragment) {
										return foundFragment;
									}
									return fragNext;
								}
								function fragmentWithinToleranceTest(
									bufferEnd,
									maxFragLookUpTolerance,
									candidate
								) {
									if (bufferEnd === void 0) {
										bufferEnd = 0;
									}
									if (maxFragLookUpTolerance === void 0) {
										maxFragLookUpTolerance = 0;
									}
									var candidateLookupTolerance = Math.min(
										maxFragLookUpTolerance,
										candidate.duration +
											(candidate.deltaPTS ? candidate.deltaPTS : 0)
									);
									if (
										candidate.start +
											candidate.duration -
											candidateLookupTolerance <=
										bufferEnd
									) {
										return 1;
									} else if (
										candidate.start - candidateLookupTolerance > bufferEnd &&
										candidate.start
									) {
										return -1;
									}
									return 0;
								}
								function pdtWithinToleranceTest(
									pdtBufferEnd,
									maxFragLookUpTolerance,
									candidate
								) {
									var candidateLookupTolerance =
										Math.min(
											maxFragLookUpTolerance,
											candidate.duration +
												(candidate.deltaPTS ? candidate.deltaPTS : 0)
										) * 1e3;
									var endProgramDateTime = candidate.endProgramDateTime || 0;
									return (
										endProgramDateTime - candidateLookupTolerance > pdtBufferEnd
									);
								}
								var STALL_MINIMUM_DURATION_MS = 250;
								var MAX_START_GAP_JUMP = 2;
								var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;
								var SKIP_BUFFER_RANGE_START = 0.05;
								var gap_controller_GapController = (function () {
									function GapController(config, media, fragmentTracker, hls) {
										this.config = config;
										this.media = media;
										this.fragmentTracker = fragmentTracker;
										this.hls = hls;
										this.nudgeRetry = 0;
										this.stallReported = false;
										this.stalled = null;
										this.moved = false;
										this.seeking = false;
									}
									var _proto = GapController.prototype;
									_proto.poll = function poll(lastCurrentTime) {
										var config = this.config,
											media = this.media,
											stalled = this.stalled;
										var currentTime = media.currentTime,
											seeking = media.seeking;
										var seeked = this.seeking && !seeking;
										var beginSeek = !this.seeking && seeking;
										this.seeking = seeking;
										if (currentTime !== lastCurrentTime) {
											this.moved = true;
											if (stalled !== null) {
												if (this.stallReported) {
													var _stalledDuration =
														self.performance.now() - stalled;
													logger["logger"].warn(
														"playback not stuck anymore @" +
															currentTime +
															", after " +
															Math.round(_stalledDuration) +
															"ms"
													);
													this.stallReported = false;
												}
												this.stalled = null;
												this.nudgeRetry = 0;
											}
											return;
										}
										if (beginSeek || seeked) {
											this.stalled = null;
										}
										if (
											media.paused ||
											media.ended ||
											media.playbackRate === 0 ||
											!media.buffered.length
										) {
											return;
										}
										var bufferInfo = BufferHelper.bufferInfo(
											media,
											currentTime,
											0
										);
										var isBuffered = bufferInfo.len > 0;
										var nextStart = bufferInfo.nextStart || 0;
										if (!isBuffered && !nextStart) {
											return;
										}
										if (seeking) {
											var hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;
											var noBufferGap =
												!nextStart ||
												(nextStart - currentTime > MAX_START_GAP_JUMP &&
													!this.fragmentTracker.getPartialFragment(
														currentTime
													));
											if (hasEnoughBuffer || noBufferGap) {
												return;
											}
											this.moved = false;
										}
										if (!this.moved && this.stalled) {
											var startJump =
												Math.max(nextStart, bufferInfo.start || 0) -
												currentTime;
											if (startJump > 0 && startJump <= MAX_START_GAP_JUMP) {
												this._trySkipBufferHole(null);
												return;
											}
										}
										var tnow = self.performance.now();
										if (stalled === null) {
											this.stalled = tnow;
											return;
										}
										var stalledDuration = tnow - stalled;
										if (
											!seeking &&
											stalledDuration >= STALL_MINIMUM_DURATION_MS
										) {
											this._reportStall(bufferInfo.len);
										}
										var bufferedWithHoles = BufferHelper.bufferInfo(
											media,
											currentTime,
											config.maxBufferHole
										);
										this._tryFixBufferStall(bufferedWithHoles, stalledDuration);
									};
									_proto._tryFixBufferStall = function _tryFixBufferStall(
										bufferInfo,
										stalledDurationMs
									) {
										var config = this.config,
											fragmentTracker = this.fragmentTracker,
											media = this.media;
										var currentTime = media.currentTime;
										var partial =
											fragmentTracker.getPartialFragment(currentTime);
										if (partial) {
											var targetTime = this._trySkipBufferHole(partial);
											if (targetTime) {
												return;
											}
										}
										if (
											bufferInfo.len > config.maxBufferHole &&
											stalledDurationMs > config.highBufferWatchdogPeriod * 1e3
										) {
											logger["logger"].warn(
												"Trying to nudge playhead over buffer-hole"
											);
											this.stalled = null;
											this._tryNudgeBuffer();
										}
									};
									_proto._reportStall = function _reportStall(bufferLen) {
										var hls = this.hls,
											media = this.media,
											stallReported = this.stallReported;
										if (!stallReported) {
											this.stallReported = true;
											logger["logger"].warn(
												"Playback stalling at @" +
													media.currentTime +
													" due to low buffer (buffer=" +
													bufferLen +
													")"
											);
											hls.trigger(events["default"].ERROR, {
												type: errors["ErrorTypes"].MEDIA_ERROR,
												details: errors["ErrorDetails"].BUFFER_STALLED_ERROR,
												fatal: false,
												buffer: bufferLen,
											});
										}
									};
									_proto._trySkipBufferHole = function _trySkipBufferHole(
										partial
									) {
										var config = this.config,
											hls = this.hls,
											media = this.media;
										var currentTime = media.currentTime;
										var lastEndTime = 0;
										for (var i = 0; i < media.buffered.length; i++) {
											var startTime = media.buffered.start(i);
											if (
												currentTime + config.maxBufferHole >= lastEndTime &&
												currentTime < startTime
											) {
												var targetTime = Math.max(
													startTime + SKIP_BUFFER_RANGE_START,
													media.currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS
												);
												logger["logger"].warn(
													"skipping hole, adjusting currentTime from " +
														currentTime +
														" to " +
														targetTime
												);
												this.moved = true;
												this.stalled = null;
												media.currentTime = targetTime;
												if (partial) {
													hls.trigger(events["default"].ERROR, {
														type: errors["ErrorTypes"].MEDIA_ERROR,
														details:
															errors["ErrorDetails"].BUFFER_SEEK_OVER_HOLE,
														fatal: false,
														reason:
															"fragment loaded with buffer holes, seeking from " +
															currentTime +
															" to " +
															targetTime,
														frag: partial,
													});
												}
												return targetTime;
											}
											lastEndTime = media.buffered.end(i);
										}
										return 0;
									};
									_proto._tryNudgeBuffer = function _tryNudgeBuffer() {
										var config = this.config,
											hls = this.hls,
											media = this.media;
										var currentTime = media.currentTime;
										var nudgeRetry = (this.nudgeRetry || 0) + 1;
										this.nudgeRetry = nudgeRetry;
										if (nudgeRetry < config.nudgeMaxRetry) {
											var targetTime =
												currentTime + nudgeRetry * config.nudgeOffset;
											logger["logger"].warn(
												"Nudging 'currentTime' from " +
													currentTime +
													" to " +
													targetTime
											);
											media.currentTime = targetTime;
											hls.trigger(events["default"].ERROR, {
												type: errors["ErrorTypes"].MEDIA_ERROR,
												details: errors["ErrorDetails"].BUFFER_NUDGE_ON_STALL,
												fatal: false,
											});
										} else {
											logger["logger"].error(
												"Playhead still not moving while enough data buffered @" +
													currentTime +
													" after " +
													config.nudgeMaxRetry +
													" nudges"
											);
											hls.trigger(events["default"].ERROR, {
												type: errors["ErrorTypes"].MEDIA_ERROR,
												details: errors["ErrorDetails"].BUFFER_STALLED_ERROR,
												fatal: true,
											});
										}
									};
									return GapController;
								})();
								function _assertThisInitialized(self) {
									if (self === void 0) {
										throw new ReferenceError(
											"this hasn't been initialised - super() hasn't been called"
										);
									}
									return self;
								}
								function task_loop_inheritsLoose(subClass, superClass) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var TaskLoop = (function (_EventHandler) {
									task_loop_inheritsLoose(TaskLoop, _EventHandler);
									function TaskLoop(hls) {
										var _this;
										for (
											var _len = arguments.length,
												events = new Array(_len > 1 ? _len - 1 : 0),
												_key = 1;
											_key < _len;
											_key++
										) {
											events[_key - 1] = arguments[_key];
										}
										_this =
											_EventHandler.call.apply(
												_EventHandler,
												[this, hls].concat(events)
											) || this;
										_this._boundTick = void 0;
										_this._tickTimer = null;
										_this._tickInterval = null;
										_this._tickCallCount = 0;
										_this._boundTick = _this.tick.bind(
											_assertThisInitialized(_this)
										);
										return _this;
									}
									var _proto = TaskLoop.prototype;
									_proto.onHandlerDestroying = function onHandlerDestroying() {
										this.clearNextTick();
										this.clearInterval();
									};
									_proto.hasInterval = function hasInterval() {
										return !!this._tickInterval;
									};
									_proto.hasNextTick = function hasNextTick() {
										return !!this._tickTimer;
									};
									_proto.setInterval = function setInterval(millis) {
										if (!this._tickInterval) {
											this._tickInterval = self.setInterval(
												this._boundTick,
												millis
											);
											return true;
										}
										return false;
									};
									_proto.clearInterval = function clearInterval() {
										if (this._tickInterval) {
											self.clearInterval(this._tickInterval);
											this._tickInterval = null;
											return true;
										}
										return false;
									};
									_proto.clearNextTick = function clearNextTick() {
										if (this._tickTimer) {
											self.clearTimeout(this._tickTimer);
											this._tickTimer = null;
											return true;
										}
										return false;
									};
									_proto.tick = function tick() {
										this._tickCallCount++;
										if (this._tickCallCount === 1) {
											this.doTick();
											if (this._tickCallCount > 1) {
												this.clearNextTick();
												this._tickTimer = self.setTimeout(this._boundTick, 0);
											}
											this._tickCallCount = 0;
										}
									};
									_proto.doTick = function doTick() {};
									return TaskLoop;
								})(event_handler);
								function base_stream_controller_inheritsLoose(
									subClass,
									superClass
								) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var State = {
									STOPPED: "STOPPED",
									STARTING: "STARTING",
									IDLE: "IDLE",
									PAUSED: "PAUSED",
									KEY_LOADING: "KEY_LOADING",
									FRAG_LOADING: "FRAG_LOADING",
									FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
									WAITING_TRACK: "WAITING_TRACK",
									PARSING: "PARSING",
									PARSED: "PARSED",
									BUFFER_FLUSHING: "BUFFER_FLUSHING",
									ENDED: "ENDED",
									ERROR: "ERROR",
									WAITING_INIT_PTS: "WAITING_INIT_PTS",
									WAITING_LEVEL: "WAITING_LEVEL",
								};
								var base_stream_controller_BaseStreamController = (function (
									_TaskLoop
								) {
									base_stream_controller_inheritsLoose(
										BaseStreamController,
										_TaskLoop
									);
									function BaseStreamController() {
										return _TaskLoop.apply(this, arguments) || this;
									}
									var _proto = BaseStreamController.prototype;
									_proto.doTick = function doTick() {};
									_proto.startLoad = function startLoad() {};
									_proto.stopLoad = function stopLoad() {
										var frag = this.fragCurrent;
										if (frag) {
											if (frag.loader) {
												frag.loader.abort();
											}
											this.fragmentTracker.removeFragment(frag);
										}
										if (this.demuxer) {
											this.demuxer.destroy();
											this.demuxer = null;
										}
										this.fragCurrent = null;
										this.fragPrevious = null;
										this.clearInterval();
										this.clearNextTick();
										this.state = State.STOPPED;
									};
									_proto._streamEnded = function _streamEnded(
										bufferInfo,
										levelDetails
									) {
										var fragCurrent = this.fragCurrent,
											fragmentTracker = this.fragmentTracker;
										if (
											!levelDetails.live &&
											fragCurrent &&
											!fragCurrent.backtracked &&
											fragCurrent.sn === levelDetails.endSN &&
											!bufferInfo.nextStart
										) {
											var fragState = fragmentTracker.getState(fragCurrent);
											return (
												fragState === FragmentState.PARTIAL ||
												fragState === FragmentState.OK
											);
										}
										return false;
									};
									_proto.onMediaSeeking = function onMediaSeeking() {
										var config = this.config,
											media = this.media,
											mediaBuffer = this.mediaBuffer,
											state = this.state;
										var currentTime = media ? media.currentTime : null;
										var bufferInfo = BufferHelper.bufferInfo(
											mediaBuffer || media,
											currentTime,
											this.config.maxBufferHole
										);
										logger["logger"].log(
											"media seeking to " +
												(Object(number["isFiniteNumber"])(currentTime)
													? currentTime.toFixed(3)
													: currentTime)
										);
										if (state === State.FRAG_LOADING) {
											var fragCurrent = this.fragCurrent;
											if (bufferInfo.len === 0 && fragCurrent) {
												var tolerance = config.maxFragLookUpTolerance;
												var fragStartOffset = fragCurrent.start - tolerance;
												var fragEndOffset =
													fragCurrent.start + fragCurrent.duration + tolerance;
												if (
													currentTime < fragStartOffset ||
													currentTime > fragEndOffset
												) {
													if (fragCurrent.loader) {
														logger["logger"].log(
															"seeking outside of buffer while fragment load in progress, cancel fragment load"
														);
														fragCurrent.loader.abort();
													}
													this.fragCurrent = null;
													this.fragPrevious = null;
													this.state = State.IDLE;
												} else {
													logger["logger"].log(
														"seeking outside of buffer but within currently loaded fragment range"
													);
												}
											}
										} else if (state === State.ENDED) {
											if (bufferInfo.len === 0) {
												this.fragPrevious = null;
												this.fragCurrent = null;
											}
											this.state = State.IDLE;
										}
										if (media) {
											this.lastCurrentTime = currentTime;
										}
										if (!this.loadedmetadata) {
											this.nextLoadPosition = this.startPosition = currentTime;
										}
										this.tick();
									};
									_proto.onMediaEnded = function onMediaEnded() {
										this.startPosition = this.lastCurrentTime = 0;
									};
									_proto.onHandlerDestroying = function onHandlerDestroying() {
										this.stopLoad();
										_TaskLoop.prototype.onHandlerDestroying.call(this);
									};
									_proto.onHandlerDestroyed = function onHandlerDestroyed() {
										this.state = State.STOPPED;
										this.fragmentTracker = null;
									};
									_proto.computeLivePosition = function computeLivePosition(
										sliding,
										levelDetails
									) {
										var targetLatency =
											this.config.liveSyncDuration !== undefined
												? this.config.liveSyncDuration
												: this.config.liveSyncDurationCount *
												  levelDetails.targetduration;
										return (
											sliding +
											Math.max(0, levelDetails.totalduration - targetLatency)
										);
									};
									return BaseStreamController;
								})(TaskLoop);
								function stream_controller_defineProperties(target, props) {
									for (var i = 0; i < props.length; i++) {
										var descriptor = props[i];
										descriptor.enumerable = descriptor.enumerable || false;
										descriptor.configurable = true;
										if ("value" in descriptor) descriptor.writable = true;
										Object.defineProperty(target, descriptor.key, descriptor);
									}
								}
								function stream_controller_createClass(
									Constructor,
									protoProps,
									staticProps
								) {
									if (protoProps)
										stream_controller_defineProperties(
											Constructor.prototype,
											protoProps
										);
									if (staticProps)
										stream_controller_defineProperties(
											Constructor,
											staticProps
										);
									return Constructor;
								}
								function stream_controller_inheritsLoose(subClass, superClass) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var TICK_INTERVAL = 100;
								var stream_controller_StreamController = (function (
									_BaseStreamController
								) {
									stream_controller_inheritsLoose(
										StreamController,
										_BaseStreamController
									);
									function StreamController(hls, fragmentTracker) {
										var _this;
										_this =
											_BaseStreamController.call(
												this,
												hls,
												events["default"].MEDIA_ATTACHED,
												events["default"].MEDIA_DETACHING,
												events["default"].MANIFEST_LOADING,
												events["default"].MANIFEST_PARSED,
												events["default"].LEVEL_LOADED,
												events["default"].LEVELS_UPDATED,
												events["default"].KEY_LOADED,
												events["default"].FRAG_LOADED,
												events["default"].FRAG_LOAD_EMERGENCY_ABORTED,
												events["default"].FRAG_PARSING_INIT_SEGMENT,
												events["default"].FRAG_PARSING_DATA,
												events["default"].FRAG_PARSED,
												events["default"].ERROR,
												events["default"].AUDIO_TRACK_SWITCHING,
												events["default"].AUDIO_TRACK_SWITCHED,
												events["default"].BUFFER_CREATED,
												events["default"].BUFFER_APPENDED,
												events["default"].BUFFER_FLUSHED
											) || this;
										_this.fragmentTracker = fragmentTracker;
										_this.config = hls.config;
										_this.audioCodecSwap = false;
										_this._state = State.STOPPED;
										_this.stallReported = false;
										_this.gapController = null;
										_this.altAudio = false;
										_this.audioOnly = false;
										_this.bitrateTest = false;
										return _this;
									}
									var _proto = StreamController.prototype;
									_proto.startLoad = function startLoad(startPosition) {
										if (this.levels) {
											var lastCurrentTime = this.lastCurrentTime,
												hls = this.hls;
											this.stopLoad();
											this.setInterval(TICK_INTERVAL);
											this.level = -1;
											this.fragLoadError = 0;
											if (!this.startFragRequested) {
												var startLevel = hls.startLevel;
												if (startLevel === -1) {
													if (hls.config.testBandwidth) {
														startLevel = 0;
														this.bitrateTest = true;
													} else {
														startLevel = hls.nextAutoLevel;
													}
												}
												this.level = hls.nextLoadLevel = startLevel;
												this.loadedmetadata = false;
											}
											if (lastCurrentTime > 0 && startPosition === -1) {
												logger["logger"].log(
													"override startPosition with lastCurrentTime @" +
														lastCurrentTime.toFixed(3)
												);
												startPosition = lastCurrentTime;
											}
											this.state = State.IDLE;
											this.nextLoadPosition =
												this.startPosition =
												this.lastCurrentTime =
													startPosition;
											this.tick();
										} else {
											this.forceStartLoad = true;
											this.state = State.STOPPED;
										}
									};
									_proto.stopLoad = function stopLoad() {
										this.forceStartLoad = false;
										_BaseStreamController.prototype.stopLoad.call(this);
									};
									_proto.doTick = function doTick() {
										switch (this.state) {
											case State.BUFFER_FLUSHING:
												this.fragLoadError = 0;
												break;
											case State.IDLE:
												this._doTickIdle();
												break;
											case State.WAITING_LEVEL:
												var level = this.levels[this.level];
												if (level && level.details) {
													this.state = State.IDLE;
												}
												break;
											case State.FRAG_LOADING_WAITING_RETRY:
												var now = window.performance.now();
												var retryDate = this.retryDate;
												if (
													!retryDate ||
													now >= retryDate ||
													(this.media && this.media.seeking)
												) {
													logger["logger"].log(
														"mediaController: retryDate reached, switch back to IDLE state"
													);
													this.state = State.IDLE;
												}
												break;
											case State.ERROR:
											case State.STOPPED:
											case State.FRAG_LOADING:
											case State.PARSING:
											case State.PARSED:
											case State.ENDED:
												break;
											default:
												break;
										}
										this._checkBuffer();
										this._checkFragmentChanged();
									};
									_proto._doTickIdle = function _doTickIdle() {
										var hls = this.hls,
											config = hls.config,
											media = this.media;
										if (
											this.levelLastLoaded === undefined ||
											(!media &&
												(this.startFragRequested || !config.startFragPrefetch))
										) {
											return;
										}
										if (this.altAudio && this.audioOnly) {
											this.demuxer.frag = null;
											return;
										}
										var pos;
										if (this.loadedmetadata) {
											pos = media.currentTime;
										} else {
											pos = this.nextLoadPosition;
										}
										var level = hls.nextLoadLevel,
											levelInfo = this.levels[level];
										if (!levelInfo) {
											return;
										}
										var levelBitrate = levelInfo.bitrate,
											maxBufLen;
										if (levelBitrate) {
											maxBufLen = Math.max(
												(8 * config.maxBufferSize) / levelBitrate,
												config.maxBufferLength
											);
										} else {
											maxBufLen = config.maxBufferLength;
										}
										maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);
										var maxBufferHole =
											pos < config.maxBufferHole
												? Math.max(MAX_START_GAP_JUMP, config.maxBufferHole)
												: config.maxBufferHole;
										var bufferInfo = BufferHelper.bufferInfo(
											this.mediaBuffer ? this.mediaBuffer : media,
											pos,
											maxBufferHole
										);
										var bufferLen = bufferInfo.len;
										if (bufferLen >= maxBufLen) {
											return;
										}
										logger["logger"].trace(
											"buffer length of " +
												bufferLen.toFixed(3) +
												" is below max of " +
												maxBufLen.toFixed(3) +
												". checking for more payload ..."
										);
										this.level = hls.nextLoadLevel = level;
										var levelDetails = levelInfo.details;
										if (
											!levelDetails ||
											(levelDetails.live && this.levelLastLoaded !== level)
										) {
											this.state = State.WAITING_LEVEL;
											return;
										}
										if (this._streamEnded(bufferInfo, levelDetails)) {
											var data = {};
											if (this.altAudio) {
												data.type = "video";
											}
											this.hls.trigger(events["default"].BUFFER_EOS, data);
											this.state = State.ENDED;
											return;
										}
										this._fetchPayloadOrEos(pos, bufferInfo, levelDetails);
									};
									_proto._fetchPayloadOrEos = function _fetchPayloadOrEos(
										pos,
										bufferInfo,
										levelDetails
									) {
										var fragPrevious = this.fragPrevious,
											level = this.level,
											fragments = levelDetails.fragments,
											fragLen = fragments.length;
										if (fragLen === 0) {
											return;
										}
										var start = fragments[0].start,
											end =
												fragments[fragLen - 1].start +
												fragments[fragLen - 1].duration,
											bufferEnd = bufferInfo.end,
											frag;
										if (
											levelDetails.initSegment &&
											!levelDetails.initSegment.data
										) {
											frag = levelDetails.initSegment;
										} else {
											if (levelDetails.live) {
												var initialLiveManifestSize =
													this.config.initialLiveManifestSize;
												if (fragLen < initialLiveManifestSize) {
													logger["logger"].warn(
														"Can not start playback of a level, reason: not enough fragments " +
															fragLen +
															" < " +
															initialLiveManifestSize
													);
													return;
												}
												frag = this._ensureFragmentAtLivePoint(
													levelDetails,
													bufferEnd,
													start,
													end,
													fragPrevious,
													fragments
												);
												if (frag === null) {
													return;
												}
											} else {
												if (bufferEnd < start) {
													frag = fragments[0];
												}
											}
										}
										if (!frag) {
											frag = this._findFragment(
												start,
												fragPrevious,
												fragLen,
												fragments,
												bufferEnd,
												end,
												levelDetails
											);
										}
										if (frag) {
											if (frag.encrypted) {
												this._loadKey(frag, levelDetails);
											} else {
												this._loadFragment(frag, levelDetails, pos, bufferEnd);
											}
										}
									};
									_proto._ensureFragmentAtLivePoint =
										function _ensureFragmentAtLivePoint(
											levelDetails,
											bufferEnd,
											start,
											end,
											fragPrevious,
											fragments
										) {
											var config = this.hls.config,
												media = this.media;
											var frag;
											var maxLatency = Infinity;
											if (config.liveMaxLatencyDuration !== undefined) {
												maxLatency = config.liveMaxLatencyDuration;
											} else if (
												Object(number["isFiniteNumber"])(
													config.liveMaxLatencyDurationCount
												)
											) {
												maxLatency =
													config.liveMaxLatencyDurationCount *
													levelDetails.targetduration;
											}
											if (
												bufferEnd <
												Math.max(
													start - config.maxFragLookUpTolerance,
													end - maxLatency
												)
											) {
												var liveSyncPosition = (this.liveSyncPosition =
													this.computeLivePosition(start, levelDetails));
												bufferEnd = liveSyncPosition;
												if (
													media &&
													!media.paused &&
													media.readyState &&
													media.duration > liveSyncPosition &&
													liveSyncPosition > media.currentTime
												) {
													logger["logger"].log(
														"buffer end: " +
															bufferEnd.toFixed(3) +
															" is located too far from the end of live sliding playlist, reset currentTime to : " +
															liveSyncPosition.toFixed(3)
													);
													media.currentTime = liveSyncPosition;
												}
												this.nextLoadPosition = liveSyncPosition;
											}
											if (
												levelDetails.PTSKnown &&
												bufferEnd > end &&
												media &&
												media.readyState
											) {
												return null;
											}
											if (this.startFragRequested && !levelDetails.PTSKnown) {
												if (fragPrevious) {
													if (levelDetails.hasProgramDateTime) {
														logger["logger"].log(
															"live playlist, switching playlist, load frag with same PDT: " +
																fragPrevious.programDateTime
														);
														frag = findFragmentByPDT(
															fragments,
															fragPrevious.endProgramDateTime,
															config.maxFragLookUpTolerance
														);
													} else {
														var targetSN = fragPrevious.sn + 1;
														if (
															targetSN >= levelDetails.startSN &&
															targetSN <= levelDetails.endSN
														) {
															var fragNext =
																fragments[targetSN - levelDetails.startSN];
															if (fragPrevious.cc === fragNext.cc) {
																frag = fragNext;
																logger["logger"].log(
																	"live playlist, switching playlist, load frag with next SN: " +
																		frag.sn
																);
															}
														}
														if (!frag) {
															frag = binary_search.search(
																fragments,
																function (frag) {
																	return fragPrevious.cc - frag.cc;
																}
															);
															if (frag) {
																logger["logger"].log(
																	"live playlist, switching playlist, load frag with same CC: " +
																		frag.sn
																);
															}
														}
													}
												}
											}
											return frag;
										};
									_proto._findFragment = function _findFragment(
										start,
										fragPreviousLoad,
										fragmentIndexRange,
										fragments,
										bufferEnd,
										end,
										levelDetails
									) {
										var config = this.hls.config;
										var fragNextLoad;
										if (bufferEnd < end) {
											var lookupTolerance =
												bufferEnd > end - config.maxFragLookUpTolerance
													? 0
													: config.maxFragLookUpTolerance;
											fragNextLoad = findFragmentByPTS(
												fragPreviousLoad,
												fragments,
												bufferEnd,
												lookupTolerance
											);
										} else {
											fragNextLoad = fragments[fragmentIndexRange - 1];
										}
										if (fragNextLoad) {
											var curSNIdx = fragNextLoad.sn - levelDetails.startSN;
											var sameLevel =
												fragPreviousLoad &&
												fragNextLoad.level === fragPreviousLoad.level;
											var prevSnFrag = fragments[curSNIdx - 1];
											var nextSnFrag = fragments[curSNIdx + 1];
											if (
												fragPreviousLoad &&
												fragNextLoad.sn === fragPreviousLoad.sn
											) {
												if (sameLevel && !fragNextLoad.backtracked) {
													if (fragNextLoad.sn < levelDetails.endSN) {
														var deltaPTS = fragPreviousLoad.deltaPTS;
														if (
															deltaPTS &&
															deltaPTS > config.maxBufferHole &&
															fragPreviousLoad.dropped &&
															curSNIdx
														) {
															fragNextLoad = prevSnFrag;
															logger["logger"].warn(
																"Previous fragment was dropped with large PTS gap between audio and video. Maybe fragment is not starting with a keyframe? Loading previous one to try to overcome this"
															);
														} else {
															fragNextLoad = nextSnFrag;
															if (
																this.fragmentTracker.getState(fragNextLoad) !==
																FragmentState.OK
															) {
																logger["logger"].log(
																	"Re-loading fragment with SN: " +
																		fragNextLoad.sn
																);
															}
														}
													} else {
														fragNextLoad = null;
													}
												} else if (fragNextLoad.backtracked) {
													if (nextSnFrag && nextSnFrag.backtracked) {
														logger["logger"].warn(
															"Already backtracked from fragment " +
																nextSnFrag.sn +
																", will not backtrack to fragment " +
																fragNextLoad.sn +
																". Loading fragment " +
																nextSnFrag.sn
														);
														fragNextLoad = nextSnFrag;
													} else {
														logger["logger"].warn(
															"Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe"
														);
														fragNextLoad.dropped = 0;
														if (prevSnFrag) {
															fragNextLoad = prevSnFrag;
															fragNextLoad.backtracked = true;
														} else if (curSNIdx) {
															fragNextLoad = null;
														}
													}
												}
											}
										}
										return fragNextLoad;
									};
									_proto._loadKey = function _loadKey(frag, levelDetails) {
										logger["logger"].log(
											"Loading key for " +
												frag.sn +
												" of [" +
												levelDetails.startSN +
												"-" +
												levelDetails.endSN +
												"], level " +
												this.level
										);
										this.state = State.KEY_LOADING;
										this.hls.trigger(events["default"].KEY_LOADING, {
											frag: frag,
										});
									};
									_proto._loadFragment = function _loadFragment(
										frag,
										levelDetails,
										pos,
										bufferEnd
									) {
										var fragState = this.fragmentTracker.getState(frag);
										this.fragCurrent = frag;
										if (frag.sn !== "initSegment") {
											this.startFragRequested = true;
										}
										if (
											Object(number["isFiniteNumber"])(frag.sn) &&
											!frag.bitrateTest
										) {
											this.nextLoadPosition = frag.start + frag.duration;
										}
										if (
											frag.backtracked ||
											fragState === FragmentState.NOT_LOADED ||
											fragState === FragmentState.PARTIAL
										) {
											frag.autoLevel = this.hls.autoLevelEnabled;
											frag.bitrateTest = this.bitrateTest;
											logger["logger"].log(
												"Loading " +
													frag.sn +
													" of [" +
													levelDetails.startSN +
													"-" +
													levelDetails.endSN +
													"], level " +
													this.level +
													", " +
													(this.loadedmetadata
														? "currentTime"
														: "nextLoadPosition") +
													": " +
													parseFloat(pos.toFixed(3)) +
													", bufferEnd: " +
													parseFloat(bufferEnd.toFixed(3))
											);
											this.hls.trigger(events["default"].FRAG_LOADING, {
												frag: frag,
											});
											if (!this.demuxer) {
												this.demuxer = new demux_demuxer(this.hls, "main");
											}
											this.state = State.FRAG_LOADING;
										} else if (fragState === FragmentState.APPENDING) {
											if (this._reduceMaxBufferLength(frag.duration)) {
												this.fragmentTracker.removeFragment(frag);
											}
										}
									};
									_proto.getBufferedFrag = function getBufferedFrag(position) {
										return this.fragmentTracker.getBufferedFrag(
											position,
											PlaylistLevelType.MAIN
										);
									};
									_proto.followingBufferedFrag = function followingBufferedFrag(
										frag
									) {
										if (frag) {
											return this.getBufferedFrag(frag.endPTS + 0.5);
										}
										return null;
									};
									_proto._checkFragmentChanged =
										function _checkFragmentChanged() {
											var fragPlayingCurrent,
												currentTime,
												video = this.media;
											if (
												video &&
												video.readyState &&
												video.seeking === false
											) {
												currentTime = video.currentTime;
												if (currentTime > this.lastCurrentTime) {
													this.lastCurrentTime = currentTime;
												}
												if (BufferHelper.isBuffered(video, currentTime)) {
													fragPlayingCurrent =
														this.getBufferedFrag(currentTime);
												} else if (
													BufferHelper.isBuffered(video, currentTime + 0.1)
												) {
													fragPlayingCurrent = this.getBufferedFrag(
														currentTime + 0.1
													);
												}
												if (fragPlayingCurrent) {
													var fragPlaying = fragPlayingCurrent;
													if (fragPlaying !== this.fragPlaying) {
														this.hls.trigger(events["default"].FRAG_CHANGED, {
															frag: fragPlaying,
														});
														var fragPlayingLevel = fragPlaying.level;
														if (
															!this.fragPlaying ||
															this.fragPlaying.level !== fragPlayingLevel
														) {
															this.hls.trigger(
																events["default"].LEVEL_SWITCHED,
																{ level: fragPlayingLevel }
															);
														}
														this.fragPlaying = fragPlaying;
													}
												}
											}
										};
									_proto.immediateLevelSwitch =
										function immediateLevelSwitch() {
											logger["logger"].log("immediateLevelSwitch");
											if (!this.immediateSwitch) {
												this.immediateSwitch = true;
												var media = this.media,
													previouslyPaused;
												if (media) {
													previouslyPaused = media.paused;
													if (!previouslyPaused) {
														media.pause();
													}
												} else {
													previouslyPaused = true;
												}
												this.previouslyPaused = previouslyPaused;
											}
											var fragCurrent = this.fragCurrent;
											if (fragCurrent && fragCurrent.loader) {
												fragCurrent.loader.abort();
											}
											this.fragCurrent = null;
											this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
										};
									_proto.immediateLevelSwitchEnd =
										function immediateLevelSwitchEnd() {
											var media = this.media;
											if (media && media.buffered.length) {
												this.immediateSwitch = false;
												if (
													media.currentTime > 0 &&
													BufferHelper.isBuffered(media, media.currentTime)
												) {
													media.currentTime -= 1e-4;
												}
												if (!this.previouslyPaused) {
													media.play();
												}
											}
										};
									_proto.nextLevelSwitch = function nextLevelSwitch() {
										var media = this.media;
										if (media && media.readyState) {
											var fetchdelay;
											var fragPlayingCurrent = this.getBufferedFrag(
												media.currentTime
											);
											if (
												fragPlayingCurrent &&
												fragPlayingCurrent.startPTS > 1
											) {
												this.flushMainBuffer(
													0,
													fragPlayingCurrent.startPTS - 1
												);
											}
											if (!media.paused) {
												var nextLevelId = this.hls.nextLoadLevel,
													nextLevel = this.levels[nextLevelId],
													fragLastKbps = this.fragLastKbps;
												if (fragLastKbps && this.fragCurrent) {
													fetchdelay =
														(this.fragCurrent.duration * nextLevel.bitrate) /
															(1e3 * fragLastKbps) +
														1;
												} else {
													fetchdelay = 0;
												}
											} else {
												fetchdelay = 0;
											}
											var bufferedFrag = this.getBufferedFrag(
												media.currentTime + fetchdelay
											);
											if (bufferedFrag) {
												var nextBufferedFrag =
													this.followingBufferedFrag(bufferedFrag);
												if (nextBufferedFrag) {
													var fragCurrent = this.fragCurrent;
													if (fragCurrent && fragCurrent.loader) {
														fragCurrent.loader.abort();
													}
													this.fragCurrent = null;
													var startPts = Math.max(
														bufferedFrag.endPTS,
														nextBufferedFrag.maxStartPTS +
															Math.min(
																this.config.maxFragLookUpTolerance,
																nextBufferedFrag.duration
															)
													);
													this.flushMainBuffer(
														startPts,
														Number.POSITIVE_INFINITY
													);
												}
											}
										}
									};
									_proto.flushMainBuffer = function flushMainBuffer(
										startOffset,
										endOffset
									) {
										this.state = State.BUFFER_FLUSHING;
										var flushScope = {
											startOffset: startOffset,
											endOffset: endOffset,
										};
										if (this.altAudio) {
											flushScope.type = "video";
										}
										this.hls.trigger(
											events["default"].BUFFER_FLUSHING,
											flushScope
										);
									};
									_proto.onMediaAttached = function onMediaAttached(data) {
										var media = (this.media = this.mediaBuffer = data.media);
										this.onvseeking = this.onMediaSeeking.bind(this);
										this.onvseeked = this.onMediaSeeked.bind(this);
										this.onvended = this.onMediaEnded.bind(this);
										media.addEventListener("seeking", this.onvseeking);
										media.addEventListener("seeked", this.onvseeked);
										media.addEventListener("ended", this.onvended);
										var config = this.config;
										if (this.levels && config.autoStartLoad) {
											this.hls.startLoad(config.startPosition);
										}
										this.gapController = new gap_controller_GapController(
											config,
											media,
											this.fragmentTracker,
											this.hls
										);
									};
									_proto.onMediaDetaching = function onMediaDetaching() {
										var media = this.media;
										if (media && media.ended) {
											logger["logger"].log(
												"MSE detaching and video ended, reset startPosition"
											);
											this.startPosition = this.lastCurrentTime = 0;
										}
										var levels = this.levels;
										if (levels) {
											levels.forEach(function (level) {
												if (level.details) {
													level.details.fragments.forEach(function (fragment) {
														fragment.backtracked = undefined;
													});
												}
											});
										}
										if (media) {
											media.removeEventListener("seeking", this.onvseeking);
											media.removeEventListener("seeked", this.onvseeked);
											media.removeEventListener("ended", this.onvended);
											this.onvseeking = this.onvseeked = this.onvended = null;
										}
										this.fragmentTracker.removeAllFragments();
										this.media = this.mediaBuffer = null;
										this.loadedmetadata = false;
										this.stopLoad();
									};
									_proto.onMediaSeeked = function onMediaSeeked() {
										var media = this.media;
										var currentTime = media ? media.currentTime : undefined;
										if (Object(number["isFiniteNumber"])(currentTime)) {
											logger["logger"].log(
												"media seeked to " + currentTime.toFixed(3)
											);
										}
										this.tick();
									};
									_proto.onManifestLoading = function onManifestLoading() {
										logger["logger"].log("trigger BUFFER_RESET");
										this.hls.trigger(events["default"].BUFFER_RESET);
										this.fragmentTracker.removeAllFragments();
										this.stalled = false;
										this.startPosition = this.lastCurrentTime = 0;
									};
									_proto.onManifestParsed = function onManifestParsed(data) {
										var aac = false,
											heaac = false,
											codec;
										data.levels.forEach(function (level) {
											codec = level.audioCodec;
											if (codec) {
												if (codec.indexOf("mp4a.40.2") !== -1) {
													aac = true;
												}
												if (codec.indexOf("mp4a.40.5") !== -1) {
													heaac = true;
												}
											}
										});
										this.audioCodecSwitch = aac && heaac;
										if (this.audioCodecSwitch) {
											logger["logger"].log(
												"both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"
											);
										}
										this.altAudio = data.altAudio;
										this.levels = data.levels;
										this.startFragRequested = false;
										var config = this.config;
										if (config.autoStartLoad || this.forceStartLoad) {
											this.hls.startLoad(config.startPosition);
										}
									};
									_proto.onLevelLoaded = function onLevelLoaded(data) {
										var newDetails = data.details;
										var newLevelId = data.level;
										var lastLevel = this.levels[this.levelLastLoaded];
										var curLevel = this.levels[newLevelId];
										var duration = newDetails.totalduration;
										var sliding = 0;
										logger["logger"].log(
											"level " +
												newLevelId +
												" loaded [" +
												newDetails.startSN +
												"," +
												newDetails.endSN +
												"],duration:" +
												duration
										);
										if (
											newDetails.live ||
											(curLevel.details && curLevel.details.live)
										) {
											var curDetails = curLevel.details;
											if (curDetails && newDetails.fragments.length > 0) {
												mergeDetails(curDetails, newDetails);
												sliding = newDetails.fragments[0].start;
												this.liveSyncPosition = this.computeLivePosition(
													sliding,
													curDetails
												);
												if (
													newDetails.PTSKnown &&
													Object(number["isFiniteNumber"])(sliding)
												) {
													logger["logger"].log(
														"live playlist sliding:" + sliding.toFixed(3)
													);
												} else {
													logger["logger"].log(
														"live playlist - outdated PTS, unknown sliding"
													);
													alignStream(this.fragPrevious, lastLevel, newDetails);
												}
											} else {
												logger["logger"].log(
													"live playlist - first load, unknown sliding"
												);
												newDetails.PTSKnown = false;
												alignStream(this.fragPrevious, lastLevel, newDetails);
											}
										} else {
											newDetails.PTSKnown = false;
										}
										curLevel.details = newDetails;
										this.levelLastLoaded = newLevelId;
										this.hls.trigger(events["default"].LEVEL_UPDATED, {
											details: newDetails,
											level: newLevelId,
										});
										if (this.startFragRequested === false) {
											if (
												this.startPosition === -1 ||
												this.lastCurrentTime === -1
											) {
												var startTimeOffset = newDetails.startTimeOffset;
												if (Object(number["isFiniteNumber"])(startTimeOffset)) {
													if (startTimeOffset < 0) {
														logger["logger"].log(
															"negative start time offset " +
																startTimeOffset +
																", count from end of last fragment"
														);
														startTimeOffset =
															sliding + duration + startTimeOffset;
													}
													logger["logger"].log(
														"start time offset found in playlist, adjust startPosition to " +
															startTimeOffset
													);
													this.startPosition = startTimeOffset;
												} else {
													if (newDetails.live) {
														this.startPosition = this.computeLivePosition(
															sliding,
															newDetails
														);
														logger["logger"].log(
															"configure startPosition to " + this.startPosition
														);
													} else {
														this.startPosition = 0;
													}
												}
												this.lastCurrentTime = this.startPosition;
											}
											this.nextLoadPosition = this.startPosition;
										}
										if (this.state === State.WAITING_LEVEL) {
											this.state = State.IDLE;
										}
										this.tick();
									};
									_proto.onKeyLoaded = function onKeyLoaded() {
										if (this.state === State.KEY_LOADING) {
											this.state = State.IDLE;
											this.tick();
										}
									};
									_proto.onFragLoaded = function onFragLoaded(data) {
										var fragCurrent = this.fragCurrent,
											hls = this.hls,
											levels = this.levels,
											media = this.media;
										var fragLoaded = data.frag;
										if (
											this.state === State.FRAG_LOADING &&
											fragCurrent &&
											fragLoaded.type === "main" &&
											fragLoaded.level === fragCurrent.level &&
											fragLoaded.sn === fragCurrent.sn
										) {
											var stats = data.stats;
											var currentLevel = levels[fragCurrent.level];
											var details = currentLevel.details;
											this.bitrateTest = false;
											this.stats = stats;
											logger["logger"].log(
												"Loaded " +
													fragCurrent.sn +
													" of [" +
													details.startSN +
													" ," +
													details.endSN +
													"],level " +
													fragCurrent.level
											);
											if (fragLoaded.bitrateTest && hls.nextLoadLevel) {
												this.state = State.IDLE;
												this.startFragRequested = false;
												stats.tparsed = stats.tbuffered =
													window.performance.now();
												hls.trigger(events["default"].FRAG_BUFFERED, {
													stats: stats,
													frag: fragCurrent,
													id: "main",
												});
												this.tick();
											} else if (fragLoaded.sn === "initSegment") {
												this.state = State.IDLE;
												stats.tparsed = stats.tbuffered =
													window.performance.now();
												details.initSegment.data = data.payload;
												hls.trigger(events["default"].FRAG_BUFFERED, {
													stats: stats,
													frag: fragCurrent,
													id: "main",
												});
												this.tick();
											} else {
												logger["logger"].log(
													"Parsing " +
														fragCurrent.sn +
														" of [" +
														details.startSN +
														" ," +
														details.endSN +
														"],level " +
														fragCurrent.level +
														", cc " +
														fragCurrent.cc
												);
												this.state = State.PARSING;
												this.pendingBuffering = true;
												this.appended = false;
												if (fragLoaded.bitrateTest) {
													fragLoaded.bitrateTest = false;
													this.fragmentTracker.onFragLoaded({
														frag: fragLoaded,
													});
												}
												var accurateTimeOffset =
													!(media && media.seeking) &&
													(details.PTSKnown || !details.live);
												var initSegmentData = details.initSegment
													? details.initSegment.data
													: [];
												var audioCodec = this._getAudioCodec(currentLevel);
												var demuxer = (this.demuxer =
													this.demuxer || new demux_demuxer(this.hls, "main"));
												demuxer.push(
													data.payload,
													initSegmentData,
													audioCodec,
													currentLevel.videoCodec,
													fragCurrent,
													details.totalduration,
													accurateTimeOffset
												);
											}
										}
										this.fragLoadError = 0;
									};
									_proto.onFragParsingInitSegment =
										function onFragParsingInitSegment(data) {
											var fragCurrent = this.fragCurrent;
											var fragNew = data.frag;
											if (
												fragCurrent &&
												data.id === "main" &&
												fragNew.sn === fragCurrent.sn &&
												fragNew.level === fragCurrent.level &&
												this.state === State.PARSING
											) {
												var tracks = data.tracks,
													trackName,
													track;
												this.audioOnly = tracks.audio && !tracks.video;
												if (this.altAudio && !this.audioOnly) {
													delete tracks.audio;
												}
												track = tracks.audio;
												if (track) {
													var audioCodec = this.levels[this.level].audioCodec,
														ua = navigator.userAgent.toLowerCase();
													if (audioCodec && this.audioCodecSwap) {
														logger["logger"].log(
															"swapping playlist audio codec"
														);
														if (audioCodec.indexOf("mp4a.40.5") !== -1) {
															audioCodec = "mp4a.40.2";
														} else {
															audioCodec = "mp4a.40.5";
														}
													}
													if (this.audioCodecSwitch) {
														if (
															track.metadata.channelCount !== 1 &&
															ua.indexOf("firefox") === -1
														) {
															audioCodec = "mp4a.40.5";
														}
													}
													if (
														ua.indexOf("android") !== -1 &&
														track.container !== "audio/mpeg"
													) {
														audioCodec = "mp4a.40.2";
														logger["logger"].log(
															"Android: force audio codec to " + audioCodec
														);
													}
													track.levelCodec = audioCodec;
													track.id = data.id;
												}
												track = tracks.video;
												if (track) {
													track.levelCodec = this.levels[this.level].videoCodec;
													track.id = data.id;
												}
												this.hls.trigger(
													events["default"].BUFFER_CODECS,
													tracks
												);
												for (trackName in tracks) {
													track = tracks[trackName];
													logger["logger"].log(
														"main track:" +
															trackName +
															",container:" +
															track.container +
															",codecs[level/parsed]=[" +
															track.levelCodec +
															"/" +
															track.codec +
															"]"
													);
													var initSegment = track.initSegment;
													if (initSegment) {
														this.appended = true;
														this.pendingBuffering = true;
														this.hls.trigger(
															events["default"].BUFFER_APPENDING,
															{
																type: trackName,
																data: initSegment,
																parent: "main",
																content: "initSegment",
															}
														);
													}
												}
												this.tick();
											}
										};
									_proto.onFragParsingData = function onFragParsingData(data) {
										var _this2 = this;
										var fragCurrent = this.fragCurrent;
										var fragNew = data.frag;
										if (
											fragCurrent &&
											data.id === "main" &&
											fragNew.sn === fragCurrent.sn &&
											fragNew.level === fragCurrent.level &&
											!(data.type === "audio" && this.altAudio) &&
											this.state === State.PARSING
										) {
											var level = this.levels[this.level],
												frag = fragCurrent;
											if (!Object(number["isFiniteNumber"])(data.endPTS)) {
												data.endPTS = data.startPTS + fragCurrent.duration;
												data.endDTS = data.startDTS + fragCurrent.duration;
											}
											if (data.hasAudio === true) {
												frag.addElementaryStream(ElementaryStreamTypes.AUDIO);
											}
											if (data.hasVideo === true) {
												frag.addElementaryStream(ElementaryStreamTypes.VIDEO);
											}
											logger["logger"].log(
												"Parsed " +
													data.type +
													",PTS:[" +
													data.startPTS.toFixed(3) +
													"," +
													data.endPTS.toFixed(3) +
													"],DTS:[" +
													data.startDTS.toFixed(3) +
													"/" +
													data.endDTS.toFixed(3) +
													"],nb:" +
													data.nb +
													",dropped:" +
													(data.dropped || 0)
											);
											if (data.type === "video") {
												frag.dropped = data.dropped;
												if (frag.dropped) {
													if (!frag.backtracked) {
														var levelDetails = level.details;
														if (
															levelDetails &&
															frag.sn === levelDetails.startSN
														) {
															logger["logger"].warn(
																"missing video frame(s) on first frag, appending with gap",
																frag.sn
															);
														} else {
															logger["logger"].warn(
																"missing video frame(s), backtracking fragment",
																frag.sn
															);
															this.fragmentTracker.removeFragment(frag);
															frag.backtracked = true;
															this.nextLoadPosition = data.startPTS;
															this.state = State.IDLE;
															this.fragPrevious = frag;
															if (this.demuxer) {
																this.demuxer.destroy();
																this.demuxer = null;
															}
															this.tick();
															return;
														}
													} else {
														logger["logger"].warn(
															"Already backtracked on this fragment, appending with the gap",
															frag.sn
														);
													}
												} else {
													frag.backtracked = false;
												}
											}
											var drift = updateFragPTSDTS(
													level.details,
													frag,
													data.startPTS,
													data.endPTS,
													data.startDTS,
													data.endDTS
												),
												hls = this.hls;
											hls.trigger(events["default"].LEVEL_PTS_UPDATED, {
												details: level.details,
												level: this.level,
												drift: drift,
												type: data.type,
												start: data.startPTS,
												end: data.endPTS,
											});
											[data.data1, data.data2].forEach(function (buffer) {
												if (
													buffer &&
													buffer.length &&
													_this2.state === State.PARSING
												) {
													_this2.appended = true;
													_this2.pendingBuffering = true;
													hls.trigger(events["default"].BUFFER_APPENDING, {
														type: data.type,
														data: buffer,
														parent: "main",
														content: "data",
													});
												}
											});
											this.tick();
										}
									};
									_proto.onFragParsed = function onFragParsed(data) {
										var fragCurrent = this.fragCurrent;
										var fragNew = data.frag;
										if (
											fragCurrent &&
											data.id === "main" &&
											fragNew.sn === fragCurrent.sn &&
											fragNew.level === fragCurrent.level &&
											this.state === State.PARSING
										) {
											this.stats.tparsed = window.performance.now();
											this.state = State.PARSED;
											this._checkAppendedParsed();
										}
									};
									_proto.onAudioTrackSwitching = function onAudioTrackSwitching(
										data
									) {
										var fromAltAudio = this.altAudio;
										var altAudio = !!data.url;
										var trackId = data.id;
										if (!altAudio) {
											if (this.mediaBuffer !== this.media) {
												logger["logger"].log(
													"switching on main audio, use media.buffered to schedule main fragment loading"
												);
												this.mediaBuffer = this.media;
												var fragCurrent = this.fragCurrent;
												if (fragCurrent.loader) {
													logger["logger"].log(
														"switching to main audio track, cancel main fragment load"
													);
													fragCurrent.loader.abort();
												}
												this.fragCurrent = null;
												this.fragPrevious = null;
												if (this.demuxer) {
													this.demuxer.destroy();
													this.demuxer = null;
												}
												this.state = State.IDLE;
											}
											var hls = this.hls;
											if (fromAltAudio) {
												hls.trigger(events["default"].BUFFER_FLUSHING, {
													startOffset: 0,
													endOffset: Number.POSITIVE_INFINITY,
													type: "audio",
												});
											}
											hls.trigger(events["default"].AUDIO_TRACK_SWITCHED, {
												id: trackId,
											});
										}
									};
									_proto.onAudioTrackSwitched = function onAudioTrackSwitched(
										data
									) {
										var trackId = data.id,
											altAudio = !!this.hls.audioTracks[trackId].url;
										if (altAudio) {
											var videoBuffer = this.videoBuffer;
											if (videoBuffer && this.mediaBuffer !== videoBuffer) {
												logger["logger"].log(
													"switching on alternate audio, use video.buffered to schedule main fragment loading"
												);
												this.mediaBuffer = videoBuffer;
											}
										}
										this.altAudio = altAudio;
										this.tick();
									};
									_proto.onBufferCreated = function onBufferCreated(data) {
										var tracks = data.tracks,
											mediaTrack,
											name,
											alternate = false;
										for (var type in tracks) {
											var track = tracks[type];
											if (track.id === "main") {
												name = type;
												mediaTrack = track;
												if (type === "video") {
													this.videoBuffer = tracks[type].buffer;
												}
											} else {
												alternate = true;
											}
										}
										if (alternate && mediaTrack) {
											logger["logger"].log(
												"alternate track found, use " +
													name +
													".buffered to schedule main fragment loading"
											);
											this.mediaBuffer = mediaTrack.buffer;
										} else {
											this.mediaBuffer = this.media;
										}
									};
									_proto.onBufferAppended = function onBufferAppended(data) {
										if (data.parent === "main") {
											var state = this.state;
											if (state === State.PARSING || state === State.PARSED) {
												this.pendingBuffering = data.pending > 0;
												this._checkAppendedParsed();
											}
										}
									};
									_proto._checkAppendedParsed =
										function _checkAppendedParsed() {
											if (
												this.state === State.PARSED &&
												(!this.appended || !this.pendingBuffering)
											) {
												var frag = this.fragCurrent;
												if (frag) {
													var media = this.mediaBuffer
														? this.mediaBuffer
														: this.media;
													logger["logger"].log(
														"main buffered : " +
															time_ranges.toString(media.buffered)
													);
													this.fragPrevious = frag;
													var stats = this.stats;
													stats.tbuffered = window.performance.now();
													this.fragLastKbps = Math.round(
														(8 * stats.total) / (stats.tbuffered - stats.tfirst)
													);
													this.hls.trigger(events["default"].FRAG_BUFFERED, {
														stats: stats,
														frag: frag,
														id: "main",
													});
													this.state = State.IDLE;
												}
												if (this.loadedmetadata || this.startPosition <= 0) {
													this.tick();
												}
											}
										};
									_proto.onError = function onError(data) {
										var frag = data.frag || this.fragCurrent;
										if (frag && frag.type !== "main") {
											return;
										}
										var mediaBuffered =
											!!this.media &&
											BufferHelper.isBuffered(
												this.media,
												this.media.currentTime
											) &&
											BufferHelper.isBuffered(
												this.media,
												this.media.currentTime + 0.5
											);
										switch (data.details) {
											case errors["ErrorDetails"].FRAG_LOAD_ERROR:
											case errors["ErrorDetails"].FRAG_LOAD_TIMEOUT:
											case errors["ErrorDetails"].KEY_LOAD_ERROR:
											case errors["ErrorDetails"].KEY_LOAD_TIMEOUT:
												if (!data.fatal) {
													if (
														this.fragLoadError + 1 <=
														this.config.fragLoadingMaxRetry
													) {
														var delay = Math.min(
															Math.pow(2, this.fragLoadError) *
																this.config.fragLoadingRetryDelay,
															this.config.fragLoadingMaxRetryTimeout
														);
														logger["logger"].warn(
															"mediaController: frag loading failed, retry in " +
																delay +
																" ms"
														);
														this.retryDate = window.performance.now() + delay;
														if (!this.loadedmetadata) {
															this.startFragRequested = false;
															this.nextLoadPosition = this.startPosition;
														}
														this.fragLoadError++;
														this.state = State.FRAG_LOADING_WAITING_RETRY;
													} else {
														logger["logger"].error(
															"mediaController: " +
																data.details +
																" reaches max retry, redispatch as fatal ..."
														);
														data.fatal = true;
														this.state = State.ERROR;
													}
												}
												break;
											case errors["ErrorDetails"].LEVEL_LOAD_ERROR:
											case errors["ErrorDetails"].LEVEL_LOAD_TIMEOUT:
												if (this.state !== State.ERROR) {
													if (data.fatal) {
														this.state = State.ERROR;
														logger["logger"].warn(
															"streamController: " +
																data.details +
																",switch to " +
																this.state +
																" state ..."
														);
													} else {
														if (
															!data.levelRetry &&
															this.state === State.WAITING_LEVEL
														) {
															this.state = State.IDLE;
														}
													}
												}
												break;
											case errors["ErrorDetails"].BUFFER_FULL_ERROR:
												if (
													data.parent === "main" &&
													(this.state === State.PARSING ||
														this.state === State.PARSED)
												) {
													if (mediaBuffered) {
														this._reduceMaxBufferLength(
															this.config.maxBufferLength
														);
														this.state = State.IDLE;
													} else {
														logger["logger"].warn(
															"buffer full error also media.currentTime is not buffered, flush everything"
														);
														this.fragCurrent = null;
														this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
													}
												}
												break;
											default:
												break;
										}
									};
									_proto._reduceMaxBufferLength =
										function _reduceMaxBufferLength(minLength) {
											var config = this.config;
											if (config.maxMaxBufferLength >= minLength) {
												config.maxMaxBufferLength /= 2;
												logger["logger"].warn(
													"main:reduce max buffer length to " +
														config.maxMaxBufferLength +
														"s"
												);
												return true;
											}
											return false;
										};
									_proto._checkBuffer = function _checkBuffer() {
										var media = this.media;
										if (!media || media.readyState === 0) {
											return;
										}
										var mediaBuffer = this.mediaBuffer
											? this.mediaBuffer
											: media;
										var buffered = mediaBuffer.buffered;
										if (!this.loadedmetadata && buffered.length) {
											this.loadedmetadata = true;
											this._seekToStartPos();
										} else if (this.immediateSwitch) {
											this.immediateLevelSwitchEnd();
										} else {
											this.gapController.poll(this.lastCurrentTime, buffered);
										}
									};
									_proto.onFragLoadEmergencyAborted =
										function onFragLoadEmergencyAborted() {
											this.state = State.IDLE;
											if (!this.loadedmetadata) {
												this.startFragRequested = false;
												this.nextLoadPosition = this.startPosition;
											}
											this.tick();
										};
									_proto.onBufferFlushed = function onBufferFlushed() {
										var media = this.mediaBuffer
											? this.mediaBuffer
											: this.media;
										if (media) {
											var elementaryStreamType = this.audioOnly
												? ElementaryStreamTypes.AUDIO
												: ElementaryStreamTypes.VIDEO;
											this.fragmentTracker.detectEvictedFragments(
												elementaryStreamType,
												media.buffered
											);
										}
										this.state = State.IDLE;
										this.fragPrevious = null;
									};
									_proto.onLevelsUpdated = function onLevelsUpdated(data) {
										this.levels = data.levels;
									};
									_proto.swapAudioCodec = function swapAudioCodec() {
										this.audioCodecSwap = !this.audioCodecSwap;
									};
									_proto._seekToStartPos = function _seekToStartPos() {
										var media = this.media;
										var currentTime = media.currentTime;
										var startPosition = this.startPosition;
										if (currentTime !== startPosition && startPosition >= 0) {
											if (media.seeking) {
												logger["logger"].log(
													"could not seek to " +
														startPosition +
														", already seeking at " +
														currentTime
												);
												return;
											}
											var bufferStart = media.buffered.length
												? media.buffered.start(0)
												: 0;
											var delta = bufferStart - startPosition;
											if (delta > 0 && delta < this.config.maxBufferHole) {
												logger["logger"].log(
													"adjusting start position by " +
														delta +
														" to match buffer start"
												);
												startPosition += delta;
												this.startPosition = startPosition;
											}
											logger["logger"].log(
												"seek to target start position " +
													startPosition +
													" from current time " +
													currentTime +
													". ready state " +
													media.readyState
											);
											media.currentTime = startPosition;
										}
									};
									_proto._getAudioCodec = function _getAudioCodec(
										currentLevel
									) {
										var audioCodec =
											this.config.defaultAudioCodec || currentLevel.audioCodec;
										if (this.audioCodecSwap) {
											logger["logger"].log("swapping playlist audio codec");
											if (audioCodec) {
												if (audioCodec.indexOf("mp4a.40.5") !== -1) {
													audioCodec = "mp4a.40.2";
												} else {
													audioCodec = "mp4a.40.5";
												}
											}
										}
										return audioCodec;
									};
									stream_controller_createClass(StreamController, [
										{
											key: "state",
											set: function set(nextState) {
												if (this.state !== nextState) {
													var previousState = this.state;
													this._state = nextState;
													logger["logger"].log(
														"main stream-controller: " +
															previousState +
															"->" +
															nextState
													);
													this.hls.trigger(
														events["default"].STREAM_STATE_TRANSITION,
														{
															previousState: previousState,
															nextState: nextState,
														}
													);
												}
											},
											get: function get() {
												return this._state;
											},
										},
										{
											key: "currentLevel",
											get: function get() {
												var media = this.media;
												if (media) {
													var frag = this.getBufferedFrag(media.currentTime);
													if (frag) {
														return frag.level;
													}
												}
												return -1;
											},
										},
										{
											key: "nextBufferedFrag",
											get: function get() {
												var media = this.media;
												if (media) {
													return this.followingBufferedFrag(
														this.getBufferedFrag(media.currentTime)
													);
												} else {
													return null;
												}
											},
										},
										{
											key: "nextLevel",
											get: function get() {
												var frag = this.nextBufferedFrag;
												if (frag) {
													return frag.level;
												} else {
													return -1;
												}
											},
										},
										{
											key: "liveSyncPosition",
											get: function get() {
												return this._liveSyncPosition;
											},
											set: function set(value) {
												this._liveSyncPosition = value;
											},
										},
									]);
									return StreamController;
								})(base_stream_controller_BaseStreamController);
								var stream_controller = stream_controller_StreamController;
								function level_controller_defineProperties(target, props) {
									for (var i = 0; i < props.length; i++) {
										var descriptor = props[i];
										descriptor.enumerable = descriptor.enumerable || false;
										descriptor.configurable = true;
										if ("value" in descriptor) descriptor.writable = true;
										Object.defineProperty(target, descriptor.key, descriptor);
									}
								}
								function level_controller_createClass(
									Constructor,
									protoProps,
									staticProps
								) {
									if (protoProps)
										level_controller_defineProperties(
											Constructor.prototype,
											protoProps
										);
									if (staticProps)
										level_controller_defineProperties(Constructor, staticProps);
									return Constructor;
								}
								function level_controller_inheritsLoose(subClass, superClass) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var chromeOrFirefox;
								var level_controller_LevelController = (function (
									_EventHandler
								) {
									level_controller_inheritsLoose(
										LevelController,
										_EventHandler
									);
									function LevelController(hls) {
										var _this;
										_this =
											_EventHandler.call(
												this,
												hls,
												events["default"].MANIFEST_LOADED,
												events["default"].LEVEL_LOADED,
												events["default"].AUDIO_TRACK_SWITCHED,
												events["default"].FRAG_LOADED,
												events["default"].ERROR
											) || this;
										_this.canload = false;
										_this.currentLevelIndex = null;
										_this.manualLevelIndex = -1;
										_this.timer = null;
										chromeOrFirefox = /chrome|firefox/.test(
											navigator.userAgent.toLowerCase()
										);
										return _this;
									}
									var _proto = LevelController.prototype;
									_proto.onHandlerDestroying = function onHandlerDestroying() {
										this.clearTimer();
										this.manualLevelIndex = -1;
									};
									_proto.clearTimer = function clearTimer() {
										if (this.timer !== null) {
											clearTimeout(this.timer);
											this.timer = null;
										}
									};
									_proto.startLoad = function startLoad() {
										var levels = this._levels;
										this.canload = true;
										this.levelRetryCount = 0;
										if (levels) {
											levels.forEach(function (level) {
												level.loadError = 0;
												var levelDetails = level.details;
												if (levelDetails && levelDetails.live) {
													level.details = undefined;
												}
											});
										}
										if (this.timer !== null) {
											this.loadLevel();
										}
									};
									_proto.stopLoad = function stopLoad() {
										this.canload = false;
									};
									_proto.onManifestLoaded = function onManifestLoaded(data) {
										var levels = [];
										var audioTracks = [];
										var bitrateStart;
										var levelSet = {};
										var levelFromSet = null;
										var videoCodecFound = false;
										var audioCodecFound = false;
										data.levels.forEach(function (level) {
											var attributes = level.attrs;
											level.loadError = 0;
											level.fragmentError = false;
											videoCodecFound = videoCodecFound || !!level.videoCodec;
											audioCodecFound = audioCodecFound || !!level.audioCodec;
											if (
												chromeOrFirefox &&
												level.audioCodec &&
												level.audioCodec.indexOf("mp4a.40.34") !== -1
											) {
												level.audioCodec = undefined;
											}
											levelFromSet = levelSet[level.bitrate];
											if (!levelFromSet) {
												level.url = [level.url];
												level.urlId = 0;
												levelSet[level.bitrate] = level;
												levels.push(level);
											} else {
												levelFromSet.url.push(level.url);
											}
											if (attributes) {
												if (attributes.AUDIO) {
													addGroupId(
														levelFromSet || level,
														"audio",
														attributes.AUDIO
													);
												}
												if (attributes.SUBTITLES) {
													addGroupId(
														levelFromSet || level,
														"text",
														attributes.SUBTITLES
													);
												}
											}
										});
										if (videoCodecFound && audioCodecFound) {
											levels = levels.filter(function (_ref) {
												var videoCodec = _ref.videoCodec;
												return !!videoCodec;
											});
										}
										levels = levels.filter(function (_ref2) {
											var audioCodec = _ref2.audioCodec,
												videoCodec = _ref2.videoCodec;
											return (
												(!audioCodec ||
													isCodecSupportedInMp4(audioCodec, "audio")) &&
												(!videoCodec ||
													isCodecSupportedInMp4(videoCodec, "video"))
											);
										});
										if (data.audioTracks) {
											audioTracks = data.audioTracks.filter(function (track) {
												return (
													!track.audioCodec ||
													isCodecSupportedInMp4(track.audioCodec, "audio")
												);
											});
											audioTracks.forEach(function (track, index) {
												track.id = index;
											});
										}
										if (levels.length > 0) {
											bitrateStart = levels[0].bitrate;
											levels.sort(function (a, b) {
												return a.bitrate - b.bitrate;
											});
											this._levels = levels;
											for (var i = 0; i < levels.length; i++) {
												if (levels[i].bitrate === bitrateStart) {
													this._firstLevel = i;
													logger["logger"].log(
														"manifest loaded," +
															levels.length +
															" level(s) found, first bitrate:" +
															bitrateStart
													);
													break;
												}
											}
											var audioOnly = audioCodecFound && !videoCodecFound;
											this.hls.trigger(events["default"].MANIFEST_PARSED, {
												levels: levels,
												audioTracks: audioTracks,
												firstLevel: this._firstLevel,
												stats: data.stats,
												audio: audioCodecFound,
												video: videoCodecFound,
												altAudio:
													!audioOnly &&
													audioTracks.some(function (t) {
														return !!t.url;
													}),
											});
										} else {
											this.hls.trigger(events["default"].ERROR, {
												type: errors["ErrorTypes"].MEDIA_ERROR,
												details:
													errors["ErrorDetails"]
														.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
												fatal: true,
												url: this.hls.url,
												reason:
													"no level with compatible codecs found in manifest",
											});
										}
									};
									_proto.setLevelInternal = function setLevelInternal(
										newLevel
									) {
										var levels = this._levels;
										var hls = this.hls;
										if (newLevel >= 0 && newLevel < levels.length) {
											this.clearTimer();
											if (this.currentLevelIndex !== newLevel) {
												logger["logger"].log("switching to level " + newLevel);
												this.currentLevelIndex = newLevel;
												var levelProperties = levels[newLevel];
												levelProperties.level = newLevel;
												hls.trigger(
													events["default"].LEVEL_SWITCHING,
													levelProperties
												);
											}
											var level = levels[newLevel];
											var levelDetails = level.details;
											if (!levelDetails || levelDetails.live) {
												var urlId = level.urlId;
												hls.trigger(events["default"].LEVEL_LOADING, {
													url: level.url[urlId],
													level: newLevel,
													id: urlId,
												});
											}
										} else {
											hls.trigger(events["default"].ERROR, {
												type: errors["ErrorTypes"].OTHER_ERROR,
												details: errors["ErrorDetails"].LEVEL_SWITCH_ERROR,
												level: newLevel,
												fatal: false,
												reason: "invalid level idx",
											});
										}
									};
									_proto.onError = function onError(data) {
										if (data.fatal) {
											if (data.type === errors["ErrorTypes"].NETWORK_ERROR) {
												this.clearTimer();
											}
											return;
										}
										var levelError = false,
											fragmentError = false;
										var levelIndex;
										switch (data.details) {
											case errors["ErrorDetails"].FRAG_LOAD_ERROR:
											case errors["ErrorDetails"].FRAG_LOAD_TIMEOUT:
											case errors["ErrorDetails"].KEY_LOAD_ERROR:
											case errors["ErrorDetails"].KEY_LOAD_TIMEOUT:
												levelIndex = data.frag.level;
												fragmentError = true;
												break;
											case errors["ErrorDetails"].LEVEL_LOAD_ERROR:
											case errors["ErrorDetails"].LEVEL_LOAD_TIMEOUT:
												levelIndex = data.context.level;
												levelError = true;
												break;
											case errors["ErrorDetails"].REMUX_ALLOC_ERROR:
												levelIndex = data.level;
												levelError = true;
												break;
										}
										if (levelIndex !== undefined) {
											this.recoverLevel(
												data,
												levelIndex,
												levelError,
												fragmentError
											);
										}
									};
									_proto.recoverLevel = function recoverLevel(
										errorEvent,
										levelIndex,
										levelError,
										fragmentError
									) {
										var _this2 = this;
										var config = this.hls.config;
										var errorDetails = errorEvent.details;
										var level = this._levels[levelIndex];
										var redundantLevels, delay, nextLevel;
										level.loadError++;
										level.fragmentError = fragmentError;
										if (levelError) {
											if (
												this.levelRetryCount + 1 <=
												config.levelLoadingMaxRetry
											) {
												delay = Math.min(
													Math.pow(2, this.levelRetryCount) *
														config.levelLoadingRetryDelay,
													config.levelLoadingMaxRetryTimeout
												);
												this.timer = setTimeout(function () {
													return _this2.loadLevel();
												}, delay);
												errorEvent.levelRetry = true;
												this.levelRetryCount++;
												logger["logger"].warn(
													"level controller, " +
														errorDetails +
														", retry in " +
														delay +
														" ms, current retry count is " +
														this.levelRetryCount
												);
											} else {
												logger["logger"].error(
													"level controller, cannot recover from " +
														errorDetails +
														" error"
												);
												this.currentLevelIndex = null;
												this.clearTimer();
												errorEvent.fatal = true;
												return;
											}
										}
										if (levelError || fragmentError) {
											redundantLevels = level.url.length;
											if (
												redundantLevels > 1 &&
												level.loadError < redundantLevels
											) {
												level.urlId = (level.urlId + 1) % redundantLevels;
												level.details = undefined;
												logger["logger"].warn(
													"level controller, " +
														errorDetails +
														" for level " +
														levelIndex +
														": switching to redundant URL-id " +
														level.urlId
												);
											} else {
												if (this.manualLevelIndex === -1) {
													nextLevel =
														levelIndex === 0
															? this._levels.length - 1
															: levelIndex - 1;
													logger["logger"].warn(
														"level controller, " +
															errorDetails +
															": switch to " +
															nextLevel
													);
													this.hls.nextAutoLevel = this.currentLevelIndex =
														nextLevel;
												} else if (fragmentError) {
													logger["logger"].warn(
														"level controller, " +
															errorDetails +
															": reload a fragment"
													);
													this.currentLevelIndex = null;
												}
											}
										}
									};
									_proto.onFragLoaded = function onFragLoaded(_ref3) {
										var frag = _ref3.frag;
										if (frag !== undefined && frag.type === "main") {
											var level = this._levels[frag.level];
											if (level !== undefined) {
												level.fragmentError = false;
												level.loadError = 0;
												this.levelRetryCount = 0;
											}
										}
									};
									_proto.onLevelLoaded = function onLevelLoaded(data) {
										var _this3 = this;
										var level = data.level,
											details = data.details;
										if (level !== this.currentLevelIndex) {
											return;
										}
										var curLevel = this._levels[level];
										if (!curLevel.fragmentError) {
											curLevel.loadError = 0;
											this.levelRetryCount = 0;
										}
										if (details.live) {
											var reloadInterval = computeReloadInterval(
												curLevel.details,
												details,
												data.stats.trequest
											);
											logger["logger"].log(
												"live playlist, reload in " +
													Math.round(reloadInterval) +
													" ms"
											);
											this.timer = setTimeout(function () {
												return _this3.loadLevel();
											}, reloadInterval);
										} else {
											this.clearTimer();
										}
									};
									_proto.onAudioTrackSwitched = function onAudioTrackSwitched(
										data
									) {
										var audioGroupId = this.hls.audioTracks[data.id].groupId;
										var currentLevel = this.hls.levels[this.currentLevelIndex];
										if (!currentLevel) {
											return;
										}
										if (currentLevel.audioGroupIds) {
											var urlId = -1;
											for (
												var i = 0;
												i < currentLevel.audioGroupIds.length;
												i++
											) {
												if (currentLevel.audioGroupIds[i] === audioGroupId) {
													urlId = i;
													break;
												}
											}
											if (urlId !== currentLevel.urlId) {
												currentLevel.urlId = urlId;
												this.startLoad();
											}
										}
									};
									_proto.loadLevel = function loadLevel() {
										logger["logger"].debug("call to loadLevel");
										if (this.currentLevelIndex !== null && this.canload) {
											var levelObject = this._levels[this.currentLevelIndex];
											if (
												typeof levelObject === "object" &&
												levelObject.url.length > 0
											) {
												var level = this.currentLevelIndex;
												var id = levelObject.urlId;
												var url = levelObject.url[id];
												logger["logger"].log(
													"Attempt loading level index " +
														level +
														" with URL-id " +
														id
												);
												this.hls.trigger(events["default"].LEVEL_LOADING, {
													url: url,
													level: level,
													id: id,
												});
											}
										}
									};
									_proto.removeLevel = function removeLevel(levelIndex, urlId) {
										var levels = this.levels
											.filter(function (level, index) {
												if (index !== levelIndex) {
													return true;
												}
												if (level.url.length > 1 && urlId !== undefined) {
													level.url = level.url.filter(function (url, id) {
														return id !== urlId;
													});
													level.urlId = 0;
													return true;
												}
												return false;
											})
											.map(function (level, index) {
												var details = level.details;
												if (details && details.fragments) {
													details.fragments.forEach(function (fragment) {
														fragment.level = index;
													});
												}
												return level;
											});
										this._levels = levels;
										this.hls.trigger(events["default"].LEVELS_UPDATED, {
											levels: levels,
										});
									};
									level_controller_createClass(LevelController, [
										{
											key: "levels",
											get: function get() {
												return this._levels;
											},
										},
										{
											key: "level",
											get: function get() {
												return this.currentLevelIndex;
											},
											set: function set(newLevel) {
												var levels = this._levels;
												if (levels) {
													newLevel = Math.min(newLevel, levels.length - 1);
													if (
														this.currentLevelIndex !== newLevel ||
														!levels[newLevel].details
													) {
														this.setLevelInternal(newLevel);
													}
												}
											},
										},
										{
											key: "manualLevel",
											get: function get() {
												return this.manualLevelIndex;
											},
											set: function set(newLevel) {
												this.manualLevelIndex = newLevel;
												if (this._startLevel === undefined) {
													this._startLevel = newLevel;
												}
												if (newLevel !== -1) {
													this.level = newLevel;
												}
											},
										},
										{
											key: "firstLevel",
											get: function get() {
												return this._firstLevel;
											},
											set: function set(newLevel) {
												this._firstLevel = newLevel;
											},
										},
										{
											key: "startLevel",
											get: function get() {
												if (this._startLevel === undefined) {
													var configStartLevel = this.hls.config.startLevel;
													if (configStartLevel !== undefined) {
														return configStartLevel;
													} else {
														return this._firstLevel;
													}
												} else {
													return this._startLevel;
												}
											},
											set: function set(newLevel) {
												this._startLevel = newLevel;
											},
										},
										{
											key: "nextLoadLevel",
											get: function get() {
												if (this.manualLevelIndex !== -1) {
													return this.manualLevelIndex;
												} else {
													return this.hls.nextAutoLevel;
												}
											},
											set: function set(nextLevel) {
												this.level = nextLevel;
												if (this.manualLevelIndex === -1) {
													this.hls.nextAutoLevel = nextLevel;
												}
											},
										},
									]);
									return LevelController;
								})(event_handler);
								var id3 = __webpack_require__("./src/demux/id3.js");
								function sendAddTrackEvent(track, videoEl) {
									var event;
									try {
										event = new Event("addtrack");
									} catch (err) {
										event = document.createEvent("Event");
										event.initEvent("addtrack", false, false);
									}
									event.track = track;
									videoEl.dispatchEvent(event);
								}
								function clearCurrentCues(track) {
									if (
										track === null || track === void 0 ? void 0 : track.cues
									) {
										while (track.cues.length > 0) {
											track.removeCue(track.cues[0]);
										}
									}
								}
								function getClosestCue(cues, time) {
									if (time < cues[0].endTime) {
										return cues[0];
									}
									if (time > cues[cues.length - 1].endTime) {
										return cues[cues.length - 1];
									}
									var left = 0;
									var right = cues.length - 1;
									while (left <= right) {
										var mid = Math.floor((right + left) / 2);
										if (time < cues[mid].endTime) {
											right = mid - 1;
										} else if (time > cues[mid].endTime) {
											left = mid + 1;
										} else {
											return cues[mid];
										}
									}
									return cues[left].endTime - time < time - cues[right].endTime
										? cues[left]
										: cues[right];
								}
								function id3_track_controller_inheritsLoose(
									subClass,
									superClass
								) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var MIN_CUE_DURATION = 0.25;
								var id3_track_controller_ID3TrackController = (function (
									_EventHandler
								) {
									id3_track_controller_inheritsLoose(
										ID3TrackController,
										_EventHandler
									);
									function ID3TrackController(hls) {
										var _this;
										_this =
											_EventHandler.call(
												this,
												hls,
												events["default"].MEDIA_ATTACHED,
												events["default"].MEDIA_DETACHING,
												events["default"].FRAG_PARSING_METADATA,
												events["default"].LIVE_BACK_BUFFER_REACHED
											) || this;
										_this.id3Track = undefined;
										_this.media = undefined;
										return _this;
									}
									var _proto = ID3TrackController.prototype;
									_proto.destroy = function destroy() {
										event_handler.prototype.destroy.call(this);
									};
									_proto.onMediaAttached = function onMediaAttached(data) {
										this.media = data.media;
										if (!this.media) {
										}
									};
									_proto.onMediaDetaching = function onMediaDetaching() {
										clearCurrentCues(this.id3Track);
										this.id3Track = undefined;
										this.media = undefined;
									};
									_proto.getID3Track = function getID3Track(textTracks) {
										for (var i = 0; i < textTracks.length; i++) {
											var textTrack = textTracks[i];
											if (
												textTrack.kind === "metadata" &&
												textTrack.label === "id3"
											) {
												sendAddTrackEvent(textTrack, this.media);
												return textTrack;
											}
										}
										return this.media.addTextTrack("metadata", "id3");
									};
									_proto.onFragParsingMetadata = function onFragParsingMetadata(
										data
									) {
										var fragment = data.frag;
										var samples = data.samples;
										if (!this.id3Track) {
											this.id3Track = this.getID3Track(this.media.textTracks);
											this.id3Track.mode = "hidden";
										}
										var Cue =
											window.WebKitDataCue ||
											window.VTTCue ||
											window.TextTrackCue;
										for (var i = 0; i < samples.length; i++) {
											var frames = id3["default"].getID3Frames(samples[i].data);
											if (frames) {
												var startTime = Math.max(samples[i].pts, 0);
												var endTime =
													i < samples.length - 1
														? samples[i + 1].pts
														: fragment.endPTS;
												if (!endTime) {
													endTime = fragment.start + fragment.duration;
												}
												var timeDiff = endTime - startTime;
												if (timeDiff <= 0) {
													endTime = startTime + MIN_CUE_DURATION;
												}
												for (var j = 0; j < frames.length; j++) {
													var frame = frames[j];
													if (!id3["default"].isTimeStampFrame(frame)) {
														var cue = new Cue(startTime, endTime, "");
														cue.value = frame;
														this.id3Track.addCue(cue);
													}
												}
											}
										}
									};
									_proto.onLiveBackBufferReached =
										function onLiveBackBufferReached(_ref) {
											var bufferEnd = _ref.bufferEnd;
											var id3Track = this.id3Track;
											if (
												!id3Track ||
												!id3Track.cues ||
												!id3Track.cues.length
											) {
												return;
											}
											var foundCue = getClosestCue(id3Track.cues, bufferEnd);
											if (!foundCue) {
												return;
											}
											while (id3Track.cues[0] !== foundCue) {
												id3Track.removeCue(id3Track.cues[0]);
											}
										};
									return ID3TrackController;
								})(event_handler);
								var id3_track_controller =
									id3_track_controller_ID3TrackController;
								function is_supported_isSupported() {
									var mediaSource = getMediaSource();
									if (!mediaSource) {
										return false;
									}
									var sourceBuffer =
										self.SourceBuffer || self.WebKitSourceBuffer;
									var isTypeSupported =
										mediaSource &&
										typeof mediaSource.isTypeSupported === "function" &&
										mediaSource.isTypeSupported(
											'video/mp4; codecs="avc1.42E01E,mp4a.40.2"'
										);
									var sourceBufferValidAPI =
										!sourceBuffer ||
										(sourceBuffer.prototype &&
											typeof sourceBuffer.prototype.appendBuffer ===
												"function" &&
											typeof sourceBuffer.prototype.remove === "function");
									return !!isTypeSupported && !!sourceBufferValidAPI;
								}
								var EWMA = (function () {
									function EWMA(halfLife) {
										this.alpha_ = void 0;
										this.estimate_ = void 0;
										this.totalWeight_ = void 0;
										this.alpha_ = halfLife
											? Math.exp(Math.log(0.5) / halfLife)
											: 0;
										this.estimate_ = 0;
										this.totalWeight_ = 0;
									}
									var _proto = EWMA.prototype;
									_proto.sample = function sample(weight, value) {
										var adjAlpha = Math.pow(this.alpha_, weight);
										this.estimate_ =
											value * (1 - adjAlpha) + adjAlpha * this.estimate_;
										this.totalWeight_ += weight;
									};
									_proto.getTotalWeight = function getTotalWeight() {
										return this.totalWeight_;
									};
									_proto.getEstimate = function getEstimate() {
										if (this.alpha_) {
											var zeroFactor =
												1 - Math.pow(this.alpha_, this.totalWeight_);
											return this.estimate_ / zeroFactor;
										} else {
											return this.estimate_;
										}
									};
									return EWMA;
								})();
								var ewma = EWMA;
								var ewma_bandwidth_estimator_EwmaBandWidthEstimator =
									(function () {
										function EwmaBandWidthEstimator(
											hls,
											slow,
											fast,
											defaultEstimate
										) {
											this.hls = void 0;
											this.defaultEstimate_ = void 0;
											this.minWeight_ = void 0;
											this.minDelayMs_ = void 0;
											this.slow_ = void 0;
											this.fast_ = void 0;
											this.hls = hls;
											this.defaultEstimate_ = defaultEstimate;
											this.minWeight_ = 0.001;
											this.minDelayMs_ = 50;
											this.slow_ = new ewma(slow);
											this.fast_ = new ewma(fast);
										}
										var _proto = EwmaBandWidthEstimator.prototype;
										_proto.sample = function sample(durationMs, numBytes) {
											durationMs = Math.max(durationMs, this.minDelayMs_);
											var numBits = 8 * numBytes,
												durationS = durationMs / 1e3,
												bandwidthInBps = numBits / durationS;
											this.fast_.sample(durationS, bandwidthInBps);
											this.slow_.sample(durationS, bandwidthInBps);
										};
										_proto.canEstimate = function canEstimate() {
											var fast = this.fast_;
											return fast && fast.getTotalWeight() >= this.minWeight_;
										};
										_proto.getEstimate = function getEstimate() {
											if (this.canEstimate()) {
												return Math.min(
													this.fast_.getEstimate(),
													this.slow_.getEstimate()
												);
											} else {
												return this.defaultEstimate_;
											}
										};
										_proto.destroy = function destroy() {};
										return EwmaBandWidthEstimator;
									})();
								var ewma_bandwidth_estimator =
									ewma_bandwidth_estimator_EwmaBandWidthEstimator;
								function abr_controller_defineProperties(target, props) {
									for (var i = 0; i < props.length; i++) {
										var descriptor = props[i];
										descriptor.enumerable = descriptor.enumerable || false;
										descriptor.configurable = true;
										if ("value" in descriptor) descriptor.writable = true;
										Object.defineProperty(target, descriptor.key, descriptor);
									}
								}
								function abr_controller_createClass(
									Constructor,
									protoProps,
									staticProps
								) {
									if (protoProps)
										abr_controller_defineProperties(
											Constructor.prototype,
											protoProps
										);
									if (staticProps)
										abr_controller_defineProperties(Constructor, staticProps);
									return Constructor;
								}
								function abr_controller_assertThisInitialized(self) {
									if (self === void 0) {
										throw new ReferenceError(
											"this hasn't been initialised - super() hasn't been called"
										);
									}
									return self;
								}
								function abr_controller_inheritsLoose(subClass, superClass) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var abr_controller_window = window,
									abr_controller_performance =
										abr_controller_window.performance;
								var abr_controller_AbrController = (function (_EventHandler) {
									abr_controller_inheritsLoose(AbrController, _EventHandler);
									function AbrController(hls) {
										var _this;
										_this =
											_EventHandler.call(
												this,
												hls,
												events["default"].FRAG_LOADING,
												events["default"].FRAG_LOADED,
												events["default"].FRAG_BUFFERED,
												events["default"].ERROR
											) || this;
										_this.lastLoadedFragLevel = 0;
										_this._nextAutoLevel = -1;
										_this.hls = hls;
										_this.timer = null;
										_this._bwEstimator = null;
										_this.onCheck = _this._abandonRulesCheck.bind(
											abr_controller_assertThisInitialized(_this)
										);
										return _this;
									}
									var _proto = AbrController.prototype;
									_proto.destroy = function destroy() {
										this.clearTimer();
										event_handler.prototype.destroy.call(this);
									};
									_proto.onFragLoading = function onFragLoading(data) {
										var frag = data.frag;
										if (frag.type === "main") {
											if (!this.timer) {
												this.fragCurrent = frag;
												this.timer = setInterval(this.onCheck, 100);
											}
											if (!this._bwEstimator) {
												var hls = this.hls;
												var config = hls.config;
												var level = frag.level;
												var isLive = hls.levels[level].details.live;
												var ewmaFast;
												var ewmaSlow;
												if (isLive) {
													ewmaFast = config.abrEwmaFastLive;
													ewmaSlow = config.abrEwmaSlowLive;
												} else {
													ewmaFast = config.abrEwmaFastVoD;
													ewmaSlow = config.abrEwmaSlowVoD;
												}
												this._bwEstimator = new ewma_bandwidth_estimator(
													hls,
													ewmaSlow,
													ewmaFast,
													config.abrEwmaDefaultEstimate
												);
											}
										}
									};
									_proto._abandonRulesCheck = function _abandonRulesCheck() {
										var hls = this.hls;
										var video = hls.media;
										var frag = this.fragCurrent;
										if (!frag) {
											return;
										}
										var loader = frag.loader;
										if (!loader || (loader.stats && loader.stats.aborted)) {
											logger["logger"].warn(
												"frag loader destroy or aborted, disarm abandonRules"
											);
											this.clearTimer();
											this._nextAutoLevel = -1;
											return;
										}
										var stats = loader.stats;
										if (
											video &&
											stats &&
											((!video.paused && video.playbackRate !== 0) ||
												!video.readyState) &&
											frag.autoLevel &&
											frag.level
										) {
											var requestDelay =
												abr_controller_performance.now() - stats.trequest;
											var playbackRate = Math.abs(video.playbackRate);
											if (requestDelay > (500 * frag.duration) / playbackRate) {
												var levels = hls.levels;
												var loadRate = Math.max(
													1,
													stats.bw
														? stats.bw / 8
														: (stats.loaded * 1e3) / requestDelay
												);
												var level = levels[frag.level];
												if (!level) {
													return;
												}
												var levelBitrate = level.realBitrate
													? Math.max(level.realBitrate, level.bitrate)
													: level.bitrate;
												var expectedLen = stats.total
													? stats.total
													: Math.max(
															stats.loaded,
															Math.round((frag.duration * levelBitrate) / 8)
													  );
												var pos = video.currentTime;
												var fragLoadedDelay =
													(expectedLen - stats.loaded) / loadRate;
												var bufferStarvationDelay =
													(BufferHelper.bufferInfo(
														video,
														pos,
														hls.config.maxBufferHole
													).end -
														pos) /
													playbackRate;
												if (
													bufferStarvationDelay <
														(2 * frag.duration) / playbackRate &&
													fragLoadedDelay > bufferStarvationDelay
												) {
													var minAutoLevel = hls.minAutoLevel;
													var fragLevelNextLoadedDelay;
													var nextLoadLevel;
													for (
														nextLoadLevel = frag.level - 1;
														nextLoadLevel > minAutoLevel;
														nextLoadLevel--
													) {
														var levelNextBitrate = levels[nextLoadLevel]
															.realBitrate
															? Math.max(
																	levels[nextLoadLevel].realBitrate,
																	levels[nextLoadLevel].bitrate
															  )
															: levels[nextLoadLevel].bitrate;
														var _fragLevelNextLoadedDelay =
															(frag.duration * levelNextBitrate) /
															(8 * 0.8 * loadRate);
														if (
															_fragLevelNextLoadedDelay < bufferStarvationDelay
														) {
															break;
														}
													}
													if (fragLevelNextLoadedDelay < fragLoadedDelay) {
														logger["logger"].warn(
															"loading too slow, abort fragment loading and switch to level " +
																nextLoadLevel +
																":fragLoadedDelay[" +
																nextLoadLevel +
																"]<fragLoadedDelay[" +
																(frag.level - 1) +
																"];bufferStarvationDelay:" +
																fragLevelNextLoadedDelay.toFixed(1) +
																"<" +
																fragLoadedDelay.toFixed(1) +
																":" +
																bufferStarvationDelay.toFixed(1)
														);
														hls.nextLoadLevel = nextLoadLevel;
														this._bwEstimator.sample(
															requestDelay,
															stats.loaded
														);
														loader.abort();
														this.clearTimer();
														hls.trigger(
															events["default"].FRAG_LOAD_EMERGENCY_ABORTED,
															{ frag: frag, stats: stats }
														);
													}
												}
											}
										}
									};
									_proto.onFragLoaded = function onFragLoaded(data) {
										var frag = data.frag;
										if (
											frag.type === "main" &&
											Object(number["isFiniteNumber"])(frag.sn)
										) {
											this.clearTimer();
											this.lastLoadedFragLevel = frag.level;
											this._nextAutoLevel = -1;
											if (this.hls.config.abrMaxWithRealBitrate) {
												var level = this.hls.levels[frag.level];
												var loadedBytes =
													(level.loaded ? level.loaded.bytes : 0) +
													data.stats.loaded;
												var loadedDuration =
													(level.loaded ? level.loaded.duration : 0) +
													data.frag.duration;
												level.loaded = {
													bytes: loadedBytes,
													duration: loadedDuration,
												};
												level.realBitrate = Math.round(
													(8 * loadedBytes) / loadedDuration
												);
											}
											if (data.frag.bitrateTest) {
												var stats = data.stats;
												stats.tparsed = stats.tbuffered = stats.tload;
												this.onFragBuffered(data);
											}
										}
									};
									_proto.onFragBuffered = function onFragBuffered(data) {
										var stats = data.stats;
										var frag = data.frag;
										if (
											stats.aborted !== true &&
											frag.type === "main" &&
											Object(number["isFiniteNumber"])(frag.sn) &&
											(!frag.bitrateTest || stats.tload === stats.tbuffered)
										) {
											var fragLoadingProcessingMs =
												stats.tparsed - stats.trequest;
											logger["logger"].log(
												"latency/loading/parsing/append/kbps:" +
													Math.round(stats.tfirst - stats.trequest) +
													"/" +
													Math.round(stats.tload - stats.tfirst) +
													"/" +
													Math.round(stats.tparsed - stats.tload) +
													"/" +
													Math.round(stats.tbuffered - stats.tparsed) +
													"/" +
													Math.round(
														(8 * stats.loaded) /
															(stats.tbuffered - stats.trequest)
													)
											);
											this._bwEstimator.sample(
												fragLoadingProcessingMs,
												stats.loaded
											);
											stats.bwEstimate = this._bwEstimator.getEstimate();
											if (frag.bitrateTest) {
												this.bitrateTestDelay = fragLoadingProcessingMs / 1e3;
											} else {
												this.bitrateTestDelay = 0;
											}
										}
									};
									_proto.onError = function onError(data) {
										switch (data.details) {
											case errors["ErrorDetails"].FRAG_LOAD_ERROR:
											case errors["ErrorDetails"].FRAG_LOAD_TIMEOUT:
												this.clearTimer();
												break;
											default:
												break;
										}
									};
									_proto.clearTimer = function clearTimer() {
										clearInterval(this.timer);
										this.timer = null;
									};
									_proto._findBestLevel = function _findBestLevel(
										currentLevel,
										currentFragDuration,
										currentBw,
										minAutoLevel,
										maxAutoLevel,
										maxFetchDuration,
										bwFactor,
										bwUpFactor,
										levels
									) {
										for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
											var levelInfo = levels[i];
											if (!levelInfo) {
												continue;
											}
											var levelDetails = levelInfo.details;
											var avgDuration = levelDetails
												? levelDetails.totalduration /
												  levelDetails.fragments.length
												: currentFragDuration;
											var live = levelDetails ? levelDetails.live : false;
											var adjustedbw = void 0;
											if (i <= currentLevel) {
												adjustedbw = bwFactor * currentBw;
											} else {
												adjustedbw = bwUpFactor * currentBw;
											}
											var bitrate = levels[i].realBitrate
												? Math.max(levels[i].realBitrate, levels[i].bitrate)
												: levels[i].bitrate;
											var fetchDuration = (bitrate * avgDuration) / adjustedbw;
											logger["logger"].trace(
												"level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " +
													i +
													"/" +
													Math.round(adjustedbw) +
													"/" +
													bitrate +
													"/" +
													avgDuration +
													"/" +
													maxFetchDuration +
													"/" +
													fetchDuration
											);
											if (
												adjustedbw > bitrate &&
												(!fetchDuration ||
													(live && !this.bitrateTestDelay) ||
													fetchDuration < maxFetchDuration)
											) {
												return i;
											}
										}
										return -1;
									};
									abr_controller_createClass(AbrController, [
										{
											key: "nextAutoLevel",
											get: function get() {
												var forcedAutoLevel = this._nextAutoLevel;
												var bwEstimator = this._bwEstimator;
												if (
													forcedAutoLevel !== -1 &&
													(!bwEstimator || !bwEstimator.canEstimate())
												) {
													return forcedAutoLevel;
												}
												var nextABRAutoLevel = this._nextABRAutoLevel;
												if (forcedAutoLevel !== -1) {
													nextABRAutoLevel = Math.min(
														forcedAutoLevel,
														nextABRAutoLevel
													);
												}
												return nextABRAutoLevel;
											},
											set: function set(nextLevel) {
												this._nextAutoLevel = nextLevel;
											},
										},
										{
											key: "_nextABRAutoLevel",
											get: function get() {
												var hls = this.hls;
												var maxAutoLevel = hls.maxAutoLevel,
													levels = hls.levels,
													config = hls.config,
													minAutoLevel = hls.minAutoLevel;
												var video = hls.media;
												var currentLevel = this.lastLoadedFragLevel;
												var currentFragDuration = this.fragCurrent
													? this.fragCurrent.duration
													: 0;
												var pos = video ? video.currentTime : 0;
												var playbackRate =
													video && video.playbackRate !== 0
														? Math.abs(video.playbackRate)
														: 1;
												var avgbw = this._bwEstimator
													? this._bwEstimator.getEstimate()
													: config.abrEwmaDefaultEstimate;
												var bufferStarvationDelay =
													(BufferHelper.bufferInfo(
														video,
														pos,
														config.maxBufferHole
													).end -
														pos) /
													playbackRate;
												var bestLevel = this._findBestLevel(
													currentLevel,
													currentFragDuration,
													avgbw,
													minAutoLevel,
													maxAutoLevel,
													bufferStarvationDelay,
													config.abrBandWidthFactor,
													config.abrBandWidthUpFactor,
													levels
												);
												if (bestLevel >= 0) {
													return bestLevel;
												} else {
													logger["logger"].trace(
														"rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering"
													);
													var maxStarvationDelay = currentFragDuration
														? Math.min(
																currentFragDuration,
																config.maxStarvationDelay
														  )
														: config.maxStarvationDelay;
													var bwFactor = config.abrBandWidthFactor;
													var bwUpFactor = config.abrBandWidthUpFactor;
													if (bufferStarvationDelay === 0) {
														var bitrateTestDelay = this.bitrateTestDelay;
														if (bitrateTestDelay) {
															var maxLoadingDelay = currentFragDuration
																? Math.min(
																		currentFragDuration,
																		config.maxLoadingDelay
																  )
																: config.maxLoadingDelay;
															maxStarvationDelay =
																maxLoadingDelay - bitrateTestDelay;
															logger["logger"].trace(
																"bitrate test took " +
																	Math.round(1e3 * bitrateTestDelay) +
																	"ms, set first fragment max fetchDuration to " +
																	Math.round(1e3 * maxStarvationDelay) +
																	" ms"
															);
															bwFactor = bwUpFactor = 1;
														}
													}
													bestLevel = this._findBestLevel(
														currentLevel,
														currentFragDuration,
														avgbw,
														minAutoLevel,
														maxAutoLevel,
														bufferStarvationDelay + maxStarvationDelay,
														bwFactor,
														bwUpFactor,
														levels
													);
													return Math.max(bestLevel, 0);
												}
											},
										},
									]);
									return AbrController;
								})(event_handler);
								var abr_controller = abr_controller_AbrController;
								function buffer_controller_inheritsLoose(subClass, superClass) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var buffer_controller_MediaSource = getMediaSource();
								var buffer_controller_BufferController = (function (
									_EventHandler
								) {
									buffer_controller_inheritsLoose(
										BufferController,
										_EventHandler
									);
									function BufferController(hls) {
										var _this;
										_this =
											_EventHandler.call(
												this,
												hls,
												events["default"].MEDIA_ATTACHING,
												events["default"].MEDIA_DETACHING,
												events["default"].MANIFEST_PARSED,
												events["default"].BUFFER_RESET,
												events["default"].BUFFER_APPENDING,
												events["default"].BUFFER_CODECS,
												events["default"].BUFFER_EOS,
												events["default"].BUFFER_FLUSHING,
												events["default"].LEVEL_PTS_UPDATED,
												events["default"].LEVEL_UPDATED
											) || this;
										_this._msDuration = null;
										_this._levelDuration = null;
										_this._levelTargetDuration = 10;
										_this._live = null;
										_this._objectUrl = null;
										_this._needsFlush = false;
										_this._needsEos = false;
										_this.config = void 0;
										_this.audioTimestampOffset = void 0;
										_this.bufferCodecEventsExpected = 0;
										_this._bufferCodecEventsTotal = 0;
										_this.media = null;
										_this.mediaSource = null;
										_this.segments = [];
										_this.parent = void 0;
										_this.appending = false;
										_this.appended = 0;
										_this.appendError = 0;
										_this.flushBufferCounter = 0;
										_this.tracks = {};
										_this.pendingTracks = {};
										_this.sourceBuffer = {};
										_this.flushRange = [];
										_this._onMediaSourceOpen = function () {
											logger["logger"].log("media source opened");
											_this.hls.trigger(events["default"].MEDIA_ATTACHED, {
												media: _this.media,
											});
											var mediaSource = _this.mediaSource;
											if (mediaSource) {
												mediaSource.removeEventListener(
													"sourceopen",
													_this._onMediaSourceOpen
												);
											}
											_this.checkPendingTracks();
										};
										_this._onMediaSourceClose = function () {
											logger["logger"].log("media source closed");
										};
										_this._onMediaSourceEnded = function () {
											logger["logger"].log("media source ended");
										};
										_this._onSBUpdateEnd = function () {
											if (
												_this.audioTimestampOffset &&
												_this.sourceBuffer.audio
											) {
												var audioBuffer = _this.sourceBuffer.audio;
												logger["logger"].warn(
													"change mpeg audio timestamp offset from " +
														audioBuffer.timestampOffset +
														" to " +
														_this.audioTimestampOffset
												);
												audioBuffer.timestampOffset =
													_this.audioTimestampOffset;
												delete _this.audioTimestampOffset;
											}
											if (_this._needsFlush) {
												_this.doFlush();
											}
											if (_this._needsEos) {
												_this.checkEos();
											}
											_this.appending = false;
											var parent = _this.parent;
											var pending = _this.segments.reduce(function (
												counter,
												segment
											) {
												return segment.parent === parent
													? counter + 1
													: counter;
											},
											0);
											var timeRanges = {};
											var sbSet = _this.sourceBuffer;
											for (var streamType in sbSet) {
												var sb = sbSet[streamType];
												if (!sb) {
													throw Error(
														"handling source buffer update end error: source buffer for " +
															streamType +
															" uninitilized and unable to update buffered TimeRanges."
													);
												}
												timeRanges[streamType] = sb.buffered;
											}
											_this.hls.trigger(events["default"].BUFFER_APPENDED, {
												parent: parent,
												pending: pending,
												timeRanges: timeRanges,
											});
											if (!_this._needsFlush) {
												_this.doAppending();
											}
											_this.updateMediaElementDuration();
											if (pending === 0) {
												_this.flushLiveBackBuffer();
											}
										};
										_this._onSBUpdateError = function (event) {
											logger["logger"].error("sourceBuffer error:", event);
											_this.hls.trigger(events["default"].ERROR, {
												type: errors["ErrorTypes"].MEDIA_ERROR,
												details: errors["ErrorDetails"].BUFFER_APPENDING_ERROR,
												fatal: false,
											});
										};
										_this.config = hls.config;
										return _this;
									}
									var _proto = BufferController.prototype;
									_proto.destroy = function destroy() {
										event_handler.prototype.destroy.call(this);
									};
									_proto.onLevelPtsUpdated = function onLevelPtsUpdated(data) {
										var type = data.type;
										var audioTrack = this.tracks.audio;
										if (
											type === "audio" &&
											audioTrack &&
											audioTrack.container === "audio/mpeg"
										) {
											var audioBuffer = this.sourceBuffer.audio;
											if (!audioBuffer) {
												throw Error(
													"Level PTS Updated and source buffer for audio uninitalized"
												);
											}
											var delta = Math.abs(
												audioBuffer.timestampOffset - data.start
											);
											if (delta > 0.1) {
												var updating = audioBuffer.updating;
												try {
													audioBuffer.abort();
												} catch (err) {
													logger["logger"].warn(
														"can not abort audio buffer: " + err
													);
												}
												if (!updating) {
													logger["logger"].warn(
														"change mpeg audio timestamp offset from " +
															audioBuffer.timestampOffset +
															" to " +
															data.start
													);
													audioBuffer.timestampOffset = data.start;
												} else {
													this.audioTimestampOffset = data.start;
												}
											}
										}
									};
									_proto.onManifestParsed = function onManifestParsed(data) {
										var codecEvents = 2;
										if ((data.audio && !data.video) || !data.altAudio) {
											codecEvents = 1;
										}
										this.bufferCodecEventsExpected =
											this._bufferCodecEventsTotal = codecEvents;
										logger["logger"].log(
											this.bufferCodecEventsExpected +
												" bufferCodec event(s) expected"
										);
									};
									_proto.onMediaAttaching = function onMediaAttaching(data) {
										var media = (this.media = data.media);
										if (media && buffer_controller_MediaSource) {
											var ms = (this.mediaSource =
												new buffer_controller_MediaSource());
											ms.addEventListener(
												"sourceopen",
												this._onMediaSourceOpen
											);
											ms.addEventListener(
												"sourceended",
												this._onMediaSourceEnded
											);
											ms.addEventListener(
												"sourceclose",
												this._onMediaSourceClose
											);
											media.src = window.URL.createObjectURL(ms);
											this._objectUrl = media.src;
										}
									};
									_proto.onMediaDetaching = function onMediaDetaching() {
										logger["logger"].log("media source detaching");
										var ms = this.mediaSource;
										if (ms) {
											if (ms.readyState === "open") {
												try {
													ms.endOfStream();
												} catch (err) {
													logger["logger"].warn(
														"onMediaDetaching:" +
															err.message +
															" while calling endOfStream"
													);
												}
											}
											ms.removeEventListener(
												"sourceopen",
												this._onMediaSourceOpen
											);
											ms.removeEventListener(
												"sourceended",
												this._onMediaSourceEnded
											);
											ms.removeEventListener(
												"sourceclose",
												this._onMediaSourceClose
											);
											if (this.media) {
												if (this._objectUrl) {
													window.URL.revokeObjectURL(this._objectUrl);
												}
												if (this.media.src === this._objectUrl) {
													this.media.removeAttribute("src");
													this.media.load();
												} else {
													logger["logger"].warn(
														"media.src was changed by a third party - skip cleanup"
													);
												}
											}
											this.mediaSource = null;
											this.media = null;
											this._objectUrl = null;
											this.bufferCodecEventsExpected =
												this._bufferCodecEventsTotal;
											this.pendingTracks = {};
											this.tracks = {};
											this.sourceBuffer = {};
											this.flushRange = [];
											this.segments = [];
											this.appended = 0;
										}
										this.hls.trigger(events["default"].MEDIA_DETACHED);
									};
									_proto.checkPendingTracks = function checkPendingTracks() {
										var bufferCodecEventsExpected =
												this.bufferCodecEventsExpected,
											pendingTracks = this.pendingTracks;
										var pendingTracksCount = Object.keys(pendingTracks).length;
										if (
											(pendingTracksCount && !bufferCodecEventsExpected) ||
											pendingTracksCount === 2
										) {
											this.createSourceBuffers(pendingTracks);
											this.pendingTracks = {};
											this.doAppending();
										}
									};
									_proto.onBufferReset = function onBufferReset() {
										var sourceBuffer = this.sourceBuffer;
										for (var type in sourceBuffer) {
											var sb = sourceBuffer[type];
											try {
												if (sb) {
													if (this.mediaSource) {
														this.mediaSource.removeSourceBuffer(sb);
													}
													sb.removeEventListener(
														"updateend",
														this._onSBUpdateEnd
													);
													sb.removeEventListener(
														"error",
														this._onSBUpdateError
													);
												}
											} catch (err) {}
										}
										this.sourceBuffer = {};
										this.flushRange = [];
										this.segments = [];
										this.appended = 0;
									};
									_proto.onBufferCodecs = function onBufferCodecs(tracks) {
										var _this2 = this;
										if (Object.keys(this.sourceBuffer).length) {
											return;
										}
										Object.keys(tracks).forEach(function (trackName) {
											_this2.pendingTracks[trackName] = tracks[trackName];
										});
										this.bufferCodecEventsExpected = Math.max(
											this.bufferCodecEventsExpected - 1,
											0
										);
										if (
											this.mediaSource &&
											this.mediaSource.readyState === "open"
										) {
											this.checkPendingTracks();
										}
									};
									_proto.createSourceBuffers = function createSourceBuffers(
										tracks
									) {
										var sourceBuffer = this.sourceBuffer,
											mediaSource = this.mediaSource;
										if (!mediaSource) {
											throw Error(
												"createSourceBuffers called when mediaSource was null"
											);
										}
										for (var trackName in tracks) {
											if (!sourceBuffer[trackName]) {
												var track = tracks[trackName];
												if (!track) {
													throw Error(
														"source buffer exists for track " +
															trackName +
															", however track does not"
													);
												}
												var codec = track.levelCodec || track.codec;
												var mimeType = track.container + ";codecs=" + codec;
												logger["logger"].log(
													"creating sourceBuffer(" + mimeType + ")"
												);
												try {
													var sb = (sourceBuffer[trackName] =
														mediaSource.addSourceBuffer(mimeType));
													sb.addEventListener("updateend", this._onSBUpdateEnd);
													sb.addEventListener("error", this._onSBUpdateError);
													this.tracks[trackName] = {
														buffer: sb,
														codec: codec,
														id: track.id,
														container: track.container,
														levelCodec: track.levelCodec,
													};
												} catch (err) {
													logger["logger"].error(
														"error while trying to add sourceBuffer:" +
															err.message
													);
													this.hls.trigger(events["default"].ERROR, {
														type: errors["ErrorTypes"].MEDIA_ERROR,
														details:
															errors["ErrorDetails"].BUFFER_ADD_CODEC_ERROR,
														fatal: false,
														err: err,
														mimeType: mimeType,
													});
												}
											}
										}
										this.hls.trigger(events["default"].BUFFER_CREATED, {
											tracks: this.tracks,
										});
									};
									_proto.onBufferAppending = function onBufferAppending(data) {
										if (!this._needsFlush) {
											if (!this.segments) {
												this.segments = [data];
											} else {
												this.segments.push(data);
											}
											this.doAppending();
										}
									};
									_proto.onBufferEos = function onBufferEos(data) {
										for (var type in this.sourceBuffer) {
											if (!data.type || data.type === type) {
												var sb = this.sourceBuffer[type];
												if (sb && !sb.ended) {
													sb.ended = true;
													logger["logger"].log(type + " sourceBuffer now EOS");
												}
											}
										}
										this.checkEos();
									};
									_proto.checkEos = function checkEos() {
										var sourceBuffer = this.sourceBuffer,
											mediaSource = this.mediaSource;
										if (!mediaSource || mediaSource.readyState !== "open") {
											this._needsEos = false;
											return;
										}
										for (var type in sourceBuffer) {
											var sb = sourceBuffer[type];
											if (!sb) continue;
											if (!sb.ended) {
												return;
											}
											if (sb.updating) {
												this._needsEos = true;
												return;
											}
										}
										logger["logger"].log(
											"all media data are available, signal endOfStream() to MediaSource and stop loading fragment"
										);
										try {
											mediaSource.endOfStream();
										} catch (e) {
											logger["logger"].warn(
												"exception while calling mediaSource.endOfStream()"
											);
										}
										this._needsEos = false;
									};
									_proto.onBufferFlushing = function onBufferFlushing(data) {
										if (data.type) {
											this.flushRange.push({
												start: data.startOffset,
												end: data.endOffset,
												type: data.type,
											});
										} else {
											this.flushRange.push({
												start: data.startOffset,
												end: data.endOffset,
												type: "video",
											});
											this.flushRange.push({
												start: data.startOffset,
												end: data.endOffset,
												type: "audio",
											});
										}
										this.flushBufferCounter = 0;
										this.doFlush();
									};
									_proto.flushLiveBackBuffer = function flushLiveBackBuffer() {
										if (!this._live) {
											return;
										}
										var liveBackBufferLength = this.config.liveBackBufferLength;
										if (
											!isFinite(liveBackBufferLength) ||
											liveBackBufferLength < 0
										) {
											return;
										}
										if (!this.media) {
											logger["logger"].error(
												"flushLiveBackBuffer called without attaching media"
											);
											return;
										}
										var currentTime = this.media.currentTime;
										var sourceBuffer = this.sourceBuffer;
										var bufferTypes = Object.keys(sourceBuffer);
										var targetBackBufferPosition =
											currentTime -
											Math.max(liveBackBufferLength, this._levelTargetDuration);
										for (
											var index = bufferTypes.length - 1;
											index >= 0;
											index--
										) {
											var bufferType = bufferTypes[index];
											var sb = sourceBuffer[bufferType];
											if (sb) {
												var buffered = sb.buffered;
												if (
													buffered.length > 0 &&
													targetBackBufferPosition > buffered.start(0)
												) {
													if (
														this.removeBufferRange(
															bufferType,
															sb,
															0,
															targetBackBufferPosition
														)
													) {
														this.hls.trigger(
															events["default"].LIVE_BACK_BUFFER_REACHED,
															{ bufferEnd: targetBackBufferPosition }
														);
													}
												}
											}
										}
									};
									_proto.onLevelUpdated = function onLevelUpdated(_ref) {
										var details = _ref.details;
										if (details.fragments.length > 0) {
											this._levelDuration =
												details.totalduration + details.fragments[0].start;
											this._levelTargetDuration =
												details.averagetargetduration ||
												details.targetduration ||
												10;
											this._live = details.live;
											this.updateMediaElementDuration();
										}
									};
									_proto.updateMediaElementDuration =
										function updateMediaElementDuration() {
											var config = this.config;
											var duration;
											if (
												this._levelDuration === null ||
												!this.media ||
												!this.mediaSource ||
												!this.sourceBuffer ||
												this.media.readyState === 0 ||
												this.mediaSource.readyState !== "open"
											) {
												return;
											}
											for (var type in this.sourceBuffer) {
												var sb = this.sourceBuffer[type];
												if (sb && sb.updating === true) {
													return;
												}
											}
											duration = this.media.duration;
											if (this._msDuration === null) {
												this._msDuration = this.mediaSource.duration;
											}
											if (
												this._live === true &&
												config.liveDurationInfinity === true
											) {
												logger["logger"].log(
													"Media Source duration is set to Infinity"
												);
												this._msDuration = this.mediaSource.duration = Infinity;
											} else if (
												(this._levelDuration > this._msDuration &&
													this._levelDuration > duration) ||
												!Object(number["isFiniteNumber"])(duration)
											) {
												logger["logger"].log(
													"Updating Media Source duration to " +
														this._levelDuration.toFixed(3)
												);
												this._msDuration = this.mediaSource.duration =
													this._levelDuration;
											}
										};
									_proto.doFlush = function doFlush() {
										while (this.flushRange.length) {
											var range = this.flushRange[0];
											if (
												this.flushBuffer(range.start, range.end, range.type)
											) {
												this.flushRange.shift();
												this.flushBufferCounter = 0;
											} else {
												this._needsFlush = true;
												return;
											}
										}
										if (this.flushRange.length === 0) {
											this._needsFlush = false;
											var appended = 0;
											var sourceBuffer = this.sourceBuffer;
											try {
												for (var type in sourceBuffer) {
													var sb = sourceBuffer[type];
													if (sb) {
														appended += sb.buffered.length;
													}
												}
											} catch (error) {
												logger["logger"].error(
													"error while accessing sourceBuffer.buffered"
												);
											}
											this.appended = appended;
											this.hls.trigger(events["default"].BUFFER_FLUSHED);
										}
									};
									_proto.doAppending = function doAppending() {
										var config = this.config,
											hls = this.hls,
											segments = this.segments,
											sourceBuffer = this.sourceBuffer;
										if (!Object.keys(sourceBuffer).length) {
											return;
										}
										if (!this.media || this.media.error) {
											this.segments = [];
											logger["logger"].error(
												"trying to append although a media error occured, flush segment and abort"
											);
											return;
										}
										if (this.appending) {
											return;
										}
										var segment = segments.shift();
										if (!segment) {
											return;
										}
										try {
											var sb = sourceBuffer[segment.type];
											if (!sb) {
												this._onSBUpdateEnd();
												return;
											}
											if (sb.updating) {
												segments.unshift(segment);
												return;
											}
											sb.ended = false;
											this.parent = segment.parent;
											sb.appendBuffer(segment.data);
											this.appendError = 0;
											this.appended++;
											this.appending = true;
										} catch (err) {
											logger["logger"].error(
												"error while trying to append buffer:" + err.message
											);
											segments.unshift(segment);
											var event = {
												type: errors["ErrorTypes"].MEDIA_ERROR,
												parent: segment.parent,
												details: "",
												fatal: false,
											};
											if (err.code === 22) {
												this.segments = [];
												event.details =
													errors["ErrorDetails"].BUFFER_FULL_ERROR;
											} else {
												this.appendError++;
												event.details =
													errors["ErrorDetails"].BUFFER_APPEND_ERROR;
												if (this.appendError > config.appendErrorMaxRetry) {
													logger["logger"].log(
														"fail " +
															config.appendErrorMaxRetry +
															" times to append segment in sourceBuffer"
													);
													this.segments = [];
													event.fatal = true;
												}
											}
											hls.trigger(events["default"].ERROR, event);
										}
									};
									_proto.flushBuffer = function flushBuffer(
										startOffset,
										endOffset,
										sbType
									) {
										var sourceBuffer = this.sourceBuffer;
										if (!Object.keys(sourceBuffer).length) {
											return true;
										}
										var currentTime = "null";
										if (this.media) {
											currentTime = this.media.currentTime.toFixed(3);
										}
										logger["logger"].log(
											"flushBuffer,pos/start/end: " +
												currentTime +
												"/" +
												startOffset +
												"/" +
												endOffset
										);
										if (this.flushBufferCounter >= this.appended) {
											logger["logger"].warn("abort flushing too many retries");
											return true;
										}
										var sb = sourceBuffer[sbType];
										if (sb) {
											sb.ended = false;
											if (!sb.updating) {
												if (
													this.removeBufferRange(
														sbType,
														sb,
														startOffset,
														endOffset
													)
												) {
													this.flushBufferCounter++;
													return false;
												}
											} else {
												logger["logger"].warn(
													"cannot flush, sb updating in progress"
												);
												return false;
											}
										}
										logger["logger"].log("buffer flushed");
										return true;
									};
									_proto.removeBufferRange = function removeBufferRange(
										type,
										sb,
										startOffset,
										endOffset
									) {
										try {
											for (var i = 0; i < sb.buffered.length; i++) {
												var bufStart = sb.buffered.start(i);
												var bufEnd = sb.buffered.end(i);
												var removeStart = Math.max(bufStart, startOffset);
												var removeEnd = Math.min(bufEnd, endOffset);
												if (Math.min(removeEnd, bufEnd) - removeStart > 0.5) {
													var currentTime = "null";
													if (this.media) {
														currentTime = this.media.currentTime.toString();
													}
													logger["logger"].log(
														"sb remove " +
															type +
															" [" +
															removeStart +
															"," +
															removeEnd +
															"], of [" +
															bufStart +
															"," +
															bufEnd +
															"], pos:" +
															currentTime
													);
													sb.remove(removeStart, removeEnd);
													return true;
												}
											}
										} catch (error) {
											logger["logger"].warn("removeBufferRange failed", error);
										}
										return false;
									};
									return BufferController;
								})(event_handler);
								var buffer_controller = buffer_controller_BufferController;
								function cap_level_controller_defineProperties(target, props) {
									for (var i = 0; i < props.length; i++) {
										var descriptor = props[i];
										descriptor.enumerable = descriptor.enumerable || false;
										descriptor.configurable = true;
										if ("value" in descriptor) descriptor.writable = true;
										Object.defineProperty(target, descriptor.key, descriptor);
									}
								}
								function cap_level_controller_createClass(
									Constructor,
									protoProps,
									staticProps
								) {
									if (protoProps)
										cap_level_controller_defineProperties(
											Constructor.prototype,
											protoProps
										);
									if (staticProps)
										cap_level_controller_defineProperties(
											Constructor,
											staticProps
										);
									return Constructor;
								}
								function cap_level_controller_inheritsLoose(
									subClass,
									superClass
								) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var cap_level_controller_CapLevelController = (function (
									_EventHandler
								) {
									cap_level_controller_inheritsLoose(
										CapLevelController,
										_EventHandler
									);
									function CapLevelController(hls) {
										var _this;
										_this =
											_EventHandler.call(
												this,
												hls,
												events["default"].FPS_DROP_LEVEL_CAPPING,
												events["default"].MEDIA_ATTACHING,
												events["default"].MANIFEST_PARSED,
												events["default"].LEVELS_UPDATED,
												events["default"].BUFFER_CODECS,
												events["default"].MEDIA_DETACHING
											) || this;
										_this.autoLevelCapping = Number.POSITIVE_INFINITY;
										_this.firstLevel = null;
										_this.levels = [];
										_this.media = null;
										_this.restrictedLevels = [];
										_this.timer = null;
										_this.clientRect = null;
										return _this;
									}
									var _proto = CapLevelController.prototype;
									_proto.destroy = function destroy() {
										if (this.hls.config.capLevelToPlayerSize) {
											this.media = null;
											this.clientRect = null;
											this.stopCapping();
										}
									};
									_proto.onFpsDropLevelCapping = function onFpsDropLevelCapping(
										data
									) {
										if (
											CapLevelController.isLevelAllowed(
												data.droppedLevel,
												this.restrictedLevels
											)
										) {
											this.restrictedLevels.push(data.droppedLevel);
										}
									};
									_proto.onMediaAttaching = function onMediaAttaching(data) {
										this.media =
											data.media instanceof window.HTMLVideoElement
												? data.media
												: null;
									};
									_proto.onManifestParsed = function onManifestParsed(data) {
										var hls = this.hls;
										this.restrictedLevels = [];
										this.levels = data.levels;
										this.firstLevel = data.firstLevel;
										if (hls.config.capLevelToPlayerSize && data.video) {
											this.startCapping();
										}
									};
									_proto.onBufferCodecs = function onBufferCodecs(data) {
										var hls = this.hls;
										if (hls.config.capLevelToPlayerSize && data.video) {
											this.startCapping();
										}
									};
									_proto.onLevelsUpdated = function onLevelsUpdated(data) {
										this.levels = data.levels;
									};
									_proto.onMediaDetaching = function onMediaDetaching() {
										this.stopCapping();
									};
									_proto.detectPlayerSize = function detectPlayerSize() {
										if (this.media) {
											var levelsLength = this.levels ? this.levels.length : 0;
											if (levelsLength) {
												var hls = this.hls;
												hls.autoLevelCapping = this.getMaxLevel(
													levelsLength - 1
												);
												if (hls.autoLevelCapping > this.autoLevelCapping) {
													hls.streamController.nextLevelSwitch();
												}
												this.autoLevelCapping = hls.autoLevelCapping;
											}
										}
									};
									_proto.getMaxLevel = function getMaxLevel(capLevelIndex) {
										var _this2 = this;
										if (!this.levels) {
											return -1;
										}
										var validLevels = this.levels.filter(function (
											level,
											index
										) {
											return (
												CapLevelController.isLevelAllowed(
													index,
													_this2.restrictedLevels
												) && index <= capLevelIndex
											);
										});
										this.clientRect = null;
										return CapLevelController.getMaxLevelByMediaSize(
											validLevels,
											this.mediaWidth,
											this.mediaHeight
										);
									};
									_proto.startCapping = function startCapping() {
										if (this.timer) {
											return;
										}
										this.autoLevelCapping = Number.POSITIVE_INFINITY;
										this.hls.firstLevel = this.getMaxLevel(this.firstLevel);
										clearInterval(this.timer);
										this.timer = setInterval(
											this.detectPlayerSize.bind(this),
											1e3
										);
										this.detectPlayerSize();
									};
									_proto.stopCapping = function stopCapping() {
										this.restrictedLevels = [];
										this.firstLevel = null;
										this.autoLevelCapping = Number.POSITIVE_INFINITY;
										if (this.timer) {
											this.timer = clearInterval(this.timer);
											this.timer = null;
										}
									};
									_proto.getDimensions = function getDimensions() {
										if (this.clientRect) {
											return this.clientRect;
										}
										var media = this.media;
										var boundsRect = { width: 0, height: 0 };
										if (media) {
											var clientRect = media.getBoundingClientRect();
											boundsRect.width = clientRect.width;
											boundsRect.height = clientRect.height;
											if (!boundsRect.width && !boundsRect.height) {
												boundsRect.width =
													clientRect.right - clientRect.left ||
													media.width ||
													0;
												boundsRect.height =
													clientRect.bottom - clientRect.top ||
													media.height ||
													0;
											}
										}
										this.clientRect = boundsRect;
										return boundsRect;
									};
									CapLevelController.isLevelAllowed = function isLevelAllowed(
										level,
										restrictedLevels
									) {
										if (restrictedLevels === void 0) {
											restrictedLevels = [];
										}
										return restrictedLevels.indexOf(level) === -1;
									};
									CapLevelController.getMaxLevelByMediaSize =
										function getMaxLevelByMediaSize(levels, width, height) {
											if (!levels || (levels && !levels.length)) {
												return -1;
											}
											var atGreatestBandiwdth = function atGreatestBandiwdth(
												curLevel,
												nextLevel
											) {
												if (!nextLevel) {
													return true;
												}
												return (
													curLevel.width !== nextLevel.width ||
													curLevel.height !== nextLevel.height
												);
											};
											var maxLevelIndex = levels.length - 1;
											for (var i = 0; i < levels.length; i += 1) {
												var level = levels[i];
												if (
													(level.width >= width || level.height >= height) &&
													atGreatestBandiwdth(level, levels[i + 1])
												) {
													maxLevelIndex = i;
													break;
												}
											}
											return maxLevelIndex;
										};
									cap_level_controller_createClass(
										CapLevelController,
										[
											{
												key: "mediaWidth",
												get: function get() {
													return (
														this.getDimensions().width *
														CapLevelController.contentScaleFactor
													);
												},
											},
											{
												key: "mediaHeight",
												get: function get() {
													return (
														this.getDimensions().height *
														CapLevelController.contentScaleFactor
													);
												},
											},
										],
										[
											{
												key: "contentScaleFactor",
												get: function get() {
													var pixelRatio = 1;
													try {
														pixelRatio = window.devicePixelRatio;
													} catch (e) {}
													return pixelRatio;
												},
											},
										]
									);
									return CapLevelController;
								})(event_handler);
								var cap_level_controller =
									cap_level_controller_CapLevelController;
								function fps_controller_inheritsLoose(subClass, superClass) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var fps_controller_window = window,
									fps_controller_performance =
										fps_controller_window.performance;
								var fps_controller_FPSController = (function (_EventHandler) {
									fps_controller_inheritsLoose(FPSController, _EventHandler);
									function FPSController(hls) {
										return (
											_EventHandler.call(
												this,
												hls,
												events["default"].MEDIA_ATTACHING
											) || this
										);
									}
									var _proto = FPSController.prototype;
									_proto.destroy = function destroy() {
										if (this.timer) {
											clearInterval(this.timer);
										}
										this.isVideoPlaybackQualityAvailable = false;
									};
									_proto.onMediaAttaching = function onMediaAttaching(data) {
										var config = this.hls.config;
										if (config.capLevelOnFPSDrop) {
											var video = (this.video =
												data.media instanceof window.HTMLVideoElement
													? data.media
													: null);
											if (typeof video.getVideoPlaybackQuality === "function") {
												this.isVideoPlaybackQualityAvailable = true;
											}
											clearInterval(this.timer);
											this.timer = setInterval(
												this.checkFPSInterval.bind(this),
												config.fpsDroppedMonitoringPeriod
											);
										}
									};
									_proto.checkFPS = function checkFPS(
										video,
										decodedFrames,
										droppedFrames
									) {
										var currentTime = fps_controller_performance.now();
										if (decodedFrames) {
											if (this.lastTime) {
												var currentPeriod = currentTime - this.lastTime,
													currentDropped =
														droppedFrames - this.lastDroppedFrames,
													currentDecoded =
														decodedFrames - this.lastDecodedFrames,
													droppedFPS = (1e3 * currentDropped) / currentPeriod,
													hls = this.hls;
												hls.trigger(events["default"].FPS_DROP, {
													currentDropped: currentDropped,
													currentDecoded: currentDecoded,
													totalDroppedFrames: droppedFrames,
												});
												if (droppedFPS > 0) {
													if (
														currentDropped >
														hls.config.fpsDroppedMonitoringThreshold *
															currentDecoded
													) {
														var currentLevel = hls.currentLevel;
														logger["logger"].warn(
															"drop FPS ratio greater than max allowed value for currentLevel: " +
																currentLevel
														);
														if (
															currentLevel > 0 &&
															(hls.autoLevelCapping === -1 ||
																hls.autoLevelCapping >= currentLevel)
														) {
															currentLevel = currentLevel - 1;
															hls.trigger(
																events["default"].FPS_DROP_LEVEL_CAPPING,
																{
																	level: currentLevel,
																	droppedLevel: hls.currentLevel,
																}
															);
															hls.autoLevelCapping = currentLevel;
															hls.streamController.nextLevelSwitch();
														}
													}
												}
											}
											this.lastTime = currentTime;
											this.lastDroppedFrames = droppedFrames;
											this.lastDecodedFrames = decodedFrames;
										}
									};
									_proto.checkFPSInterval = function checkFPSInterval() {
										var video = this.video;
										if (video) {
											if (this.isVideoPlaybackQualityAvailable) {
												var videoPlaybackQuality =
													video.getVideoPlaybackQuality();
												this.checkFPS(
													video,
													videoPlaybackQuality.totalVideoFrames,
													videoPlaybackQuality.droppedVideoFrames
												);
											} else {
												this.checkFPS(
													video,
													video.webkitDecodedFrameCount,
													video.webkitDroppedFrameCount
												);
											}
										}
									};
									return FPSController;
								})(event_handler);
								var fps_controller = fps_controller_FPSController;
								var xhr_loader_XhrLoader = (function () {
									function XhrLoader(config) {
										if (config && config.xhrSetup) {
											this.xhrSetup = config.xhrSetup;
										}
									}
									var _proto = XhrLoader.prototype;
									_proto.destroy = function destroy() {
										this.abort();
										this.loader = null;
									};
									_proto.abort = function abort() {
										var loader = this.loader;
										if (loader && loader.readyState !== 4) {
											this.stats.aborted = true;
											loader.abort();
										}
										window.clearTimeout(this.requestTimeout);
										this.requestTimeout = null;
										window.clearTimeout(this.retryTimeout);
										this.retryTimeout = null;
									};
									_proto.load = function load(context, config, callbacks) {
										this.context = context;
										this.config = config;
										this.callbacks = callbacks;
										this.stats = {
											trequest: window.performance.now(),
											retry: 0,
										};
										this.retryDelay = config.retryDelay;
										this.loadInternal();
									};
									_proto.loadInternal = function loadInternal() {
										var xhr,
											context = this.context;
										xhr = this.loader = new window.XMLHttpRequest();
										var stats = this.stats;
										stats.tfirst = 0;
										stats.loaded = 0;
										var xhrSetup = this.xhrSetup;
										try {
											if (xhrSetup) {
												try {
													xhrSetup(xhr, context.url);
												} catch (e) {
													xhr.open("GET", context.url, true);
													xhrSetup(xhr, context.url);
												}
											}
											if (!xhr.readyState) {
												xhr.open("GET", context.url, true);
											}
										} catch (e) {
											this.callbacks.onError(
												{ code: xhr.status, text: e.message },
												context,
												xhr
											);
											return;
										}
										if (context.rangeEnd) {
											xhr.setRequestHeader(
												"Range",
												"bytes=" +
													context.rangeStart +
													"-" +
													(context.rangeEnd - 1)
											);
										}
										xhr.onreadystatechange = this.readystatechange.bind(this);
										xhr.onprogress = this.loadprogress.bind(this);
										xhr.responseType = context.responseType;
										this.requestTimeout = window.setTimeout(
											this.loadtimeout.bind(this),
											this.config.timeout
										);
										xhr.send();
									};
									_proto.readystatechange = function readystatechange(event) {
										var xhr = event.currentTarget,
											readyState = xhr.readyState,
											stats = this.stats,
											context = this.context,
											config = this.config;
										if (stats.aborted) {
											return;
										}
										if (readyState >= 2) {
											window.clearTimeout(this.requestTimeout);
											if (stats.tfirst === 0) {
												stats.tfirst = Math.max(
													window.performance.now(),
													stats.trequest
												);
											}
											if (readyState === 4) {
												var status = xhr.status;
												if (status >= 200 && status < 300) {
													stats.tload = Math.max(
														stats.tfirst,
														window.performance.now()
													);
													var data, len;
													if (context.responseType === "arraybuffer") {
														data = xhr.response;
														len = data.byteLength;
													} else {
														data = xhr.responseText;
														len = data.length;
													}
													stats.loaded = stats.total = len;
													var response = { url: xhr.responseURL, data: data };
													this.callbacks.onSuccess(
														response,
														stats,
														context,
														xhr
													);
												} else {
													if (
														stats.retry >= config.maxRetry ||
														(status >= 400 && status < 499)
													) {
														logger["logger"].error(
															status + " while loading " + context.url
														);
														this.callbacks.onError(
															{ code: status, text: xhr.statusText },
															context,
															xhr
														);
													} else {
														logger["logger"].warn(
															status +
																" while loading " +
																context.url +
																", retrying in " +
																this.retryDelay +
																"..."
														);
														this.destroy();
														this.retryTimeout = window.setTimeout(
															this.loadInternal.bind(this),
															this.retryDelay
														);
														this.retryDelay = Math.min(
															2 * this.retryDelay,
															config.maxRetryDelay
														);
														stats.retry++;
													}
												}
											} else {
												this.requestTimeout = window.setTimeout(
													this.loadtimeout.bind(this),
													config.timeout
												);
											}
										}
									};
									_proto.loadtimeout = function loadtimeout() {
										logger["logger"].warn(
											"timeout while loading " + this.context.url
										);
										this.callbacks.onTimeout(this.stats, this.context, null);
									};
									_proto.loadprogress = function loadprogress(event) {
										var xhr = event.currentTarget,
											stats = this.stats;
										stats.loaded = event.loaded;
										if (event.lengthComputable) {
											stats.total = event.total;
										}
										var onProgress = this.callbacks.onProgress;
										if (onProgress) {
											onProgress(stats, this.context, null, xhr);
										}
									};
									return XhrLoader;
								})();
								var xhr_loader = xhr_loader_XhrLoader;
								function audio_track_controller_defineProperties(
									target,
									props
								) {
									for (var i = 0; i < props.length; i++) {
										var descriptor = props[i];
										descriptor.enumerable = descriptor.enumerable || false;
										descriptor.configurable = true;
										if ("value" in descriptor) descriptor.writable = true;
										Object.defineProperty(target, descriptor.key, descriptor);
									}
								}
								function audio_track_controller_createClass(
									Constructor,
									protoProps,
									staticProps
								) {
									if (protoProps)
										audio_track_controller_defineProperties(
											Constructor.prototype,
											protoProps
										);
									if (staticProps)
										audio_track_controller_defineProperties(
											Constructor,
											staticProps
										);
									return Constructor;
								}
								function audio_track_controller_inheritsLoose(
									subClass,
									superClass
								) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var audio_track_controller_AudioTrackController = (function (
									_TaskLoop
								) {
									audio_track_controller_inheritsLoose(
										AudioTrackController,
										_TaskLoop
									);
									function AudioTrackController(hls) {
										var _this;
										_this =
											_TaskLoop.call(
												this,
												hls,
												events["default"].MANIFEST_LOADING,
												events["default"].MANIFEST_PARSED,
												events["default"].AUDIO_TRACK_LOADED,
												events["default"].AUDIO_TRACK_SWITCHED,
												events["default"].LEVEL_LOADED,
												events["default"].ERROR
											) || this;
										_this._trackId = -1;
										_this._selectDefaultTrack = true;
										_this.tracks = [];
										_this.trackIdBlacklist = Object.create(null);
										_this.audioGroupId = null;
										return _this;
									}
									var _proto = AudioTrackController.prototype;
									_proto.onManifestLoading = function onManifestLoading() {
										this.tracks = [];
										this._trackId = -1;
										this._selectDefaultTrack = true;
									};
									_proto.onManifestParsed = function onManifestParsed(data) {
										var tracks = (this.tracks = data.audioTracks || []);
										this.hls.trigger(events["default"].AUDIO_TRACKS_UPDATED, {
											audioTracks: tracks,
										});
										this._selectAudioGroup(this.hls.nextLoadLevel);
									};
									_proto.onAudioTrackLoaded = function onAudioTrackLoaded(
										data
									) {
										if (data.id >= this.tracks.length) {
											logger["logger"].warn("Invalid audio track id:", data.id);
											return;
										}
										logger["logger"].log("audioTrack " + data.id + " loaded");
										this.tracks[data.id].details = data.details;
										if (data.details.live && !this.hasInterval()) {
											var updatePeriodMs = data.details.targetduration * 1e3;
											this.setInterval(updatePeriodMs);
										}
										if (!data.details.live && this.hasInterval()) {
											this.clearInterval();
										}
									};
									_proto.onAudioTrackSwitched = function onAudioTrackSwitched(
										data
									) {
										var audioGroupId = this.tracks[data.id].groupId;
										if (audioGroupId && this.audioGroupId !== audioGroupId) {
											this.audioGroupId = audioGroupId;
										}
									};
									_proto.onLevelLoaded = function onLevelLoaded(data) {
										this._selectAudioGroup(data.level);
									};
									_proto.onError = function onError(data) {
										if (data.type !== errors["ErrorTypes"].NETWORK_ERROR) {
											return;
										}
										if (data.fatal) {
											this.clearInterval();
										}
										if (
											data.details !==
											errors["ErrorDetails"].AUDIO_TRACK_LOAD_ERROR
										) {
											return;
										}
										logger["logger"].warn(
											"Network failure on audio-track id:",
											data.context.id
										);
										this._handleLoadError();
									};
									_proto._setAudioTrack = function _setAudioTrack(newId) {
										if (
											this._trackId === newId &&
											this.tracks[this._trackId].details
										) {
											logger["logger"].debug(
												"Same id as current audio-track passed, and track details available -> no-op"
											);
											return;
										}
										if (newId < 0 || newId >= this.tracks.length) {
											logger["logger"].warn(
												"Invalid id passed to audio-track controller"
											);
											return;
										}
										var audioTrack = this.tracks[newId];
										logger["logger"].log(
											"Now switching to audio-track index " + newId
										);
										this.clearInterval();
										this._trackId = newId;
										var url = audioTrack.url,
											type = audioTrack.type,
											id = audioTrack.id;
										this.hls.trigger(events["default"].AUDIO_TRACK_SWITCHING, {
											id: id,
											type: type,
											url: url,
										});
										this._loadTrackDetailsIfNeeded(audioTrack);
									};
									_proto.doTick = function doTick() {
										this._updateTrack(this._trackId);
									};
									_proto._selectAudioGroup = function _selectAudioGroup(
										levelId
									) {
										var levelInfo = this.hls.levels[levelId];
										if (!levelInfo || !levelInfo.audioGroupIds) {
											return;
										}
										var audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];
										if (this.audioGroupId !== audioGroupId) {
											this.audioGroupId = audioGroupId;
											this._selectInitialAudioTrack();
										}
									};
									_proto._selectInitialAudioTrack =
										function _selectInitialAudioTrack() {
											var _this2 = this;
											var tracks = this.tracks;
											if (!tracks.length) {
												return;
											}
											var currentAudioTrack = this.tracks[this._trackId];
											var name = null;
											if (currentAudioTrack) {
												name = currentAudioTrack.name;
											}
											if (this._selectDefaultTrack) {
												var defaultTracks = tracks.filter(function (track) {
													return track.default;
												});
												if (defaultTracks.length) {
													tracks = defaultTracks;
												} else {
													logger["logger"].warn(
														"No default audio tracks defined"
													);
												}
											}
											var trackFound = false;
											var traverseTracks = function traverseTracks() {
												tracks.forEach(function (track) {
													if (trackFound) {
														return;
													}
													if (
														(!_this2.audioGroupId ||
															track.groupId === _this2.audioGroupId) &&
														(!name || name === track.name)
													) {
														_this2._setAudioTrack(track.id);
														trackFound = true;
													}
												});
											};
											traverseTracks();
											if (!trackFound) {
												name = null;
												traverseTracks();
											}
											if (!trackFound) {
												logger["logger"].error(
													"No track found for running audio group-ID: " +
														this.audioGroupId
												);
												this.hls.trigger(events["default"].ERROR, {
													type: errors["ErrorTypes"].MEDIA_ERROR,
													details:
														errors["ErrorDetails"].AUDIO_TRACK_LOAD_ERROR,
													fatal: true,
												});
											}
										};
									_proto._needsTrackLoading = function _needsTrackLoading(
										audioTrack
									) {
										var details = audioTrack.details,
											url = audioTrack.url;
										if (!details || details.live) {
											return !!url;
										}
										return false;
									};
									_proto._loadTrackDetailsIfNeeded =
										function _loadTrackDetailsIfNeeded(audioTrack) {
											if (this._needsTrackLoading(audioTrack)) {
												var url = audioTrack.url,
													id = audioTrack.id;
												logger["logger"].log(
													"loading audio-track playlist for id: " + id
												);
												this.hls.trigger(
													events["default"].AUDIO_TRACK_LOADING,
													{ url: url, id: id }
												);
											}
										};
									_proto._updateTrack = function _updateTrack(newId) {
										if (newId < 0 || newId >= this.tracks.length) {
											return;
										}
										this.clearInterval();
										this._trackId = newId;
										logger["logger"].log(
											"trying to update audio-track " + newId
										);
										var audioTrack = this.tracks[newId];
										this._loadTrackDetailsIfNeeded(audioTrack);
									};
									_proto._handleLoadError = function _handleLoadError() {
										this.trackIdBlacklist[this._trackId] = true;
										var previousId = this._trackId;
										var _this$tracks$previous = this.tracks[previousId],
											name = _this$tracks$previous.name,
											language = _this$tracks$previous.language,
											groupId = _this$tracks$previous.groupId;
										logger["logger"].warn(
											"Loading failed on audio track id: " +
												previousId +
												", group-id: " +
												groupId +
												', name/language: "' +
												name +
												'" / "' +
												language +
												'"'
										);
										var newId = previousId;
										for (var i = 0; i < this.tracks.length; i++) {
											if (this.trackIdBlacklist[i]) {
												continue;
											}
											var newTrack = this.tracks[i];
											if (newTrack.name === name) {
												newId = i;
												break;
											}
										}
										if (newId === previousId) {
											logger["logger"].warn(
												'No fallback audio-track found for name/language: "' +
													name +
													'" / "' +
													language +
													'"'
											);
											return;
										}
										logger["logger"].log(
											"Attempting audio-track fallback id:",
											newId,
											"group-id:",
											this.tracks[newId].groupId
										);
										this._setAudioTrack(newId);
									};
									audio_track_controller_createClass(AudioTrackController, [
										{
											key: "audioTracks",
											get: function get() {
												return this.tracks;
											},
										},
										{
											key: "audioTrack",
											get: function get() {
												return this._trackId;
											},
											set: function set(newId) {
												this._setAudioTrack(newId);
												this._selectDefaultTrack = false;
											},
										},
									]);
									return AudioTrackController;
								})(TaskLoop);
								var audio_track_controller =
									audio_track_controller_AudioTrackController;
								function audio_stream_controller_defineProperties(
									target,
									props
								) {
									for (var i = 0; i < props.length; i++) {
										var descriptor = props[i];
										descriptor.enumerable = descriptor.enumerable || false;
										descriptor.configurable = true;
										if ("value" in descriptor) descriptor.writable = true;
										Object.defineProperty(target, descriptor.key, descriptor);
									}
								}
								function audio_stream_controller_createClass(
									Constructor,
									protoProps,
									staticProps
								) {
									if (protoProps)
										audio_stream_controller_defineProperties(
											Constructor.prototype,
											protoProps
										);
									if (staticProps)
										audio_stream_controller_defineProperties(
											Constructor,
											staticProps
										);
									return Constructor;
								}
								function audio_stream_controller_inheritsLoose(
									subClass,
									superClass
								) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var audio_stream_controller_window = window,
									audio_stream_controller_performance =
										audio_stream_controller_window.performance;
								var audio_stream_controller_TICK_INTERVAL = 100;
								var audio_stream_controller_AudioStreamController = (function (
									_BaseStreamController
								) {
									audio_stream_controller_inheritsLoose(
										AudioStreamController,
										_BaseStreamController
									);
									function AudioStreamController(hls, fragmentTracker) {
										var _this;
										_this =
											_BaseStreamController.call(
												this,
												hls,
												events["default"].MEDIA_ATTACHED,
												events["default"].MEDIA_DETACHING,
												events["default"].AUDIO_TRACKS_UPDATED,
												events["default"].AUDIO_TRACK_SWITCHING,
												events["default"].AUDIO_TRACK_LOADED,
												events["default"].KEY_LOADED,
												events["default"].FRAG_LOADED,
												events["default"].FRAG_PARSING_INIT_SEGMENT,
												events["default"].FRAG_PARSING_DATA,
												events["default"].FRAG_PARSED,
												events["default"].ERROR,
												events["default"].BUFFER_RESET,
												events["default"].BUFFER_CREATED,
												events["default"].BUFFER_APPENDED,
												events["default"].BUFFER_FLUSHED,
												events["default"].INIT_PTS_FOUND
											) || this;
										_this.fragmentTracker = fragmentTracker;
										_this.config = hls.config;
										_this.audioCodecSwap = false;
										_this._state = State.STOPPED;
										_this.initPTS = [];
										_this.waitingFragment = null;
										_this.videoTrackCC = null;
										_this.waitingVideoCC = null;
										return _this;
									}
									var _proto = AudioStreamController.prototype;
									_proto.onInitPtsFound = function onInitPtsFound(data) {
										var demuxerId = data.id,
											cc = data.frag.cc,
											initPTS = data.initPTS;
										if (demuxerId === "main") {
											this.initPTS[cc] = initPTS;
											this.videoTrackCC = cc;
											logger["logger"].log(
												"InitPTS for cc: " + cc + " found from main: " + initPTS
											);
											if (this.state === State.WAITING_INIT_PTS) {
												this.tick();
											}
										}
									};
									_proto.startLoad = function startLoad(startPosition) {
										if (this.tracks) {
											var lastCurrentTime = this.lastCurrentTime;
											this.stopLoad();
											this.setInterval(audio_stream_controller_TICK_INTERVAL);
											this.fragLoadError = 0;
											if (lastCurrentTime > 0 && startPosition === -1) {
												logger["logger"].log(
													"audio:override startPosition with lastCurrentTime @" +
														lastCurrentTime.toFixed(3)
												);
												this.state = State.IDLE;
											} else {
												this.lastCurrentTime = this.startPosition
													? this.startPosition
													: startPosition;
												this.state = State.STARTING;
											}
											this.nextLoadPosition = this.startPosition =
												this.lastCurrentTime;
											this.tick();
										} else {
											this.startPosition = startPosition;
											this.state = State.STOPPED;
										}
									};
									_proto.doTick = function doTick() {
										var pos,
											track,
											trackDetails,
											hls = this.hls,
											config = hls.config;
										switch (this.state) {
											case State.ERROR:
											case State.PAUSED:
											case State.BUFFER_FLUSHING:
												break;
											case State.STARTING:
												this.state = State.WAITING_TRACK;
												this.loadedmetadata = false;
												break;
											case State.IDLE:
												var tracks = this.tracks;
												if (!tracks) {
													break;
												}
												if (
													!this.media &&
													(this.startFragRequested || !config.startFragPrefetch)
												) {
													break;
												}
												if (this.loadedmetadata) {
													pos = this.media.currentTime;
												} else {
													pos = this.nextLoadPosition;
													if (pos === undefined) {
														break;
													}
												}
												var media = this.mediaBuffer
													? this.mediaBuffer
													: this.media;
												var videoBuffer = this.videoBuffer
													? this.videoBuffer
													: this.media;
												var maxBufferHole =
													pos < config.maxBufferHole
														? Math.max(MAX_START_GAP_JUMP, config.maxBufferHole)
														: config.maxBufferHole;
												var bufferInfo = BufferHelper.bufferInfo(
													media,
													pos,
													maxBufferHole
												);
												var mainBufferInfo = BufferHelper.bufferInfo(
													videoBuffer,
													pos,
													maxBufferHole
												);
												var bufferLen = bufferInfo.len;
												var bufferEnd = bufferInfo.end;
												var fragPrevious = this.fragPrevious;
												var maxConfigBuffer = Math.min(
													config.maxBufferLength,
													config.maxMaxBufferLength
												);
												var maxBufLen = Math.max(
													maxConfigBuffer,
													mainBufferInfo.len
												);
												var audioSwitch = this.audioSwitch;
												var trackId = this.trackId;
												if (
													(bufferLen < maxBufLen || audioSwitch) &&
													trackId < tracks.length
												) {
													trackDetails = tracks[trackId].details;
													if (typeof trackDetails === "undefined") {
														this.state = State.WAITING_TRACK;
														break;
													}
													if (
														!audioSwitch &&
														this._streamEnded(bufferInfo, trackDetails)
													) {
														this.hls.trigger(events["default"].BUFFER_EOS, {
															type: "audio",
														});
														this.state = State.ENDED;
														return;
													}
													var fragments = trackDetails.fragments,
														fragLen = fragments.length,
														start = fragments[0].start,
														end =
															fragments[fragLen - 1].start +
															fragments[fragLen - 1].duration,
														frag;
													if (audioSwitch) {
														if (trackDetails.live && !trackDetails.PTSKnown) {
															logger["logger"].log(
																"switching audiotrack, live stream, unknown PTS,load first fragment"
															);
															bufferEnd = 0;
														} else {
															bufferEnd = pos;
															if (trackDetails.PTSKnown && pos < start) {
																if (
																	bufferInfo.end > start ||
																	bufferInfo.nextStart
																) {
																	logger["logger"].log(
																		"alt audio track ahead of main track, seek to start of alt audio track"
																	);
																	this.media.currentTime = start + 0.05;
																} else {
																	return;
																}
															}
														}
													}
													if (
														trackDetails.initSegment &&
														!trackDetails.initSegment.data
													) {
														frag = trackDetails.initSegment;
													} else if (bufferEnd <= start) {
														frag = fragments[0];
														if (
															this.videoTrackCC !== null &&
															frag.cc !== this.videoTrackCC
														) {
															frag = findFragWithCC(
																fragments,
																this.videoTrackCC
															);
														}
														if (
															trackDetails.live &&
															frag.loadIdx &&
															frag.loadIdx === this.fragLoadIdx
														) {
															var nextBuffered = bufferInfo.nextStart
																? bufferInfo.nextStart
																: start;
															logger["logger"].log(
																"no alt audio available @currentTime:" +
																	this.media.currentTime +
																	", seeking @" +
																	(nextBuffered + 0.05)
															);
															this.media.currentTime = nextBuffered + 0.05;
															return;
														}
													} else {
														var foundFrag;
														var maxFragLookUpTolerance =
															config.maxFragLookUpTolerance;
														var fragNext = fragPrevious
															? fragments[fragPrevious.sn - fragments[0].sn + 1]
															: undefined;
														if (bufferEnd < end) {
															if (bufferEnd > end - maxFragLookUpTolerance) {
																maxFragLookUpTolerance = 0;
															}
															if (
																fragNext &&
																!fragmentWithinToleranceTest(
																	bufferEnd,
																	maxFragLookUpTolerance,
																	fragNext
																)
															) {
																foundFrag = fragNext;
															} else {
																foundFrag = binary_search.search(
																	fragments,
																	function (frag) {
																		return fragmentWithinToleranceTest(
																			bufferEnd,
																			maxFragLookUpTolerance,
																			frag
																		);
																	}
																);
															}
														} else {
															foundFrag = fragments[fragLen - 1];
														}
														if (foundFrag) {
															frag = foundFrag;
															start = foundFrag.start;
															if (
																fragPrevious &&
																frag.level === fragPrevious.level &&
																frag.sn === fragPrevious.sn
															) {
																if (frag.sn < trackDetails.endSN) {
																	frag =
																		fragments[
																			frag.sn + 1 - trackDetails.startSN
																		];
																	if (
																		this.fragmentTracker.getState(frag) !==
																		FragmentState.OK
																	) {
																		logger["logger"].log(
																			"SN just loaded, load next one: " +
																				frag.sn
																		);
																	}
																} else {
																	frag = null;
																}
															}
														}
													}
													if (frag) {
														if (frag.encrypted) {
															logger["logger"].log(
																"Loading key for " +
																	frag.sn +
																	" of [" +
																	trackDetails.startSN +
																	" ," +
																	trackDetails.endSN +
																	"],track " +
																	trackId
															);
															this.state = State.KEY_LOADING;
															hls.trigger(events["default"].KEY_LOADING, {
																frag: frag,
															});
														} else {
															this.fragCurrent = frag;
															if (
																audioSwitch ||
																this.fragmentTracker.getState(frag) ===
																	FragmentState.NOT_LOADED
															) {
																logger["logger"].log(
																	"Loading " +
																		frag.sn +
																		", cc: " +
																		frag.cc +
																		" of [" +
																		trackDetails.startSN +
																		" ," +
																		trackDetails.endSN +
																		"],track " +
																		trackId +
																		", " +
																		(this.loadedmetadata
																			? "currentTime"
																			: "nextLoadPosition") +
																		": " +
																		pos +
																		", bufferEnd: " +
																		bufferEnd.toFixed(3)
																);
																if (frag.sn !== "initSegment") {
																	this.startFragRequested = true;
																}
																if (Object(number["isFiniteNumber"])(frag.sn)) {
																	this.nextLoadPosition =
																		frag.start + frag.duration;
																}
																hls.trigger(events["default"].FRAG_LOADING, {
																	frag: frag,
																});
																this.state = State.FRAG_LOADING;
															}
														}
													}
												}
												break;
											case State.WAITING_TRACK:
												track = this.tracks[this.trackId];
												if (track && track.details) {
													this.state = State.IDLE;
												}
												break;
											case State.FRAG_LOADING_WAITING_RETRY:
												var now = audio_stream_controller_performance.now();
												var retryDate = this.retryDate;
												media = this.media;
												var isSeeking = media && media.seeking;
												if (!retryDate || now >= retryDate || isSeeking) {
													logger["logger"].log(
														"audioStreamController: retryDate reached, switch back to IDLE state"
													);
													this.state = State.IDLE;
												}
												break;
											case State.WAITING_INIT_PTS:
												var waitingFrag = this.waitingFragment;
												if (waitingFrag) {
													var waitingFragCC = waitingFrag.frag.cc;
													if (this.initPTS[waitingFragCC] !== undefined) {
														this.waitingFragment = null;
														this.state = State.FRAG_LOADING;
														this.onFragLoaded(waitingFrag);
													} else if (
														this.videoTrackCC !== this.waitingVideoCC
													) {
														logger["logger"].log(
															"Waiting fragment cc (" +
																waitingFragCC +
																") cancelled because video is at cc " +
																this.videoTrackCC
														);
														this.clearWaitingFragment();
													} else {
														var _bufferInfo = BufferHelper.bufferInfo(
															this.mediaBuffer,
															this.media.currentTime,
															config.maxBufferHole
														);
														var waitingFragmentAtPosition =
															fragmentWithinToleranceTest(
																_bufferInfo.end,
																config.maxFragLookUpTolerance,
																waitingFrag.frag
															);
														if (waitingFragmentAtPosition < 0) {
															logger["logger"].log(
																"Waiting fragment cc (" +
																	waitingFragCC +
																	") @ " +
																	waitingFrag.frag.start +
																	" cancelled because another fragment at " +
																	_bufferInfo.end +
																	" is needed"
															);
															this.clearWaitingFragment();
														}
													}
												} else {
													this.state = State.IDLE;
												}
												break;
											case State.STOPPED:
											case State.FRAG_LOADING:
											case State.PARSING:
											case State.PARSED:
											case State.ENDED:
												break;
											default:
												break;
										}
									};
									_proto.clearWaitingFragment =
										function clearWaitingFragment() {
											var waitingFrag = this.waitingFragment;
											if (waitingFrag) {
												this.fragmentTracker.removeFragment(waitingFrag.frag);
												this.waitingFragment = null;
												this.waitingVideoCC = null;
												this.state = State.IDLE;
											}
										};
									_proto.onMediaAttached = function onMediaAttached(data) {
										var media = (this.media = this.mediaBuffer = data.media);
										this.onvseeking = this.onMediaSeeking.bind(this);
										this.onvended = this.onMediaEnded.bind(this);
										media.addEventListener("seeking", this.onvseeking);
										media.addEventListener("ended", this.onvended);
										var config = this.config;
										if (this.tracks && config.autoStartLoad) {
											this.startLoad(config.startPosition);
										}
									};
									_proto.onMediaDetaching = function onMediaDetaching() {
										var media = this.media;
										if (media && media.ended) {
											logger["logger"].log(
												"MSE detaching and video ended, reset startPosition"
											);
											this.startPosition = this.lastCurrentTime = 0;
										}
										if (media) {
											media.removeEventListener("seeking", this.onvseeking);
											media.removeEventListener("ended", this.onvended);
											this.onvseeking = this.onvseeked = this.onvended = null;
										}
										this.media = this.mediaBuffer = this.videoBuffer = null;
										this.loadedmetadata = false;
										this.fragmentTracker.removeAllFragments();
										this.stopLoad();
									};
									_proto.onAudioTracksUpdated = function onAudioTracksUpdated(
										data
									) {
										logger["logger"].log("audio tracks updated");
										this.tracks = data.audioTracks;
									};
									_proto.onAudioTrackSwitching = function onAudioTrackSwitching(
										data
									) {
										var altAudio = !!data.url;
										this.trackId = data.id;
										this.fragCurrent = null;
										this.clearWaitingFragment();
										this.state = State.PAUSED;
										if (!altAudio) {
											if (this.demuxer) {
												this.demuxer.destroy();
												this.demuxer = null;
											}
										} else {
											this.setInterval(audio_stream_controller_TICK_INTERVAL);
										}
										if (altAudio) {
											this.audioSwitch = true;
											this.state = State.IDLE;
										}
										this.tick();
									};
									_proto.onAudioTrackLoaded = function onAudioTrackLoaded(
										data
									) {
										var newDetails = data.details,
											trackId = data.id,
											track = this.tracks[trackId],
											curDetails = track.details,
											duration = newDetails.totalduration,
											sliding = 0;
										logger["logger"].log(
											"track " +
												trackId +
												" loaded [" +
												newDetails.startSN +
												"," +
												newDetails.endSN +
												"],duration:" +
												duration
										);
										if (newDetails.live || (curDetails && curDetails.live)) {
											if (curDetails && newDetails.fragments.length > 0) {
												mergeDetails(curDetails, newDetails);
												sliding = newDetails.fragments[0].start;
												if (newDetails.PTSKnown) {
													logger["logger"].log(
														"live audio playlist sliding:" + sliding.toFixed(3)
													);
												} else {
													logger["logger"].log(
														"live audio playlist - outdated PTS, unknown sliding"
													);
												}
											} else {
												newDetails.PTSKnown = false;
												logger["logger"].log(
													"live audio playlist - first load, unknown sliding"
												);
											}
										} else {
											newDetails.PTSKnown = false;
										}
										track.details = newDetails;
										if (!this.startFragRequested) {
											if (this.startPosition === -1) {
												var startTimeOffset = newDetails.startTimeOffset;
												if (Object(number["isFiniteNumber"])(startTimeOffset)) {
													logger["logger"].log(
														"start time offset found in playlist, adjust startPosition to " +
															startTimeOffset
													);
													this.startPosition = startTimeOffset;
												} else {
													if (newDetails.live) {
														this.startPosition = this.computeLivePosition(
															sliding,
															newDetails
														);
														logger["logger"].log(
															"compute startPosition for audio-track to " +
																this.startPosition
														);
													} else {
														this.startPosition = 0;
													}
												}
											}
											this.nextLoadPosition = this.startPosition;
										}
										if (this.state === State.WAITING_TRACK) {
											this.state = State.IDLE;
										}
										this.tick();
									};
									_proto.onKeyLoaded = function onKeyLoaded() {
										if (this.state === State.KEY_LOADING) {
											this.state = State.IDLE;
											this.tick();
										}
									};
									_proto.onFragLoaded = function onFragLoaded(data) {
										var fragCurrent = this.fragCurrent,
											fragLoaded = data.frag;
										if (
											this.state === State.FRAG_LOADING &&
											fragCurrent &&
											fragLoaded.type === "audio" &&
											fragLoaded.level === fragCurrent.level &&
											fragLoaded.sn === fragCurrent.sn
										) {
											var track = this.tracks[this.trackId],
												details = track.details,
												duration = details.totalduration,
												trackId = fragCurrent.level,
												sn = fragCurrent.sn,
												cc = fragCurrent.cc,
												audioCodec =
													this.config.defaultAudioCodec ||
													track.audioCodec ||
													"mp4a.40.2",
												stats = (this.stats = data.stats);
											if (sn === "initSegment") {
												this.state = State.IDLE;
												stats.tparsed = stats.tbuffered =
													audio_stream_controller_performance.now();
												details.initSegment.data = data.payload;
												this.hls.trigger(events["default"].FRAG_BUFFERED, {
													stats: stats,
													frag: fragCurrent,
													id: "audio",
												});
												this.tick();
											} else {
												this.state = State.PARSING;
												this.appended = false;
												if (!this.demuxer) {
													this.demuxer = new demux_demuxer(this.hls, "audio");
												}
												var initPTS = this.initPTS[cc];
												var initSegmentData = details.initSegment
													? details.initSegment.data
													: [];
												if (initPTS !== undefined) {
													this.pendingBuffering = true;
													logger["logger"].log(
														"Demuxing " +
															sn +
															" of [" +
															details.startSN +
															" ," +
															details.endSN +
															"],track " +
															trackId
													);
													var accurateTimeOffset = false;
													this.demuxer.push(
														data.payload,
														initSegmentData,
														audioCodec,
														null,
														fragCurrent,
														duration,
														accurateTimeOffset,
														initPTS
													);
												} else {
													logger["logger"].log(
														"Unknown video PTS for cc " +
															cc +
															", waiting for video PTS before demuxing audio frag " +
															sn +
															" of [" +
															details.startSN +
															" ," +
															details.endSN +
															"],track " +
															trackId
													);
													this.waitingFragment = data;
													this.waitingVideoCC = this.videoTrackCC;
													this.state = State.WAITING_INIT_PTS;
												}
											}
										}
										this.fragLoadError = 0;
									};
									_proto.onFragParsingInitSegment =
										function onFragParsingInitSegment(data) {
											var fragCurrent = this.fragCurrent;
											var fragNew = data.frag;
											if (
												fragCurrent &&
												data.id === "audio" &&
												fragNew.sn === fragCurrent.sn &&
												fragNew.level === fragCurrent.level &&
												this.state === State.PARSING
											) {
												var tracks = data.tracks,
													track;
												if (tracks.video) {
													delete tracks.video;
												}
												track = tracks.audio;
												if (track) {
													track.levelCodec = track.codec;
													track.id = data.id;
													this.hls.trigger(
														events["default"].BUFFER_CODECS,
														tracks
													);
													logger["logger"].log(
														"audio track:audio,container:" +
															track.container +
															",codecs[level/parsed]=[" +
															track.levelCodec +
															"/" +
															track.codec +
															"]"
													);
													var initSegment = track.initSegment;
													if (initSegment) {
														var appendObj = {
															type: "audio",
															data: initSegment,
															parent: "audio",
															content: "initSegment",
														};
														if (this.audioSwitch) {
															this.pendingData = [appendObj];
														} else {
															this.appended = true;
															this.pendingBuffering = true;
															this.hls.trigger(
																events["default"].BUFFER_APPENDING,
																appendObj
															);
														}
													}
													this.tick();
												}
											}
										};
									_proto.onFragParsingData = function onFragParsingData(data) {
										var _this2 = this;
										var fragCurrent = this.fragCurrent;
										var fragNew = data.frag;
										if (
											fragCurrent &&
											data.id === "audio" &&
											data.type === "audio" &&
											fragNew.sn === fragCurrent.sn &&
											fragNew.level === fragCurrent.level &&
											this.state === State.PARSING
										) {
											var trackId = this.trackId,
												track = this.tracks[trackId],
												hls = this.hls;
											if (!Object(number["isFiniteNumber"])(data.endPTS)) {
												data.endPTS = data.startPTS + fragCurrent.duration;
												data.endDTS = data.startDTS + fragCurrent.duration;
											}
											fragCurrent.addElementaryStream(
												ElementaryStreamTypes.AUDIO
											);
											logger["logger"].log(
												"parsed " +
													data.type +
													",PTS:[" +
													data.startPTS.toFixed(3) +
													"," +
													data.endPTS.toFixed(3) +
													"],DTS:[" +
													data.startDTS.toFixed(3) +
													"/" +
													data.endDTS.toFixed(3) +
													"],nb:" +
													data.nb
											);
											updateFragPTSDTS(
												track.details,
												fragCurrent,
												data.startPTS,
												data.endPTS
											);
											var media = this.media;
											var appendOnBufferFlush = false;
											if (this.audioSwitch) {
												if (media && media.readyState) {
													var currentTime = media.currentTime;
													logger["logger"].log(
														"switching audio track : currentTime:" + currentTime
													);
													if (currentTime >= data.startPTS) {
														logger["logger"].log(
															"switching audio track : flushing all audio"
														);
														this.state = State.BUFFER_FLUSHING;
														hls.trigger(events["default"].BUFFER_FLUSHING, {
															startOffset: 0,
															endOffset: Number.POSITIVE_INFINITY,
															type: "audio",
														});
														appendOnBufferFlush = true;
														this.audioSwitch = false;
														hls.trigger(
															events["default"].AUDIO_TRACK_SWITCHED,
															{ id: trackId }
														);
													}
												} else {
													this.audioSwitch = false;
													hls.trigger(events["default"].AUDIO_TRACK_SWITCHED, {
														id: trackId,
													});
												}
											}
											var pendingData = this.pendingData;
											if (!pendingData) {
												logger["logger"].warn(
													"Apparently attempt to enqueue media payload without codec initialization data upfront"
												);
												hls.trigger(events["default"].ERROR, {
													type: errors["ErrorTypes"].MEDIA_ERROR,
													details: null,
													fatal: true,
												});
												return;
											}
											if (!this.audioSwitch) {
												[data.data1, data.data2].forEach(function (buffer) {
													if (buffer && buffer.length) {
														pendingData.push({
															type: data.type,
															data: buffer,
															parent: "audio",
															content: "data",
														});
													}
												});
												if (!appendOnBufferFlush && pendingData.length) {
													pendingData.forEach(function (appendObj) {
														if (_this2.state === State.PARSING) {
															_this2.pendingBuffering = true;
															_this2.hls.trigger(
																events["default"].BUFFER_APPENDING,
																appendObj
															);
														}
													});
													this.pendingData = [];
													this.appended = true;
												}
											}
											this.tick();
										}
									};
									_proto.onFragParsed = function onFragParsed(data) {
										var fragCurrent = this.fragCurrent;
										var fragNew = data.frag;
										if (
											fragCurrent &&
											data.id === "audio" &&
											fragNew.sn === fragCurrent.sn &&
											fragNew.level === fragCurrent.level &&
											this.state === State.PARSING
										) {
											this.stats.tparsed =
												audio_stream_controller_performance.now();
											this.state = State.PARSED;
											this._checkAppendedParsed();
										}
									};
									_proto.onBufferReset = function onBufferReset() {
										this.mediaBuffer = this.videoBuffer = null;
										this.loadedmetadata = false;
									};
									_proto.onBufferCreated = function onBufferCreated(data) {
										var audioTrack = data.tracks.audio;
										if (audioTrack) {
											this.mediaBuffer = audioTrack.buffer;
											this.loadedmetadata = true;
										}
										if (data.tracks.video) {
											this.videoBuffer = data.tracks.video.buffer;
										}
									};
									_proto.onBufferAppended = function onBufferAppended(data) {
										if (data.parent === "audio") {
											var state = this.state;
											if (state === State.PARSING || state === State.PARSED) {
												this.pendingBuffering = data.pending > 0;
												this._checkAppendedParsed();
											}
										}
									};
									_proto._checkAppendedParsed =
										function _checkAppendedParsed() {
											if (
												this.state === State.PARSED &&
												(!this.appended || !this.pendingBuffering)
											) {
												var frag = this.fragCurrent,
													stats = this.stats,
													hls = this.hls;
												if (frag) {
													this.fragPrevious = frag;
													stats.tbuffered =
														audio_stream_controller_performance.now();
													hls.trigger(events["default"].FRAG_BUFFERED, {
														stats: stats,
														frag: frag,
														id: "audio",
													});
													var media = this.mediaBuffer
														? this.mediaBuffer
														: this.media;
													if (media) {
														logger["logger"].log(
															"audio buffered : " +
																time_ranges.toString(media.buffered)
														);
													}
													if (this.audioSwitch && this.appended) {
														this.audioSwitch = false;
														hls.trigger(
															events["default"].AUDIO_TRACK_SWITCHED,
															{ id: this.trackId }
														);
													}
													this.state = State.IDLE;
												}
												this.tick();
											}
										};
									_proto.onError = function onError(data) {
										var frag = data.frag;
										if (frag && frag.type !== "audio") {
											return;
										}
										switch (data.details) {
											case errors["ErrorDetails"].FRAG_LOAD_ERROR:
											case errors["ErrorDetails"].FRAG_LOAD_TIMEOUT:
												var _frag = data.frag;
												if (_frag && _frag.type !== "audio") {
													break;
												}
												if (!data.fatal) {
													var loadError = this.fragLoadError;
													if (loadError) {
														loadError++;
													} else {
														loadError = 1;
													}
													var config = this.config;
													if (loadError <= config.fragLoadingMaxRetry) {
														this.fragLoadError = loadError;
														var delay = Math.min(
															Math.pow(2, loadError - 1) *
																config.fragLoadingRetryDelay,
															config.fragLoadingMaxRetryTimeout
														);
														logger["logger"].warn(
															"AudioStreamController: frag loading failed, retry in " +
																delay +
																" ms"
														);
														this.retryDate =
															audio_stream_controller_performance.now() + delay;
														this.state = State.FRAG_LOADING_WAITING_RETRY;
													} else {
														logger["logger"].error(
															"AudioStreamController: " +
																data.details +
																" reaches max retry, redispatch as fatal ..."
														);
														data.fatal = true;
														this.state = State.ERROR;
													}
												}
												break;
											case errors["ErrorDetails"].AUDIO_TRACK_LOAD_ERROR:
											case errors["ErrorDetails"].AUDIO_TRACK_LOAD_TIMEOUT:
											case errors["ErrorDetails"].KEY_LOAD_ERROR:
											case errors["ErrorDetails"].KEY_LOAD_TIMEOUT:
												if (this.state !== State.ERROR) {
													this.state = data.fatal ? State.ERROR : State.IDLE;
													logger["logger"].warn(
														"AudioStreamController: " +
															data.details +
															" while loading frag, now switching to " +
															this.state +
															" state ..."
													);
												}
												break;
											case errors["ErrorDetails"].BUFFER_FULL_ERROR:
												if (
													data.parent === "audio" &&
													(this.state === State.PARSING ||
														this.state === State.PARSED)
												) {
													var media = this.mediaBuffer,
														currentTime = this.media.currentTime,
														mediaBuffered =
															media &&
															BufferHelper.isBuffered(media, currentTime) &&
															BufferHelper.isBuffered(media, currentTime + 0.5);
													if (mediaBuffered) {
														var _config = this.config;
														if (
															_config.maxMaxBufferLength >=
															_config.maxBufferLength
														) {
															_config.maxMaxBufferLength /= 2;
															logger["logger"].warn(
																"AudioStreamController: reduce max buffer length to " +
																	_config.maxMaxBufferLength +
																	"s"
															);
														}
														this.state = State.IDLE;
													} else {
														logger["logger"].warn(
															"AudioStreamController: buffer full error also media.currentTime is not buffered, flush audio buffer"
														);
														this.fragCurrent = null;
														this.state = State.BUFFER_FLUSHING;
														this.hls.trigger(
															events["default"].BUFFER_FLUSHING,
															{
																startOffset: 0,
																endOffset: Number.POSITIVE_INFINITY,
																type: "audio",
															}
														);
													}
												}
												break;
											default:
												break;
										}
									};
									_proto.onBufferFlushed = function onBufferFlushed() {
										var _this3 = this;
										var pendingData = this.pendingData;
										if (pendingData && pendingData.length) {
											logger["logger"].log(
												"AudioStreamController: appending pending audio data after buffer flushed"
											);
											pendingData.forEach(function (appendObj) {
												_this3.hls.trigger(
													events["default"].BUFFER_APPENDING,
													appendObj
												);
											});
											this.appended = true;
											this.pendingData = [];
											this.state = State.PARSED;
										} else {
											this.state = State.IDLE;
											this.fragPrevious = null;
											this.tick();
										}
									};
									audio_stream_controller_createClass(AudioStreamController, [
										{
											key: "state",
											set: function set(nextState) {
												if (this.state !== nextState) {
													var previousState = this.state;
													this._state = nextState;
													logger["logger"].log(
														"audio stream:" + previousState + "->" + nextState
													);
												}
											},
											get: function get() {
												return this._state;
											},
										},
									]);
									return AudioStreamController;
								})(base_stream_controller_BaseStreamController);
								var audio_stream_controller =
									audio_stream_controller_AudioStreamController;
								var vttcue = (function () {
									if (typeof window !== "undefined" && window.VTTCue) {
										return window.VTTCue;
									}
									var autoKeyword = "auto";
									var directionSetting = { "": true, lr: true, rl: true };
									var alignSetting = {
										start: true,
										middle: true,
										end: true,
										left: true,
										right: true,
									};
									function findDirectionSetting(value) {
										if (typeof value !== "string") {
											return false;
										}
										var dir = directionSetting[value.toLowerCase()];
										return dir ? value.toLowerCase() : false;
									}
									function findAlignSetting(value) {
										if (typeof value !== "string") {
											return false;
										}
										var align = alignSetting[value.toLowerCase()];
										return align ? value.toLowerCase() : false;
									}
									function extend(obj) {
										var i = 1;
										for (; i < arguments.length; i++) {
											var cobj = arguments[i];
											for (var p in cobj) {
												obj[p] = cobj[p];
											}
										}
										return obj;
									}
									function VTTCue(startTime, endTime, text) {
										var cue = this;
										var baseObj = {};
										baseObj.enumerable = true;
										cue.hasBeenReset = false;
										var _id = "";
										var _pauseOnExit = false;
										var _startTime = startTime;
										var _endTime = endTime;
										var _text = text;
										var _region = null;
										var _vertical = "";
										var _snapToLines = true;
										var _line = "auto";
										var _lineAlign = "start";
										var _position = 50;
										var _positionAlign = "middle";
										var _size = 50;
										var _align = "middle";
										Object.defineProperty(
											cue,
											"id",
											extend({}, baseObj, {
												get: function get() {
													return _id;
												},
												set: function set(value) {
													_id = "" + value;
												},
											})
										);
										Object.defineProperty(
											cue,
											"pauseOnExit",
											extend({}, baseObj, {
												get: function get() {
													return _pauseOnExit;
												},
												set: function set(value) {
													_pauseOnExit = !!value;
												},
											})
										);
										Object.defineProperty(
											cue,
											"startTime",
											extend({}, baseObj, {
												get: function get() {
													return _startTime;
												},
												set: function set(value) {
													if (typeof value !== "number") {
														throw new TypeError(
															"Start time must be set to a number."
														);
													}
													_startTime = value;
													this.hasBeenReset = true;
												},
											})
										);
										Object.defineProperty(
											cue,
											"endTime",
											extend({}, baseObj, {
												get: function get() {
													return _endTime;
												},
												set: function set(value) {
													if (typeof value !== "number") {
														throw new TypeError(
															"End time must be set to a number."
														);
													}
													_endTime = value;
													this.hasBeenReset = true;
												},
											})
										);
										Object.defineProperty(
											cue,
											"text",
											extend({}, baseObj, {
												get: function get() {
													return _text;
												},
												set: function set(value) {
													_text = "" + value;
													this.hasBeenReset = true;
												},
											})
										);
										Object.defineProperty(
											cue,
											"region",
											extend({}, baseObj, {
												get: function get() {
													return _region;
												},
												set: function set(value) {
													_region = value;
													this.hasBeenReset = true;
												},
											})
										);
										Object.defineProperty(
											cue,
											"vertical",
											extend({}, baseObj, {
												get: function get() {
													return _vertical;
												},
												set: function set(value) {
													var setting = findDirectionSetting(value);
													if (setting === false) {
														throw new SyntaxError(
															"An invalid or illegal string was specified."
														);
													}
													_vertical = setting;
													this.hasBeenReset = true;
												},
											})
										);
										Object.defineProperty(
											cue,
											"snapToLines",
											extend({}, baseObj, {
												get: function get() {
													return _snapToLines;
												},
												set: function set(value) {
													_snapToLines = !!value;
													this.hasBeenReset = true;
												},
											})
										);
										Object.defineProperty(
											cue,
											"line",
											extend({}, baseObj, {
												get: function get() {
													return _line;
												},
												set: function set(value) {
													if (
														typeof value !== "number" &&
														value !== autoKeyword
													) {
														throw new SyntaxError(
															"An invalid number or illegal string was specified."
														);
													}
													_line = value;
													this.hasBeenReset = true;
												},
											})
										);
										Object.defineProperty(
											cue,
											"lineAlign",
											extend({}, baseObj, {
												get: function get() {
													return _lineAlign;
												},
												set: function set(value) {
													var setting = findAlignSetting(value);
													if (!setting) {
														throw new SyntaxError(
															"An invalid or illegal string was specified."
														);
													}
													_lineAlign = setting;
													this.hasBeenReset = true;
												},
											})
										);
										Object.defineProperty(
											cue,
											"position",
											extend({}, baseObj, {
												get: function get() {
													return _position;
												},
												set: function set(value) {
													if (value < 0 || value > 100) {
														throw new Error(
															"Position must be between 0 and 100."
														);
													}
													_position = value;
													this.hasBeenReset = true;
												},
											})
										);
										Object.defineProperty(
											cue,
											"positionAlign",
											extend({}, baseObj, {
												get: function get() {
													return _positionAlign;
												},
												set: function set(value) {
													var setting = findAlignSetting(value);
													if (!setting) {
														throw new SyntaxError(
															"An invalid or illegal string was specified."
														);
													}
													_positionAlign = setting;
													this.hasBeenReset = true;
												},
											})
										);
										Object.defineProperty(
											cue,
											"size",
											extend({}, baseObj, {
												get: function get() {
													return _size;
												},
												set: function set(value) {
													if (value < 0 || value > 100) {
														throw new Error("Size must be between 0 and 100.");
													}
													_size = value;
													this.hasBeenReset = true;
												},
											})
										);
										Object.defineProperty(
											cue,
											"align",
											extend({}, baseObj, {
												get: function get() {
													return _align;
												},
												set: function set(value) {
													var setting = findAlignSetting(value);
													if (!setting) {
														throw new SyntaxError(
															"An invalid or illegal string was specified."
														);
													}
													_align = setting;
													this.hasBeenReset = true;
												},
											})
										);
										cue.displayState = void 0;
									}
									VTTCue.prototype.getCueAsHTML = function () {
										var WebVTT = window.WebVTT;
										return WebVTT.convertCueToDOMTree(window, this.text);
									};
									return VTTCue;
								})();
								var StringDecoder = function StringDecoder() {
									return {
										decode: function decode(data) {
											if (!data) {
												return "";
											}
											if (typeof data !== "string") {
												throw new Error("Error - expected string data.");
											}
											return decodeURIComponent(encodeURIComponent(data));
										},
									};
								};
								function VTTParser() {
									this.window = window;
									this.state = "INITIAL";
									this.buffer = "";
									this.decoder = new StringDecoder();
									this.regionList = [];
								}
								function parseTimeStamp(input) {
									function computeSeconds(h, m, s, f) {
										return (
											(h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1e3
										);
									}
									var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
									if (!m) {
										return null;
									}
									if (m[3]) {
										return computeSeconds(
											m[1],
											m[2],
											m[3].replace(":", ""),
											m[4]
										);
									} else if (m[1] > 59) {
										return computeSeconds(m[1], m[2], 0, m[4]);
									} else {
										return computeSeconds(0, m[1], m[2], m[4]);
									}
								}
								function Settings() {
									this.values = Object.create(null);
								}
								Settings.prototype = {
									set: function set(k, v) {
										if (!this.get(k) && v !== "") {
											this.values[k] = v;
										}
									},
									get: function get(k, dflt, defaultKey) {
										if (defaultKey) {
											return this.has(k) ? this.values[k] : dflt[defaultKey];
										}
										return this.has(k) ? this.values[k] : dflt;
									},
									has: function has(k) {
										return k in this.values;
									},
									alt: function alt(k, v, a) {
										for (var n = 0; n < a.length; ++n) {
											if (v === a[n]) {
												this.set(k, v);
												break;
											}
										}
									},
									integer: function integer(k, v) {
										if (/^-?\d+$/.test(v)) {
											this.set(k, parseInt(v, 10));
										}
									},
									percent: function percent(k, v) {
										var m;
										if ((m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/))) {
											v = parseFloat(v);
											if (v >= 0 && v <= 100) {
												this.set(k, v);
												return true;
											}
										}
										return false;
									},
								};
								function parseOptions(
									input,
									callback,
									keyValueDelim,
									groupDelim
								) {
									var groups = groupDelim ? input.split(groupDelim) : [input];
									for (var i in groups) {
										if (typeof groups[i] !== "string") {
											continue;
										}
										var kv = groups[i].split(keyValueDelim);
										if (kv.length !== 2) {
											continue;
										}
										var k = kv[0];
										var v = kv[1];
										callback(k, v);
									}
								}
								var defaults = new vttcue(0, 0, 0);
								var center = defaults.align === "middle" ? "middle" : "center";
								function parseCue(input, cue, regionList) {
									var oInput = input;
									function consumeTimeStamp() {
										var ts = parseTimeStamp(input);
										if (ts === null) {
											throw new Error("Malformed timestamp: " + oInput);
										}
										input = input.replace(/^[^\sa-zA-Z-]+/, "");
										return ts;
									}
									function consumeCueSettings(input, cue) {
										var settings = new Settings();
										parseOptions(
											input,
											function (k, v) {
												switch (k) {
													case "region":
														for (var i = regionList.length - 1; i >= 0; i--) {
															if (regionList[i].id === v) {
																settings.set(k, regionList[i].region);
																break;
															}
														}
														break;
													case "vertical":
														settings.alt(k, v, ["rl", "lr"]);
														break;
													case "line":
														var vals = v.split(","),
															vals0 = vals[0];
														settings.integer(k, vals0);
														if (settings.percent(k, vals0)) {
															settings.set("snapToLines", false);
														}
														settings.alt(k, vals0, ["auto"]);
														if (vals.length === 2) {
															settings.alt("lineAlign", vals[1], [
																"start",
																center,
																"end",
															]);
														}
														break;
													case "position":
														vals = v.split(",");
														settings.percent(k, vals[0]);
														if (vals.length === 2) {
															settings.alt("positionAlign", vals[1], [
																"start",
																center,
																"end",
																"line-left",
																"line-right",
																"auto",
															]);
														}
														break;
													case "size":
														settings.percent(k, v);
														break;
													case "align":
														settings.alt(k, v, [
															"start",
															center,
															"end",
															"left",
															"right",
														]);
														break;
												}
											},
											/:/,
											/\s/
										);
										cue.region = settings.get("region", null);
										cue.vertical = settings.get("vertical", "");
										var line = settings.get("line", "auto");
										if (line === "auto" && defaults.line === -1) {
											line = -1;
										}
										cue.line = line;
										cue.lineAlign = settings.get("lineAlign", "start");
										cue.snapToLines = settings.get("snapToLines", true);
										cue.size = settings.get("size", 100);
										cue.align = settings.get("align", center);
										var position = settings.get("position", "auto");
										if (position === "auto" && defaults.position === 50) {
											position =
												cue.align === "start" || cue.align === "left"
													? 0
													: cue.align === "end" || cue.align === "right"
													? 100
													: 50;
										}
										cue.position = position;
									}
									function skipWhitespace() {
										input = input.replace(/^\s+/, "");
									}
									skipWhitespace();
									cue.startTime = consumeTimeStamp();
									skipWhitespace();
									if (input.substr(0, 3) !== "--\x3e") {
										throw new Error(
											"Malformed time stamp (time stamps must be separated by '--\x3e'): " +
												oInput
										);
									}
									input = input.substr(3);
									skipWhitespace();
									cue.endTime = consumeTimeStamp();
									skipWhitespace();
									consumeCueSettings(input, cue);
								}
								function fixLineBreaks(input) {
									return input.replace(/<br(?: \/)?>/gi, "\n");
								}
								VTTParser.prototype = {
									parse: function parse(data) {
										var self = this;
										if (data) {
											self.buffer += self.decoder.decode(data, {
												stream: true,
											});
										}
										function collectNextLine() {
											var buffer = self.buffer;
											var pos = 0;
											buffer = fixLineBreaks(buffer);
											while (
												pos < buffer.length &&
												buffer[pos] !== "\r" &&
												buffer[pos] !== "\n"
											) {
												++pos;
											}
											var line = buffer.substr(0, pos);
											if (buffer[pos] === "\r") {
												++pos;
											}
											if (buffer[pos] === "\n") {
												++pos;
											}
											self.buffer = buffer.substr(pos);
											return line;
										}
										function parseHeader(input) {
											parseOptions(
												input,
												function (k, v) {
													switch (k) {
														case "Region":
															break;
													}
												},
												/:/
											);
										}
										try {
											var line;
											if (self.state === "INITIAL") {
												if (!/\r\n|\n/.test(self.buffer)) {
													return this;
												}
												line = collectNextLine();
												var m = line.match(/^()?WEBVTT([ \t].*)?$/);
												if (!m || !m[0]) {
													throw new Error("Malformed WebVTT signature.");
												}
												self.state = "HEADER";
											}
											var alreadyCollectedLine = false;
											while (self.buffer) {
												if (!/\r\n|\n/.test(self.buffer)) {
													return this;
												}
												if (!alreadyCollectedLine) {
													line = collectNextLine();
												} else {
													alreadyCollectedLine = false;
												}
												switch (self.state) {
													case "HEADER":
														if (/:/.test(line)) {
															parseHeader(line);
														} else if (!line) {
															self.state = "ID";
														}
														continue;
													case "NOTE":
														if (!line) {
															self.state = "ID";
														}
														continue;
													case "ID":
														if (/^NOTE($|[ \t])/.test(line)) {
															self.state = "NOTE";
															break;
														}
														if (!line) {
															continue;
														}
														self.cue = new vttcue(0, 0, "");
														self.state = "CUE";
														if (line.indexOf("--\x3e") === -1) {
															self.cue.id = line;
															continue;
														}
													case "CUE":
														try {
															parseCue(line, self.cue, self.regionList);
														} catch (e) {
															self.cue = null;
															self.state = "BADCUE";
															continue;
														}
														self.state = "CUETEXT";
														continue;
													case "CUETEXT":
														var hasSubstring = line.indexOf("--\x3e") !== -1;
														if (
															!line ||
															(hasSubstring && (alreadyCollectedLine = true))
														) {
															if (self.oncue) {
																self.oncue(self.cue);
															}
															self.cue = null;
															self.state = "ID";
															continue;
														}
														if (self.cue.text) {
															self.cue.text += "\n";
														}
														self.cue.text += line;
														continue;
													case "BADCUE":
														if (!line) {
															self.state = "ID";
														}
														continue;
												}
											}
										} catch (e) {
											if (self.state === "CUETEXT" && self.cue && self.oncue) {
												self.oncue(self.cue);
											}
											self.cue = null;
											self.state =
												self.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
										}
										return this;
									},
									flush: function flush() {
										var self = this;
										try {
											self.buffer += self.decoder.decode();
											if (self.cue || self.state === "HEADER") {
												self.buffer += "\n\n";
												self.parse();
											}
											if (self.state === "INITIAL") {
												throw new Error("Malformed WebVTT signature.");
											}
										} catch (e) {
											throw e;
										}
										if (self.onflush) {
											self.onflush();
										}
										return this;
									},
								};
								var vttparser = VTTParser;
								function newCue(track, startTime, endTime, captionScreen) {
									var result = [];
									var row;
									var cue;
									var indenting;
									var indent;
									var text;
									var VTTCue = window.VTTCue || TextTrackCue;
									for (var r = 0; r < captionScreen.rows.length; r++) {
										row = captionScreen.rows[r];
										indenting = true;
										indent = 0;
										text = "";
										if (!row.isEmpty()) {
											for (var c = 0; c < row.chars.length; c++) {
												if (row.chars[c].uchar.match(/\s/) && indenting) {
													indent++;
												} else {
													text += row.chars[c].uchar;
													indenting = false;
												}
											}
											row.cueStartTime = startTime;
											if (startTime === endTime) {
												endTime += 1e-4;
											}
											cue = new VTTCue(
												startTime,
												endTime,
												fixLineBreaks(text.trim())
											);
											if (indent >= 16) {
												indent--;
											} else {
												indent++;
											}
											if (navigator.userAgent.match(/Firefox\//)) {
												cue.line = r + 1;
											} else {
												cue.line = r > 7 ? r - 2 : r + 1;
											}
											cue.align = "left";
											cue.position = Math.max(
												0,
												Math.min(100, 100 * (indent / 32))
											);
											result.push(cue);
											if (track) {
												track.addCue(cue);
											}
										}
									}
									return result;
								}
								var specialCea608CharsCodes = {
									42: 225,
									92: 233,
									94: 237,
									95: 243,
									96: 250,
									123: 231,
									124: 247,
									125: 209,
									126: 241,
									127: 9608,
									128: 174,
									129: 176,
									130: 189,
									131: 191,
									132: 8482,
									133: 162,
									134: 163,
									135: 9834,
									136: 224,
									137: 32,
									138: 232,
									139: 226,
									140: 234,
									141: 238,
									142: 244,
									143: 251,
									144: 193,
									145: 201,
									146: 211,
									147: 218,
									148: 220,
									149: 252,
									150: 8216,
									151: 161,
									152: 42,
									153: 8217,
									154: 9473,
									155: 169,
									156: 8480,
									157: 8226,
									158: 8220,
									159: 8221,
									160: 192,
									161: 194,
									162: 199,
									163: 200,
									164: 202,
									165: 203,
									166: 235,
									167: 206,
									168: 207,
									169: 239,
									170: 212,
									171: 217,
									172: 249,
									173: 219,
									174: 171,
									175: 187,
									176: 195,
									177: 227,
									178: 205,
									179: 204,
									180: 236,
									181: 210,
									182: 242,
									183: 213,
									184: 245,
									185: 123,
									186: 125,
									187: 92,
									188: 94,
									189: 95,
									190: 124,
									191: 8764,
									192: 196,
									193: 228,
									194: 214,
									195: 246,
									196: 223,
									197: 165,
									198: 164,
									199: 9475,
									200: 197,
									201: 229,
									202: 216,
									203: 248,
									204: 9487,
									205: 9491,
									206: 9495,
									207: 9499,
								};
								var getCharForByte = function getCharForByte(_byte) {
									var charCode = _byte;
									if (specialCea608CharsCodes.hasOwnProperty(_byte)) {
										charCode = specialCea608CharsCodes[_byte];
									}
									return String.fromCharCode(charCode);
								};
								var NR_ROWS = 15;
								var NR_COLS = 100;
								var rowsLowCh1 = {
									17: 1,
									18: 3,
									21: 5,
									22: 7,
									23: 9,
									16: 11,
									19: 12,
									20: 14,
								};
								var rowsHighCh1 = {
									17: 2,
									18: 4,
									21: 6,
									22: 8,
									23: 10,
									19: 13,
									20: 15,
								};
								var rowsLowCh2 = {
									25: 1,
									26: 3,
									29: 5,
									30: 7,
									31: 9,
									24: 11,
									27: 12,
									28: 14,
								};
								var rowsHighCh2 = {
									25: 2,
									26: 4,
									29: 6,
									30: 8,
									31: 10,
									27: 13,
									28: 15,
								};
								var backgroundColors = [
									"white",
									"green",
									"blue",
									"cyan",
									"red",
									"yellow",
									"magenta",
									"black",
									"transparent",
								];
								var VerboseLevel;
								(function (VerboseLevel) {
									VerboseLevel[(VerboseLevel["ERROR"] = 0)] = "ERROR";
									VerboseLevel[(VerboseLevel["TEXT"] = 1)] = "TEXT";
									VerboseLevel[(VerboseLevel["WARNING"] = 2)] = "WARNING";
									VerboseLevel[(VerboseLevel["INFO"] = 2)] = "INFO";
									VerboseLevel[(VerboseLevel["DEBUG"] = 3)] = "DEBUG";
									VerboseLevel[(VerboseLevel["DATA"] = 3)] = "DATA";
								})(VerboseLevel || (VerboseLevel = {}));
								var cea_608_parser_CaptionsLogger = (function () {
									function CaptionsLogger() {
										this.time = null;
										this.verboseLevel = VerboseLevel.ERROR;
									}
									var _proto = CaptionsLogger.prototype;
									_proto.log = function log(severity, msg) {
										if (this.verboseLevel >= severity) {
											logger["logger"].log(
												this.time + " [" + severity + "] " + msg
											);
										}
									};
									return CaptionsLogger;
								})();
								var numArrayToHexArray = function numArrayToHexArray(numArray) {
									var hexArray = [];
									for (var j = 0; j < numArray.length; j++) {
										hexArray.push(numArray[j].toString(16));
									}
									return hexArray;
								};
								var PenState = (function () {
									function PenState(
										foreground,
										underline,
										italics,
										background,
										flash
									) {
										this.foreground = void 0;
										this.underline = void 0;
										this.italics = void 0;
										this.background = void 0;
										this.flash = void 0;
										this.foreground = foreground || "white";
										this.underline = underline || false;
										this.italics = italics || false;
										this.background = background || "black";
										this.flash = flash || false;
									}
									var _proto2 = PenState.prototype;
									_proto2.reset = function reset() {
										this.foreground = "white";
										this.underline = false;
										this.italics = false;
										this.background = "black";
										this.flash = false;
									};
									_proto2.setStyles = function setStyles(styles) {
										var attribs = [
											"foreground",
											"underline",
											"italics",
											"background",
											"flash",
										];
										for (var i = 0; i < attribs.length; i++) {
											var style = attribs[i];
											if (styles.hasOwnProperty(style)) {
												this[style] = styles[style];
											}
										}
									};
									_proto2.isDefault = function isDefault() {
										return (
											this.foreground === "white" &&
											!this.underline &&
											!this.italics &&
											this.background === "black" &&
											!this.flash
										);
									};
									_proto2.equals = function equals(other) {
										return (
											this.foreground === other.foreground &&
											this.underline === other.underline &&
											this.italics === other.italics &&
											this.background === other.background &&
											this.flash === other.flash
										);
									};
									_proto2.copy = function copy(newPenState) {
										this.foreground = newPenState.foreground;
										this.underline = newPenState.underline;
										this.italics = newPenState.italics;
										this.background = newPenState.background;
										this.flash = newPenState.flash;
									};
									_proto2.toString = function toString() {
										return (
											"color=" +
											this.foreground +
											", underline=" +
											this.underline +
											", italics=" +
											this.italics +
											", background=" +
											this.background +
											", flash=" +
											this.flash
										);
									};
									return PenState;
								})();
								var StyledUnicodeChar = (function () {
									function StyledUnicodeChar(
										uchar,
										foreground,
										underline,
										italics,
										background,
										flash
									) {
										this.uchar = void 0;
										this.penState = void 0;
										this.uchar = uchar || " ";
										this.penState = new PenState(
											foreground,
											underline,
											italics,
											background,
											flash
										);
									}
									var _proto3 = StyledUnicodeChar.prototype;
									_proto3.reset = function reset() {
										this.uchar = " ";
										this.penState.reset();
									};
									_proto3.setChar = function setChar(uchar, newPenState) {
										this.uchar = uchar;
										this.penState.copy(newPenState);
									};
									_proto3.setPenState = function setPenState(newPenState) {
										this.penState.copy(newPenState);
									};
									_proto3.equals = function equals(other) {
										return (
											this.uchar === other.uchar &&
											this.penState.equals(other.penState)
										);
									};
									_proto3.copy = function copy(newChar) {
										this.uchar = newChar.uchar;
										this.penState.copy(newChar.penState);
									};
									_proto3.isEmpty = function isEmpty() {
										return this.uchar === " " && this.penState.isDefault();
									};
									return StyledUnicodeChar;
								})();
								var Row = (function () {
									function Row(logger) {
										this.chars = void 0;
										this.pos = void 0;
										this.currPenState = void 0;
										this.cueStartTime = void 0;
										this.logger = void 0;
										this.chars = [];
										for (var i = 0; i < NR_COLS; i++) {
											this.chars.push(new StyledUnicodeChar());
										}
										this.logger = logger;
										this.pos = 0;
										this.currPenState = new PenState();
									}
									var _proto4 = Row.prototype;
									_proto4.equals = function equals(other) {
										var equal = true;
										for (var i = 0; i < NR_COLS; i++) {
											if (!this.chars[i].equals(other.chars[i])) {
												equal = false;
												break;
											}
										}
										return equal;
									};
									_proto4.copy = function copy(other) {
										for (var i = 0; i < NR_COLS; i++) {
											this.chars[i].copy(other.chars[i]);
										}
									};
									_proto4.isEmpty = function isEmpty() {
										var empty = true;
										for (var i = 0; i < NR_COLS; i++) {
											if (!this.chars[i].isEmpty()) {
												empty = false;
												break;
											}
										}
										return empty;
									};
									_proto4.setCursor = function setCursor(absPos) {
										if (this.pos !== absPos) {
											this.pos = absPos;
										}
										if (this.pos < 0) {
											this.logger.log(
												VerboseLevel.DEBUG,
												"Negative cursor position " + this.pos
											);
											this.pos = 0;
										} else if (this.pos > NR_COLS) {
											this.logger.log(
												VerboseLevel.DEBUG,
												"Too large cursor position " + this.pos
											);
											this.pos = NR_COLS;
										}
									};
									_proto4.moveCursor = function moveCursor(relPos) {
										var newPos = this.pos + relPos;
										if (relPos > 1) {
											for (var i = this.pos + 1; i < newPos + 1; i++) {
												this.chars[i].setPenState(this.currPenState);
											}
										}
										this.setCursor(newPos);
									};
									_proto4.backSpace = function backSpace() {
										this.moveCursor(-1);
										this.chars[this.pos].setChar(" ", this.currPenState);
									};
									_proto4.insertChar = function insertChar(_byte2) {
										if (_byte2 >= 144) {
											this.backSpace();
										}
										var _char = getCharForByte(_byte2);
										if (this.pos >= NR_COLS) {
											this.logger.log(
												VerboseLevel.ERROR,
												"Cannot insert " +
													_byte2.toString(16) +
													" (" +
													_char +
													") at position " +
													this.pos +
													". Skipping it!"
											);
											return;
										}
										this.chars[this.pos].setChar(_char, this.currPenState);
										this.moveCursor(1);
									};
									_proto4.clearFromPos = function clearFromPos(startPos) {
										var i;
										for (i = startPos; i < NR_COLS; i++) {
											this.chars[i].reset();
										}
									};
									_proto4.clear = function clear() {
										this.clearFromPos(0);
										this.pos = 0;
										this.currPenState.reset();
									};
									_proto4.clearToEndOfRow = function clearToEndOfRow() {
										this.clearFromPos(this.pos);
									};
									_proto4.getTextString = function getTextString() {
										var chars = [];
										var empty = true;
										for (var i = 0; i < NR_COLS; i++) {
											var _char2 = this.chars[i].uchar;
											if (_char2 !== " ") {
												empty = false;
											}
											chars.push(_char2);
										}
										if (empty) {
											return "";
										} else {
											return chars.join("");
										}
									};
									_proto4.setPenStyles = function setPenStyles(styles) {
										this.currPenState.setStyles(styles);
										var currChar = this.chars[this.pos];
										currChar.setPenState(this.currPenState);
									};
									return Row;
								})();
								var CaptionScreen = (function () {
									function CaptionScreen(logger) {
										this.rows = void 0;
										this.currRow = void 0;
										this.nrRollUpRows = void 0;
										this.lastOutputScreen = void 0;
										this.logger = void 0;
										this.rows = [];
										for (var i = 0; i < NR_ROWS; i++) {
											this.rows.push(new Row(logger));
										}
										this.logger = logger;
										this.currRow = NR_ROWS - 1;
										this.nrRollUpRows = null;
										this.lastOutputScreen = null;
										this.reset();
									}
									var _proto5 = CaptionScreen.prototype;
									_proto5.reset = function reset() {
										for (var i = 0; i < NR_ROWS; i++) {
											this.rows[i].clear();
										}
										this.currRow = NR_ROWS - 1;
									};
									_proto5.equals = function equals(other) {
										var equal = true;
										for (var i = 0; i < NR_ROWS; i++) {
											if (!this.rows[i].equals(other.rows[i])) {
												equal = false;
												break;
											}
										}
										return equal;
									};
									_proto5.copy = function copy(other) {
										for (var i = 0; i < NR_ROWS; i++) {
											this.rows[i].copy(other.rows[i]);
										}
									};
									_proto5.isEmpty = function isEmpty() {
										var empty = true;
										for (var i = 0; i < NR_ROWS; i++) {
											if (!this.rows[i].isEmpty()) {
												empty = false;
												break;
											}
										}
										return empty;
									};
									_proto5.backSpace = function backSpace() {
										var row = this.rows[this.currRow];
										row.backSpace();
									};
									_proto5.clearToEndOfRow = function clearToEndOfRow() {
										var row = this.rows[this.currRow];
										row.clearToEndOfRow();
									};
									_proto5.insertChar = function insertChar(_char3) {
										var row = this.rows[this.currRow];
										row.insertChar(_char3);
									};
									_proto5.setPen = function setPen(styles) {
										var row = this.rows[this.currRow];
										row.setPenStyles(styles);
									};
									_proto5.moveCursor = function moveCursor(relPos) {
										var row = this.rows[this.currRow];
										row.moveCursor(relPos);
									};
									_proto5.setCursor = function setCursor(absPos) {
										this.logger.log(VerboseLevel.INFO, "setCursor: " + absPos);
										var row = this.rows[this.currRow];
										row.setCursor(absPos);
									};
									_proto5.setPAC = function setPAC(pacData) {
										this.logger.log(
											VerboseLevel.INFO,
											"pacData = " + JSON.stringify(pacData)
										);
										var newRow = pacData.row - 1;
										if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
											newRow = this.nrRollUpRows - 1;
										}
										if (this.nrRollUpRows && this.currRow !== newRow) {
											for (var i = 0; i < NR_ROWS; i++) {
												this.rows[i].clear();
											}
											var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
											var lastOutputScreen = this.lastOutputScreen;
											if (lastOutputScreen) {
												var prevLineTime =
													lastOutputScreen.rows[topRowIndex].cueStartTime;
												var time = this.logger.time;
												if (
													prevLineTime &&
													time !== null &&
													prevLineTime < time
												) {
													for (var _i = 0; _i < this.nrRollUpRows; _i++) {
														this.rows[newRow - this.nrRollUpRows + _i + 1].copy(
															lastOutputScreen.rows[topRowIndex + _i]
														);
													}
												}
											}
										}
										this.currRow = newRow;
										var row = this.rows[this.currRow];
										if (pacData.indent !== null) {
											var indent = pacData.indent;
											var prevPos = Math.max(indent - 1, 0);
											row.setCursor(pacData.indent);
											pacData.color = row.chars[prevPos].penState.foreground;
										}
										var styles = {
											foreground: pacData.color,
											underline: pacData.underline,
											italics: pacData.italics,
											background: "black",
											flash: false,
										};
										this.setPen(styles);
									};
									_proto5.setBkgData = function setBkgData(bkgData) {
										this.logger.log(
											VerboseLevel.INFO,
											"bkgData = " + JSON.stringify(bkgData)
										);
										this.backSpace();
										this.setPen(bkgData);
										this.insertChar(32);
									};
									_proto5.setRollUpRows = function setRollUpRows(nrRows) {
										this.nrRollUpRows = nrRows;
									};
									_proto5.rollUp = function rollUp() {
										if (this.nrRollUpRows === null) {
											this.logger.log(
												VerboseLevel.DEBUG,
												"roll_up but nrRollUpRows not set yet"
											);
											return;
										}
										this.logger.log(VerboseLevel.TEXT, this.getDisplayText());
										var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
										var topRow = this.rows.splice(topRowIndex, 1)[0];
										topRow.clear();
										this.rows.splice(this.currRow, 0, topRow);
										this.logger.log(VerboseLevel.INFO, "Rolling up");
									};
									_proto5.getDisplayText = function getDisplayText(asOneRow) {
										asOneRow = asOneRow || false;
										var displayText = [];
										var text = "";
										var rowNr = -1;
										for (var i = 0; i < NR_ROWS; i++) {
											var rowText = this.rows[i].getTextString();
											if (rowText) {
												rowNr = i + 1;
												if (asOneRow) {
													displayText.push(
														"Row " + rowNr + ": '" + rowText + "'"
													);
												} else {
													displayText.push(rowText.trim());
												}
											}
										}
										if (displayText.length > 0) {
											if (asOneRow) {
												text = "[" + displayText.join(" | ") + "]";
											} else {
												text = displayText.join("\n");
											}
										}
										return text;
									};
									_proto5.getTextAndFormat = function getTextAndFormat() {
										return this.rows;
									};
									return CaptionScreen;
								})();
								var Cea608Channel = (function () {
									function Cea608Channel(channelNumber, outputFilter, logger) {
										this.chNr = void 0;
										this.outputFilter = void 0;
										this.mode = void 0;
										this.verbose = void 0;
										this.displayedMemory = void 0;
										this.nonDisplayedMemory = void 0;
										this.lastOutputScreen = void 0;
										this.currRollUpRow = void 0;
										this.writeScreen = void 0;
										this.cueStartTime = void 0;
										this.logger = void 0;
										this.chNr = channelNumber;
										this.outputFilter = outputFilter;
										this.mode = null;
										this.verbose = 0;
										this.displayedMemory = new CaptionScreen(logger);
										this.nonDisplayedMemory = new CaptionScreen(logger);
										this.lastOutputScreen = new CaptionScreen(logger);
										this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
										this.writeScreen = this.displayedMemory;
										this.mode = null;
										this.cueStartTime = null;
										this.logger = logger;
									}
									var _proto6 = Cea608Channel.prototype;
									_proto6.reset = function reset() {
										this.mode = null;
										this.displayedMemory.reset();
										this.nonDisplayedMemory.reset();
										this.lastOutputScreen.reset();
										this.outputFilter.reset();
										this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
										this.writeScreen = this.displayedMemory;
										this.mode = null;
										this.cueStartTime = null;
									};
									_proto6.getHandler = function getHandler() {
										return this.outputFilter;
									};
									_proto6.setHandler = function setHandler(newHandler) {
										this.outputFilter = newHandler;
									};
									_proto6.setPAC = function setPAC(pacData) {
										this.writeScreen.setPAC(pacData);
									};
									_proto6.setBkgData = function setBkgData(bkgData) {
										this.writeScreen.setBkgData(bkgData);
									};
									_proto6.setMode = function setMode(newMode) {
										if (newMode === this.mode) {
											return;
										}
										this.mode = newMode;
										this.logger.log(VerboseLevel.INFO, "MODE=" + newMode);
										if (this.mode === "MODE_POP-ON") {
											this.writeScreen = this.nonDisplayedMemory;
										} else {
											this.writeScreen = this.displayedMemory;
											this.writeScreen.reset();
										}
										if (this.mode !== "MODE_ROLL-UP") {
											this.displayedMemory.nrRollUpRows = null;
											this.nonDisplayedMemory.nrRollUpRows = null;
										}
										this.mode = newMode;
									};
									_proto6.insertChars = function insertChars(chars) {
										for (var i = 0; i < chars.length; i++) {
											this.writeScreen.insertChar(chars[i]);
										}
										var screen =
											this.writeScreen === this.displayedMemory
												? "DISP"
												: "NON_DISP";
										this.logger.log(
											VerboseLevel.INFO,
											screen + ": " + this.writeScreen.getDisplayText(true)
										);
										if (
											this.mode === "MODE_PAINT-ON" ||
											this.mode === "MODE_ROLL-UP"
										) {
											this.logger.log(
												VerboseLevel.TEXT,
												"DISPLAYED: " +
													this.displayedMemory.getDisplayText(true)
											);
											this.outputDataUpdate();
										}
									};
									_proto6.ccRCL = function ccRCL() {
										this.logger.log(
											VerboseLevel.INFO,
											"RCL - Resume Caption Loading"
										);
										this.setMode("MODE_POP-ON");
									};
									_proto6.ccBS = function ccBS() {
										this.logger.log(VerboseLevel.INFO, "BS - BackSpace");
										if (this.mode === "MODE_TEXT") {
											return;
										}
										this.writeScreen.backSpace();
										if (this.writeScreen === this.displayedMemory) {
											this.outputDataUpdate();
										}
									};
									_proto6.ccAOF = function ccAOF() {};
									_proto6.ccAON = function ccAON() {};
									_proto6.ccDER = function ccDER() {
										this.logger.log(
											VerboseLevel.INFO,
											"DER- Delete to End of Row"
										);
										this.writeScreen.clearToEndOfRow();
										this.outputDataUpdate();
									};
									_proto6.ccRU = function ccRU(nrRows) {
										this.logger.log(
											VerboseLevel.INFO,
											"RU(" + nrRows + ") - Roll Up"
										);
										this.writeScreen = this.displayedMemory;
										this.setMode("MODE_ROLL-UP");
										this.writeScreen.setRollUpRows(nrRows);
									};
									_proto6.ccFON = function ccFON() {
										this.logger.log(VerboseLevel.INFO, "FON - Flash On");
										this.writeScreen.setPen({ flash: true });
									};
									_proto6.ccRDC = function ccRDC() {
										this.logger.log(
											VerboseLevel.INFO,
											"RDC - Resume Direct Captioning"
										);
										this.setMode("MODE_PAINT-ON");
									};
									_proto6.ccTR = function ccTR() {
										this.logger.log(VerboseLevel.INFO, "TR");
										this.setMode("MODE_TEXT");
									};
									_proto6.ccRTD = function ccRTD() {
										this.logger.log(VerboseLevel.INFO, "RTD");
										this.setMode("MODE_TEXT");
									};
									_proto6.ccEDM = function ccEDM() {
										this.logger.log(
											VerboseLevel.INFO,
											"EDM - Erase Displayed Memory"
										);
										this.displayedMemory.reset();
										this.outputDataUpdate(true);
									};
									_proto6.ccCR = function ccCR() {
										this.logger.log(VerboseLevel.INFO, "CR - Carriage Return");
										this.writeScreen.rollUp();
										this.outputDataUpdate(true);
									};
									_proto6.ccENM = function ccENM() {
										this.logger.log(
											VerboseLevel.INFO,
											"ENM - Erase Non-displayed Memory"
										);
										this.nonDisplayedMemory.reset();
									};
									_proto6.ccEOC = function ccEOC() {
										this.logger.log(VerboseLevel.INFO, "EOC - End Of Caption");
										if (this.mode === "MODE_POP-ON") {
											var tmp = this.displayedMemory;
											this.displayedMemory = this.nonDisplayedMemory;
											this.nonDisplayedMemory = tmp;
											this.writeScreen = this.nonDisplayedMemory;
											this.logger.log(
												VerboseLevel.TEXT,
												"DISP: " + this.displayedMemory.getDisplayText()
											);
										}
										this.outputDataUpdate(true);
									};
									_proto6.ccTO = function ccTO(nrCols) {
										this.logger.log(
											VerboseLevel.INFO,
											"TO(" + nrCols + ") - Tab Offset"
										);
										this.writeScreen.moveCursor(nrCols);
									};
									_proto6.ccMIDROW = function ccMIDROW(secondByte) {
										var styles = { flash: false };
										styles.underline = secondByte % 2 === 1;
										styles.italics = secondByte >= 46;
										if (!styles.italics) {
											var colorIndex = Math.floor(secondByte / 2) - 16;
											var colors = [
												"white",
												"green",
												"blue",
												"cyan",
												"red",
												"yellow",
												"magenta",
											];
											styles.foreground = colors[colorIndex];
										} else {
											styles.foreground = "white";
										}
										this.logger.log(
											VerboseLevel.INFO,
											"MIDROW: " + JSON.stringify(styles)
										);
										this.writeScreen.setPen(styles);
									};
									_proto6.outputDataUpdate = function outputDataUpdate(
										dispatch
									) {
										if (dispatch === void 0) {
											dispatch = false;
										}
										var time = this.logger.time;
										if (time === null) {
											return;
										}
										if (this.outputFilter) {
											if (
												this.cueStartTime === null &&
												!this.displayedMemory.isEmpty()
											) {
												this.cueStartTime = time;
											} else {
												if (
													!this.displayedMemory.equals(this.lastOutputScreen)
												) {
													this.outputFilter.newCue(
														this.cueStartTime,
														time,
														this.lastOutputScreen
													);
													if (dispatch && this.outputFilter.dispatchCue) {
														this.outputFilter.dispatchCue();
													}
													this.cueStartTime = this.displayedMemory.isEmpty()
														? null
														: time;
												}
											}
											this.lastOutputScreen.copy(this.displayedMemory);
										}
									};
									_proto6.cueSplitAtTime = function cueSplitAtTime(t) {
										if (this.outputFilter) {
											if (!this.displayedMemory.isEmpty()) {
												if (this.outputFilter.newCue) {
													this.outputFilter.newCue(
														this.cueStartTime,
														t,
														this.displayedMemory
													);
												}
												this.cueStartTime = t;
											}
										}
									};
									return Cea608Channel;
								})();
								var Cea608Parser = (function () {
									function Cea608Parser(field, out1, out2) {
										this.channels = void 0;
										this.currentChannel = 0;
										this.cmdHistory = void 0;
										this.logger = void 0;
										var logger = new cea_608_parser_CaptionsLogger();
										this.channels = [
											null,
											new Cea608Channel(field, out1, logger),
											new Cea608Channel(field + 1, out2, logger),
										];
										this.cmdHistory = createCmdHistory();
										this.logger = logger;
									}
									var _proto7 = Cea608Parser.prototype;
									_proto7.getHandler = function getHandler(channel) {
										return this.channels[channel].getHandler();
									};
									_proto7.setHandler = function setHandler(
										channel,
										newHandler
									) {
										this.channels[channel].setHandler(newHandler);
									};
									_proto7.addData = function addData(time, byteList) {
										var cmdFound;
										var a;
										var b;
										var charsFound = false;
										this.logger.time = time;
										for (var i = 0; i < byteList.length; i += 2) {
											a = byteList[i] & 127;
											b = byteList[i + 1] & 127;
											if (a === 0 && b === 0) {
												continue;
											} else {
												this.logger.log(
													VerboseLevel.DATA,
													"[" +
														numArrayToHexArray([byteList[i], byteList[i + 1]]) +
														"] -> (" +
														numArrayToHexArray([a, b]) +
														")"
												);
											}
											cmdFound = this.parseCmd(a, b);
											if (!cmdFound) {
												cmdFound = this.parseMidrow(a, b);
											}
											if (!cmdFound) {
												cmdFound = this.parsePAC(a, b);
											}
											if (!cmdFound) {
												cmdFound = this.parseBackgroundAttributes(a, b);
											}
											if (!cmdFound) {
												charsFound = this.parseChars(a, b);
												if (charsFound) {
													var currChNr = this.currentChannel;
													if (currChNr && currChNr > 0) {
														var channel = this.channels[currChNr];
														channel.insertChars(charsFound);
													} else {
														this.logger.log(
															VerboseLevel.WARNING,
															"No channel found yet. TEXT-MODE?"
														);
													}
												}
											}
											if (!cmdFound && !charsFound) {
												this.logger.log(
													VerboseLevel.WARNING,
													"Couldn't parse cleaned data " +
														numArrayToHexArray([a, b]) +
														" orig: " +
														numArrayToHexArray([byteList[i], byteList[i + 1]])
												);
											}
										}
									};
									_proto7.parseCmd = function parseCmd(a, b) {
										var cmdHistory = this.cmdHistory;
										var cond1 =
											(a === 20 || a === 28 || a === 21 || a === 29) &&
											b >= 32 &&
											b <= 47;
										var cond2 = (a === 23 || a === 31) && b >= 33 && b <= 35;
										if (!(cond1 || cond2)) {
											return false;
										}
										if (hasCmdRepeated(a, b, cmdHistory)) {
											setLastCmd(null, null, cmdHistory);
											this.logger.log(
												VerboseLevel.DEBUG,
												"Repeated command (" +
													numArrayToHexArray([a, b]) +
													") is dropped"
											);
											return true;
										}
										var chNr = a === 20 || a === 21 || a === 23 ? 1 : 2;
										var channel = this.channels[chNr];
										if (a === 20 || a === 21 || a === 28 || a === 29) {
											if (b === 32) {
												channel.ccRCL();
											} else if (b === 33) {
												channel.ccBS();
											} else if (b === 34) {
												channel.ccAOF();
											} else if (b === 35) {
												channel.ccAON();
											} else if (b === 36) {
												channel.ccDER();
											} else if (b === 37) {
												channel.ccRU(2);
											} else if (b === 38) {
												channel.ccRU(3);
											} else if (b === 39) {
												channel.ccRU(4);
											} else if (b === 40) {
												channel.ccFON();
											} else if (b === 41) {
												channel.ccRDC();
											} else if (b === 42) {
												channel.ccTR();
											} else if (b === 43) {
												channel.ccRTD();
											} else if (b === 44) {
												channel.ccEDM();
											} else if (b === 45) {
												channel.ccCR();
											} else if (b === 46) {
												channel.ccENM();
											} else if (b === 47) {
												channel.ccEOC();
											}
										} else {
											channel.ccTO(b - 32);
										}
										setLastCmd(a, b, cmdHistory);
										this.currentChannel = chNr;
										return true;
									};
									_proto7.parseMidrow = function parseMidrow(a, b) {
										var chNr = 0;
										if ((a === 17 || a === 25) && b >= 32 && b <= 47) {
											if (a === 17) {
												chNr = 1;
											} else {
												chNr = 2;
											}
											if (chNr !== this.currentChannel) {
												this.logger.log(
													VerboseLevel.ERROR,
													"Mismatch channel in midrow parsing"
												);
												return false;
											}
											var channel = this.channels[chNr];
											if (!channel) {
												return false;
											}
											channel.ccMIDROW(b);
											this.logger.log(
												VerboseLevel.DEBUG,
												"MIDROW (" + numArrayToHexArray([a, b]) + ")"
											);
											return true;
										}
										return false;
									};
									_proto7.parsePAC = function parsePAC(a, b) {
										var row;
										var cmdHistory = this.cmdHistory;
										var case1 =
											((a >= 17 && a <= 23) || (a >= 25 && a <= 31)) &&
											b >= 64 &&
											b <= 127;
										var case2 = (a === 16 || a === 24) && b >= 64 && b <= 95;
										if (!(case1 || case2)) {
											return false;
										}
										if (hasCmdRepeated(a, b, cmdHistory)) {
											setLastCmd(null, null, cmdHistory);
											return true;
										}
										var chNr = a <= 23 ? 1 : 2;
										if (b >= 64 && b <= 95) {
											row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
										} else {
											row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
										}
										var channel = this.channels[chNr];
										if (!channel) {
											return false;
										}
										channel.setPAC(this.interpretPAC(row, b));
										setLastCmd(a, b, cmdHistory);
										this.currentChannel = chNr;
										return true;
									};
									_proto7.interpretPAC = function interpretPAC(row, _byte3) {
										var pacIndex = _byte3;
										var pacData = {
											color: null,
											italics: false,
											indent: null,
											underline: false,
											row: row,
										};
										if (_byte3 > 95) {
											pacIndex = _byte3 - 96;
										} else {
											pacIndex = _byte3 - 64;
										}
										pacData.underline = (pacIndex & 1) === 1;
										if (pacIndex <= 13) {
											pacData.color = [
												"white",
												"green",
												"blue",
												"cyan",
												"red",
												"yellow",
												"magenta",
												"white",
											][Math.floor(pacIndex / 2)];
										} else if (pacIndex <= 15) {
											pacData.italics = true;
											pacData.color = "white";
										} else {
											pacData.indent = Math.floor((pacIndex - 16) / 2) * 4;
										}
										return pacData;
									};
									_proto7.parseChars = function parseChars(a, b) {
										var channelNr;
										var charCodes = null;
										var charCode1 = null;
										if (a >= 25) {
											channelNr = 2;
											charCode1 = a - 8;
										} else {
											channelNr = 1;
											charCode1 = a;
										}
										if (charCode1 >= 17 && charCode1 <= 19) {
											var oneCode = b;
											if (charCode1 === 17) {
												oneCode = b + 80;
											} else if (charCode1 === 18) {
												oneCode = b + 112;
											} else {
												oneCode = b + 144;
											}
											this.logger.log(
												VerboseLevel.INFO,
												"Special char '" +
													getCharForByte(oneCode) +
													"' in channel " +
													channelNr
											);
											charCodes = [oneCode];
										} else if (a >= 32 && a <= 127) {
											charCodes = b === 0 ? [a] : [a, b];
										}
										if (charCodes) {
											var hexCodes = numArrayToHexArray(charCodes);
											this.logger.log(
												VerboseLevel.DEBUG,
												"Char codes =  " + hexCodes.join(",")
											);
											setLastCmd(a, b, this.cmdHistory);
										}
										return charCodes;
									};
									_proto7.parseBackgroundAttributes =
										function parseBackgroundAttributes(a, b) {
											var case1 = (a === 16 || a === 24) && b >= 32 && b <= 47;
											var case2 = (a === 23 || a === 31) && b >= 45 && b <= 47;
											if (!(case1 || case2)) {
												return false;
											}
											var index;
											var bkgData = {};
											if (a === 16 || a === 24) {
												index = Math.floor((b - 32) / 2);
												bkgData.background = backgroundColors[index];
												if (b % 2 === 1) {
													bkgData.background = bkgData.background + "_semi";
												}
											} else if (b === 45) {
												bkgData.background = "transparent";
											} else {
												bkgData.foreground = "black";
												if (b === 47) {
													bkgData.underline = true;
												}
											}
											var chNr = a <= 23 ? 1 : 2;
											var channel = this.channels[chNr];
											channel.setBkgData(bkgData);
											setLastCmd(a, b, this.cmdHistory);
											return true;
										};
									_proto7.reset = function reset() {
										for (
											var i = 0;
											i < Object.keys(this.channels).length;
											i++
										) {
											var channel = this.channels[i];
											if (channel) {
												channel.reset();
											}
										}
										this.cmdHistory = createCmdHistory();
									};
									_proto7.cueSplitAtTime = function cueSplitAtTime(t) {
										for (var i = 0; i < this.channels.length; i++) {
											var channel = this.channels[i];
											if (channel) {
												channel.cueSplitAtTime(t);
											}
										}
									};
									return Cea608Parser;
								})();
								function setLastCmd(a, b, cmdHistory) {
									cmdHistory.a = a;
									cmdHistory.b = b;
								}
								function hasCmdRepeated(a, b, cmdHistory) {
									return cmdHistory.a === a && cmdHistory.b === b;
								}
								function createCmdHistory() {
									return { a: null, b: null };
								}
								var cea_608_parser = Cea608Parser;
								var OutputFilter = (function () {
									function OutputFilter(timelineController, trackName) {
										this.timelineController = void 0;
										this.cueRanges = [];
										this.trackName = void 0;
										this.startTime = null;
										this.endTime = null;
										this.screen = null;
										this.timelineController = timelineController;
										this.trackName = trackName;
									}
									var _proto = OutputFilter.prototype;
									_proto.dispatchCue = function dispatchCue() {
										if (this.startTime === null) {
											return;
										}
										this.timelineController.addCues(
											this.trackName,
											this.startTime,
											this.endTime,
											this.screen,
											this.cueRanges
										);
										this.startTime = null;
									};
									_proto.newCue = function newCue(startTime, endTime, screen) {
										if (this.startTime === null || this.startTime > startTime) {
											this.startTime = startTime;
										}
										this.endTime = endTime;
										this.screen = screen;
										this.timelineController.createCaptionsTrack(this.trackName);
									};
									_proto.reset = function reset() {
										this.cueRanges = [];
									};
									return OutputFilter;
								})();
								var startsWith = function startsWith(
									inputString,
									searchString,
									position
								) {
									return (
										inputString.substr(position || 0, searchString.length) ===
										searchString
									);
								};
								var webvtt_parser_cueString2millis = function cueString2millis(
									timeString
								) {
									var ts = parseInt(timeString.substr(-3));
									var secs = parseInt(timeString.substr(-6, 2));
									var mins = parseInt(timeString.substr(-9, 2));
									var hours =
										timeString.length > 9
											? parseInt(timeString.substr(0, timeString.indexOf(":")))
											: 0;
									if (
										!Object(number["isFiniteNumber"])(ts) ||
										!Object(number["isFiniteNumber"])(secs) ||
										!Object(number["isFiniteNumber"])(mins) ||
										!Object(number["isFiniteNumber"])(hours)
									) {
										throw Error(
											"Malformed X-TIMESTAMP-MAP: Local:" + timeString
										);
									}
									ts += 1e3 * secs;
									ts += 60 * 1e3 * mins;
									ts += 60 * 60 * 1e3 * hours;
									return ts;
								};
								var hash = function hash(text) {
									var hash = 5381;
									var i = text.length;
									while (i) {
										hash = (hash * 33) ^ text.charCodeAt(--i);
									}
									return (hash >>> 0).toString();
								};
								var calculateOffset = function calculateOffset(
									vttCCs,
									cc,
									presentationTime
								) {
									var currCC = vttCCs[cc];
									var prevCC = vttCCs[currCC.prevCC];
									if (!prevCC || (!prevCC.new && currCC.new)) {
										vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
										currCC.new = false;
										return;
									}
									while (prevCC && prevCC.new) {
										vttCCs.ccOffset += currCC.start - prevCC.start;
										currCC.new = false;
										currCC = prevCC;
										prevCC = vttCCs[currCC.prevCC];
									}
									vttCCs.presentationOffset = presentationTime;
								};
								var WebVTTParser = {
									parse: function parse(
										vttByteArray,
										syncPTS,
										vttCCs,
										cc,
										callBack,
										errorCallBack
									) {
										var re = /\r\n|\n\r|\n|\r/g;
										var vttLines = Object(id3["utf8ArrayToStr"])(
											new Uint8Array(vttByteArray)
										)
											.trim()
											.replace(re, "\n")
											.split("\n");
										var cueTime = "00:00.000";
										var mpegTs = 0;
										var localTime = 0;
										var presentationTime = 0;
										var cues = [];
										var parsingError;
										var inHeader = true;
										var timestampMap = false;
										var parser = new vttparser();
										parser.oncue = function (cue) {
											var currCC = vttCCs[cc];
											var cueOffset = vttCCs.ccOffset;
											if (currCC && currCC.new) {
												if (localTime !== undefined) {
													cueOffset = vttCCs.ccOffset = currCC.start;
												} else {
													calculateOffset(vttCCs, cc, presentationTime);
												}
											}
											if (presentationTime) {
												cueOffset =
													presentationTime - vttCCs.presentationOffset;
											}
											if (timestampMap) {
												cue.startTime += cueOffset - localTime;
												cue.endTime += cueOffset - localTime;
											}
											cue.id =
												hash(cue.startTime.toString()) +
												hash(cue.endTime.toString()) +
												hash(cue.text);
											cue.text = decodeURIComponent(
												encodeURIComponent(cue.text)
											);
											if (cue.endTime > 0) {
												cues.push(cue);
											}
										};
										parser.onparsingerror = function (e) {
											parsingError = e;
										};
										parser.onflush = function () {
											if (parsingError && errorCallBack) {
												errorCallBack(parsingError);
												return;
											}
											callBack(cues);
										};
										vttLines.forEach(function (line) {
											if (inHeader) {
												if (startsWith(line, "X-TIMESTAMP-MAP=")) {
													inHeader = false;
													timestampMap = true;
													line
														.substr(16)
														.split(",")
														.forEach(function (timestamp) {
															if (startsWith(timestamp, "LOCAL:")) {
																cueTime = timestamp.substr(6);
															} else if (startsWith(timestamp, "MPEGTS:")) {
																mpegTs = parseInt(timestamp.substr(7));
															}
														});
													try {
														if (syncPTS + (vttCCs[cc].start * 9e4 || 0) < 0) {
															syncPTS += 8589934592;
														}
														mpegTs -= syncPTS;
														localTime =
															webvtt_parser_cueString2millis(cueTime) / 1e3;
														presentationTime = mpegTs / 9e4;
													} catch (e) {
														timestampMap = false;
														parsingError = e;
													}
													return;
												} else if (line === "") {
													inHeader = false;
												}
											}
											parser.parse(line + "\n");
										});
										parser.flush();
									},
								};
								var webvtt_parser = WebVTTParser;
								function timeline_controller_assertThisInitialized(self) {
									if (self === void 0) {
										throw new ReferenceError(
											"this hasn't been initialised - super() hasn't been called"
										);
									}
									return self;
								}
								function timeline_controller_inheritsLoose(
									subClass,
									superClass
								) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var timeline_controller_TimelineController = (function (
									_EventHandler
								) {
									timeline_controller_inheritsLoose(
										TimelineController,
										_EventHandler
									);
									function TimelineController(hls) {
										var _this;
										_this =
											_EventHandler.call(
												this,
												hls,
												events["default"].MEDIA_ATTACHING,
												events["default"].MEDIA_DETACHING,
												events["default"].FRAG_PARSING_USERDATA,
												events["default"].FRAG_DECRYPTED,
												events["default"].MANIFEST_LOADING,
												events["default"].MANIFEST_LOADED,
												events["default"].FRAG_LOADED,
												events["default"].INIT_PTS_FOUND
											) || this;
										_this.media = null;
										_this.config = void 0;
										_this.enabled = true;
										_this.Cues = void 0;
										_this.textTracks = [];
										_this.tracks = [];
										_this.initPTS = [];
										_this.unparsedVttFrags = [];
										_this.captionsTracks = {};
										_this.nonNativeCaptionsTracks = {};
										_this.captionsProperties = void 0;
										_this.cea608Parser1 = void 0;
										_this.cea608Parser2 = void 0;
										_this.lastSn = -1;
										_this.prevCC = -1;
										_this.vttCCs = newVTTCCs();
										_this.hls = hls;
										_this.config = hls.config;
										_this.Cues = hls.config.cueHandler;
										_this.captionsProperties = {
											textTrack1: {
												label: _this.config.captionsTextTrack1Label,
												languageCode:
													_this.config.captionsTextTrack1LanguageCode,
											},
											textTrack2: {
												label: _this.config.captionsTextTrack2Label,
												languageCode:
													_this.config.captionsTextTrack2LanguageCode,
											},
											textTrack3: {
												label: _this.config.captionsTextTrack3Label,
												languageCode:
													_this.config.captionsTextTrack3LanguageCode,
											},
											textTrack4: {
												label: _this.config.captionsTextTrack4Label,
												languageCode:
													_this.config.captionsTextTrack4LanguageCode,
											},
										};
										if (_this.config.enableCEA708Captions) {
											var channel1 = new OutputFilter(
												timeline_controller_assertThisInitialized(_this),
												"textTrack1"
											);
											var channel2 = new OutputFilter(
												timeline_controller_assertThisInitialized(_this),
												"textTrack2"
											);
											var channel3 = new OutputFilter(
												timeline_controller_assertThisInitialized(_this),
												"textTrack3"
											);
											var channel4 = new OutputFilter(
												timeline_controller_assertThisInitialized(_this),
												"textTrack4"
											);
											_this.cea608Parser1 = new cea_608_parser(
												1,
												channel1,
												channel2
											);
											_this.cea608Parser2 = new cea_608_parser(
												3,
												channel3,
												channel4
											);
										}
										return _this;
									}
									var _proto = TimelineController.prototype;
									_proto.addCues = function addCues(
										trackName,
										startTime,
										endTime,
										screen,
										cueRanges
									) {
										var merged = false;
										for (var i = cueRanges.length; i--; ) {
											var cueRange = cueRanges[i];
											var overlap = intersection(
												cueRange[0],
												cueRange[1],
												startTime,
												endTime
											);
											if (overlap >= 0) {
												cueRange[0] = Math.min(cueRange[0], startTime);
												cueRange[1] = Math.max(cueRange[1], endTime);
												merged = true;
												if (overlap / (endTime - startTime) > 0.5) {
													return;
												}
											}
										}
										if (!merged) {
											cueRanges.push([startTime, endTime]);
										}
										if (this.config.renderTextTracksNatively) {
											this.Cues.newCue(
												this.captionsTracks[trackName],
												startTime,
												endTime,
												screen
											);
										} else {
											var cues = this.Cues.newCue(
												null,
												startTime,
												endTime,
												screen
											);
											this.hls.trigger(events["default"].CUES_PARSED, {
												type: "captions",
												cues: cues,
												track: trackName,
											});
										}
									};
									_proto.onInitPtsFound = function onInitPtsFound(data) {
										var _this2 = this;
										var frag = data.frag,
											id = data.id,
											initPTS = data.initPTS;
										var unparsedVttFrags = this.unparsedVttFrags;
										if (id === "main") {
											this.initPTS[frag.cc] = initPTS;
										}
										if (unparsedVttFrags.length) {
											this.unparsedVttFrags = [];
											unparsedVttFrags.forEach(function (frag) {
												_this2.onFragLoaded(frag);
											});
										}
									};
									_proto.getExistingTrack = function getExistingTrack(
										trackName
									) {
										var media = this.media;
										if (media) {
											for (var i = 0; i < media.textTracks.length; i++) {
												var textTrack = media.textTracks[i];
												if (textTrack[trackName]) {
													return textTrack;
												}
											}
										}
										return null;
									};
									_proto.createCaptionsTrack = function createCaptionsTrack(
										trackName
									) {
										if (this.config.renderTextTracksNatively) {
											this.createNativeTrack(trackName);
										} else {
											this.createNonNativeTrack(trackName);
										}
									};
									_proto.createNativeTrack = function createNativeTrack(
										trackName
									) {
										if (this.captionsTracks[trackName]) {
											return;
										}
										var captionsProperties = this.captionsProperties,
											captionsTracks = this.captionsTracks,
											media = this.media;
										var _captionsProperties$t = captionsProperties[trackName],
											label = _captionsProperties$t.label,
											languageCode = _captionsProperties$t.languageCode;
										var existingTrack = this.getExistingTrack(trackName);
										if (!existingTrack) {
											var textTrack = this.createTextTrack(
												"captions",
												label,
												languageCode
											);
											if (textTrack) {
												textTrack[trackName] = true;
												captionsTracks[trackName] = textTrack;
											}
										} else {
											captionsTracks[trackName] = existingTrack;
											clearCurrentCues(captionsTracks[trackName]);
											sendAddTrackEvent(captionsTracks[trackName], media);
										}
									};
									_proto.createNonNativeTrack = function createNonNativeTrack(
										trackName
									) {
										if (this.nonNativeCaptionsTracks[trackName]) {
											return;
										}
										var trackProperties = this.captionsProperties[trackName];
										if (!trackProperties) {
											return;
										}
										var label = trackProperties.label;
										var track = {
											_id: trackName,
											label: label,
											kind: "captions",
											default: trackProperties.media
												? !!trackProperties.media.default
												: false,
											closedCaptions: trackProperties.media,
										};
										this.nonNativeCaptionsTracks[trackName] = track;
										this.hls.trigger(
											events["default"].NON_NATIVE_TEXT_TRACKS_FOUND,
											{ tracks: [track] }
										);
									};
									_proto.createTextTrack = function createTextTrack(
										kind,
										label,
										lang
									) {
										var media = this.media;
										if (!media) {
											return;
										}
										return media.addTextTrack(kind, label, lang);
									};
									_proto.destroy = function destroy() {
										_EventHandler.prototype.destroy.call(this);
									};
									_proto.onMediaAttaching = function onMediaAttaching(data) {
										this.media = data.media;
										this._cleanTracks();
									};
									_proto.onMediaDetaching = function onMediaDetaching() {
										var captionsTracks = this.captionsTracks;
										Object.keys(captionsTracks).forEach(function (trackName) {
											clearCurrentCues(captionsTracks[trackName]);
											delete captionsTracks[trackName];
										});
										this.nonNativeCaptionsTracks = {};
									};
									_proto.onManifestLoading = function onManifestLoading() {
										this.lastSn = -1;
										this.prevCC = -1;
										this.vttCCs = newVTTCCs();
										this._cleanTracks();
										this.tracks = [];
										this.captionsTracks = {};
										this.nonNativeCaptionsTracks = {};
									};
									_proto._cleanTracks = function _cleanTracks() {
										var media = this.media;
										if (!media) {
											return;
										}
										var textTracks = media.textTracks;
										if (textTracks) {
											for (var i = 0; i < textTracks.length; i++) {
												clearCurrentCues(textTracks[i]);
											}
										}
									};
									_proto.onManifestLoaded = function onManifestLoaded(data) {
										var _this3 = this;
										this.textTracks = [];
										this.unparsedVttFrags = this.unparsedVttFrags || [];
										this.initPTS = [];
										if (this.cea608Parser1 && this.cea608Parser2) {
											this.cea608Parser1.reset();
											this.cea608Parser2.reset();
										}
										if (this.config.enableWebVTT) {
											var tracks = data.subtitles || [];
											var sameTracks =
												this.tracks &&
												tracks &&
												this.tracks.length === tracks.length;
											this.tracks = data.subtitles || [];
											if (this.config.renderTextTracksNatively) {
												var inUseTracks = this.media
													? this.media.textTracks
													: [];
												this.tracks.forEach(function (track, index) {
													var textTrack;
													if (index < inUseTracks.length) {
														var inUseTrack = null;
														for (var i = 0; i < inUseTracks.length; i++) {
															if (canReuseVttTextTrack(inUseTracks[i], track)) {
																inUseTrack = inUseTracks[i];
																break;
															}
														}
														if (inUseTrack) {
															textTrack = inUseTrack;
														}
													}
													if (!textTrack) {
														textTrack = _this3.createTextTrack(
															"subtitles",
															track.name,
															track.lang
														);
													}
													if (track.default) {
														textTrack.mode = _this3.hls.subtitleDisplay
															? "showing"
															: "hidden";
													} else {
														textTrack.mode = "disabled";
													}
													_this3.textTracks.push(textTrack);
												});
											} else if (
												!sameTracks &&
												this.tracks &&
												this.tracks.length
											) {
												var tracksList = this.tracks.map(function (track) {
													return {
														label: track.name,
														kind: track.type.toLowerCase(),
														default: track.default,
														subtitleTrack: track,
													};
												});
												this.hls.trigger(
													events["default"].NON_NATIVE_TEXT_TRACKS_FOUND,
													{ tracks: tracksList }
												);
											}
										}
										if (this.config.enableCEA708Captions && data.captions) {
											data.captions.forEach(function (captionsTrack) {
												var instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(
													captionsTrack.instreamId
												);
												if (!instreamIdMatch) {
													return;
												}
												var trackName = "textTrack" + instreamIdMatch[1];
												var trackProperties =
													_this3.captionsProperties[trackName];
												if (!trackProperties) {
													return;
												}
												trackProperties.label = captionsTrack.name;
												if (captionsTrack.lang) {
													trackProperties.languageCode = captionsTrack.lang;
												}
												trackProperties.media = captionsTrack;
											});
										}
									};
									_proto.onFragLoaded = function onFragLoaded(data) {
										var frag = data.frag,
											payload = data.payload;
										var cea608Parser1 = this.cea608Parser1,
											cea608Parser2 = this.cea608Parser2,
											initPTS = this.initPTS,
											lastSn = this.lastSn,
											unparsedVttFrags = this.unparsedVttFrags;
										if (frag.type === "main") {
											var sn = frag.sn;
											if (frag.sn !== lastSn + 1) {
												if (cea608Parser1 && cea608Parser2) {
													cea608Parser1.reset();
													cea608Parser2.reset();
												}
											}
											this.lastSn = sn;
										} else if (frag.type === "subtitle") {
											if (payload.byteLength) {
												if (
													!Object(number["isFiniteNumber"])(initPTS[frag.cc])
												) {
													unparsedVttFrags.push(data);
													if (initPTS.length) {
														this.hls.trigger(
															events["default"].SUBTITLE_FRAG_PROCESSED,
															{ success: false, frag: frag }
														);
													}
													return;
												}
												var decryptData = frag.decryptdata;
												if (
													decryptData == null ||
													decryptData.key == null ||
													decryptData.method !== "AES-128"
												) {
													this._parseVTTs(frag, payload);
												}
											} else {
												this.hls.trigger(
													events["default"].SUBTITLE_FRAG_PROCESSED,
													{ success: false, frag: frag }
												);
											}
										}
									};
									_proto._parseVTTs = function _parseVTTs(frag, payload) {
										var _this4 = this;
										var hls = this.hls,
											prevCC = this.prevCC,
											textTracks = this.textTracks,
											vttCCs = this.vttCCs;
										if (!vttCCs[frag.cc]) {
											vttCCs[frag.cc] = {
												start: frag.start,
												prevCC: prevCC,
												new: true,
											};
											this.prevCC = frag.cc;
										}
										webvtt_parser.parse(
											payload,
											this.initPTS[frag.cc],
											vttCCs,
											frag.cc,
											function (cues) {
												if (_this4.config.renderTextTracksNatively) {
													var currentTrack = textTracks[frag.level];
													if (currentTrack.mode === "disabled") {
														hls.trigger(
															events["default"].SUBTITLE_FRAG_PROCESSED,
															{ success: false, frag: frag }
														);
														return;
													}
													cues.forEach(function (cue) {
														if (!currentTrack.cues.getCueById(cue.id)) {
															try {
																currentTrack.addCue(cue);
																if (!currentTrack.cues.getCueById(cue.id)) {
																	throw new Error(
																		"addCue is failed for: " + cue
																	);
																}
															} catch (err) {
																logger["logger"].debug(
																	"Failed occurred on adding cues: " + err
																);
																var textTrackCue = new window.TextTrackCue(
																	cue.startTime,
																	cue.endTime,
																	cue.text
																);
																textTrackCue.id = cue.id;
																currentTrack.addCue(textTrackCue);
															}
														}
													});
												} else {
													var trackId = _this4.tracks[frag.level].default
														? "default"
														: "subtitles" + frag.level;
													hls.trigger(events["default"].CUES_PARSED, {
														type: "subtitles",
														cues: cues,
														track: trackId,
													});
												}
												hls.trigger(events["default"].SUBTITLE_FRAG_PROCESSED, {
													success: true,
													frag: frag,
												});
											},
											function (e) {
												logger["logger"].log("Failed to parse VTT cue: " + e);
												hls.trigger(events["default"].SUBTITLE_FRAG_PROCESSED, {
													success: false,
													frag: frag,
												});
											}
										);
									};
									_proto.onFragDecrypted = function onFragDecrypted(data) {
										var frag = data.frag,
											payload = data.payload;
										if (frag.type === "subtitle") {
											if (
												!Object(number["isFiniteNumber"])(this.initPTS[frag.cc])
											) {
												this.unparsedVttFrags.push(data);
												return;
											}
											this._parseVTTs(frag, payload);
										}
									};
									_proto.onFragParsingUserdata = function onFragParsingUserdata(
										data
									) {
										var cea608Parser1 = this.cea608Parser1,
											cea608Parser2 = this.cea608Parser2;
										if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {
											return;
										}
										for (var i = 0; i < data.samples.length; i++) {
											var ccBytes = data.samples[i].bytes;
											if (ccBytes) {
												var ccdatas = this.extractCea608Data(ccBytes);
												cea608Parser1.addData(data.samples[i].pts, ccdatas[0]);
												cea608Parser2.addData(data.samples[i].pts, ccdatas[1]);
											}
										}
									};
									_proto.extractCea608Data = function extractCea608Data(
										byteArray
									) {
										var count = byteArray[0] & 31;
										var position = 2;
										var actualCCBytes = [[], []];
										for (var j = 0; j < count; j++) {
											var tmpByte = byteArray[position++];
											var ccbyte1 = 127 & byteArray[position++];
											var ccbyte2 = 127 & byteArray[position++];
											var ccValid = (4 & tmpByte) !== 0;
											var ccType = 3 & tmpByte;
											if (ccbyte1 === 0 && ccbyte2 === 0) {
												continue;
											}
											if (ccValid) {
												if (ccType === 0 || ccType === 1) {
													actualCCBytes[ccType].push(ccbyte1);
													actualCCBytes[ccType].push(ccbyte2);
												}
											}
										}
										return actualCCBytes;
									};
									return TimelineController;
								})(event_handler);
								function canReuseVttTextTrack(inUseTrack, manifestTrack) {
									return (
										inUseTrack &&
										inUseTrack.label === manifestTrack.name &&
										!(inUseTrack.textTrack1 || inUseTrack.textTrack2)
									);
								}
								function intersection(x1, x2, y1, y2) {
									return Math.min(x2, y2) - Math.max(x1, y1);
								}
								function newVTTCCs() {
									return {
										ccOffset: 0,
										presentationOffset: 0,
										0: { start: 0, prevCC: -1, new: false },
									};
								}
								var timeline_controller =
									timeline_controller_TimelineController;
								function subtitle_track_controller_defineProperties(
									target,
									props
								) {
									for (var i = 0; i < props.length; i++) {
										var descriptor = props[i];
										descriptor.enumerable = descriptor.enumerable || false;
										descriptor.configurable = true;
										if ("value" in descriptor) descriptor.writable = true;
										Object.defineProperty(target, descriptor.key, descriptor);
									}
								}
								function subtitle_track_controller_createClass(
									Constructor,
									protoProps,
									staticProps
								) {
									if (protoProps)
										subtitle_track_controller_defineProperties(
											Constructor.prototype,
											protoProps
										);
									if (staticProps)
										subtitle_track_controller_defineProperties(
											Constructor,
											staticProps
										);
									return Constructor;
								}
								function subtitle_track_controller_inheritsLoose(
									subClass,
									superClass
								) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var subtitle_track_controller_SubtitleTrackController =
									(function (_EventHandler) {
										subtitle_track_controller_inheritsLoose(
											SubtitleTrackController,
											_EventHandler
										);
										function SubtitleTrackController(hls) {
											var _this;
											_this =
												_EventHandler.call(
													this,
													hls,
													events["default"].MEDIA_ATTACHED,
													events["default"].MEDIA_DETACHING,
													events["default"].MANIFEST_LOADED,
													events["default"].SUBTITLE_TRACK_LOADED
												) || this;
											_this.tracks = [];
											_this.trackId = -1;
											_this.media = null;
											_this.stopped = true;
											_this.subtitleDisplay = true;
											_this.queuedDefaultTrack = null;
											return _this;
										}
										var _proto = SubtitleTrackController.prototype;
										_proto.destroy = function destroy() {
											event_handler.prototype.destroy.call(this);
										};
										_proto.onMediaAttached = function onMediaAttached(data) {
											var _this2 = this;
											this.media = data.media;
											if (!this.media) {
												return;
											}
											if (
												Object(number["isFiniteNumber"])(
													this.queuedDefaultTrack
												)
											) {
												this.subtitleTrack = this.queuedDefaultTrack;
												this.queuedDefaultTrack = null;
											}
											this.trackChangeListener =
												this._onTextTracksChanged.bind(this);
											this.useTextTrackPolling = !(
												this.media.textTracks &&
												"onchange" in this.media.textTracks
											);
											if (this.useTextTrackPolling) {
												this.subtitlePollingInterval = setInterval(function () {
													_this2.trackChangeListener();
												}, 500);
											} else {
												this.media.textTracks.addEventListener(
													"change",
													this.trackChangeListener
												);
											}
										};
										_proto.onMediaDetaching = function onMediaDetaching() {
											if (!this.media) {
												return;
											}
											if (this.useTextTrackPolling) {
												clearInterval(this.subtitlePollingInterval);
											} else {
												this.media.textTracks.removeEventListener(
													"change",
													this.trackChangeListener
												);
											}
											if (
												Object(number["isFiniteNumber"])(this.subtitleTrack)
											) {
												this.queuedDefaultTrack = this.subtitleTrack;
											}
											var textTracks = filterSubtitleTracks(
												this.media.textTracks
											);
											textTracks.forEach(function (track) {
												clearCurrentCues(track);
											});
											this.subtitleTrack = -1;
											this.media = null;
										};
										_proto.onManifestLoaded = function onManifestLoaded(data) {
											var _this3 = this;
											var tracks = data.subtitles || [];
											this.tracks = tracks;
											this.hls.trigger(
												events["default"].SUBTITLE_TRACKS_UPDATED,
												{ subtitleTracks: tracks }
											);
											tracks.forEach(function (track) {
												if (track.default) {
													if (_this3.media) {
														_this3.subtitleTrack = track.id;
													} else {
														_this3.queuedDefaultTrack = track.id;
													}
												}
											});
										};
										_proto.onSubtitleTrackLoaded =
											function onSubtitleTrackLoaded(data) {
												var _this4 = this;
												var id = data.id,
													details = data.details;
												var trackId = this.trackId,
													tracks = this.tracks;
												var currentTrack = tracks[trackId];
												if (
													id >= tracks.length ||
													id !== trackId ||
													!currentTrack ||
													this.stopped
												) {
													this._clearReloadTimer();
													return;
												}
												logger["logger"].log(
													"subtitle track " + id + " loaded"
												);
												if (details.live) {
													var reloadInterval = computeReloadInterval(
														currentTrack.details,
														details,
														data.stats.trequest
													);
													logger["logger"].log(
														"Reloading live subtitle playlist in " +
															reloadInterval +
															"ms"
													);
													this.timer = setTimeout(function () {
														_this4._loadCurrentTrack();
													}, reloadInterval);
												} else {
													this._clearReloadTimer();
												}
											};
										_proto.startLoad = function startLoad() {
											this.stopped = false;
											this._loadCurrentTrack();
										};
										_proto.stopLoad = function stopLoad() {
											this.stopped = true;
											this._clearReloadTimer();
										};
										_proto._clearReloadTimer = function _clearReloadTimer() {
											if (this.timer) {
												clearTimeout(this.timer);
												this.timer = null;
											}
										};
										_proto._loadCurrentTrack = function _loadCurrentTrack() {
											var trackId = this.trackId,
												tracks = this.tracks,
												hls = this.hls;
											var currentTrack = tracks[trackId];
											if (
												trackId < 0 ||
												!currentTrack ||
												(currentTrack.details && !currentTrack.details.live)
											) {
												return;
											}
											logger["logger"].log("Loading subtitle track " + trackId);
											hls.trigger(events["default"].SUBTITLE_TRACK_LOADING, {
												url: currentTrack.url,
												id: trackId,
											});
										};
										_proto._toggleTrackModes = function _toggleTrackModes(
											newId
										) {
											var media = this.media,
												subtitleDisplay = this.subtitleDisplay,
												trackId = this.trackId;
											if (!media) {
												return;
											}
											var textTracks = filterSubtitleTracks(media.textTracks);
											if (newId === -1) {
												[].slice.call(textTracks).forEach(function (track) {
													track.mode = "disabled";
												});
											} else {
												var oldTrack = textTracks[trackId];
												if (oldTrack) {
													oldTrack.mode = "disabled";
												}
											}
											var nextTrack = textTracks[newId];
											if (nextTrack) {
												nextTrack.mode = subtitleDisplay ? "showing" : "hidden";
											}
										};
										_proto._setSubtitleTrackInternal =
											function _setSubtitleTrackInternal(newId) {
												var hls = this.hls,
													tracks = this.tracks;
												if (
													!Object(number["isFiniteNumber"])(newId) ||
													newId < -1 ||
													newId >= tracks.length
												) {
													return;
												}
												this.trackId = newId;
												logger["logger"].log(
													"Switching to subtitle track " + newId
												);
												hls.trigger(events["default"].SUBTITLE_TRACK_SWITCH, {
													id: newId,
												});
												this._loadCurrentTrack();
											};
										_proto._onTextTracksChanged =
											function _onTextTracksChanged() {
												if (
													!this.media ||
													!this.hls.config.renderTextTracksNatively
												) {
													return;
												}
												var trackId = -1;
												var tracks = filterSubtitleTracks(
													this.media.textTracks
												);
												for (var id = 0; id < tracks.length; id++) {
													if (tracks[id].mode === "hidden") {
														trackId = id;
													} else if (tracks[id].mode === "showing") {
														trackId = id;
														break;
													}
												}
												this.subtitleTrack = trackId;
											};
										subtitle_track_controller_createClass(
											SubtitleTrackController,
											[
												{
													key: "subtitleTracks",
													get: function get() {
														return this.tracks;
													},
												},
												{
													key: "subtitleTrack",
													get: function get() {
														return this.trackId;
													},
													set: function set(subtitleTrackId) {
														if (this.trackId !== subtitleTrackId) {
															this._toggleTrackModes(subtitleTrackId);
															this._setSubtitleTrackInternal(subtitleTrackId);
														}
													},
												},
											]
										);
										return SubtitleTrackController;
									})(event_handler);
								function filterSubtitleTracks(textTrackList) {
									var tracks = [];
									for (var i = 0; i < textTrackList.length; i++) {
										var track = textTrackList[i];
										if (track.kind === "subtitles" && track.label) {
											tracks.push(textTrackList[i]);
										}
									}
									return tracks;
								}
								var subtitle_track_controller =
									subtitle_track_controller_SubtitleTrackController;
								var decrypter = __webpack_require__("./src/crypt/decrypter.js");
								function subtitle_stream_controller_assertThisInitialized(
									self
								) {
									if (self === void 0) {
										throw new ReferenceError(
											"this hasn't been initialised - super() hasn't been called"
										);
									}
									return self;
								}
								function subtitle_stream_controller_inheritsLoose(
									subClass,
									superClass
								) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var subtitle_stream_controller_window = window,
									subtitle_stream_controller_performance =
										subtitle_stream_controller_window.performance;
								var subtitle_stream_controller_TICK_INTERVAL = 500;
								var subtitle_stream_controller_SubtitleStreamController =
									(function (_BaseStreamController) {
										subtitle_stream_controller_inheritsLoose(
											SubtitleStreamController,
											_BaseStreamController
										);
										function SubtitleStreamController(hls, fragmentTracker) {
											var _this;
											_this =
												_BaseStreamController.call(
													this,
													hls,
													events["default"].MEDIA_ATTACHED,
													events["default"].MEDIA_DETACHING,
													events["default"].ERROR,
													events["default"].KEY_LOADED,
													events["default"].FRAG_LOADED,
													events["default"].SUBTITLE_TRACKS_UPDATED,
													events["default"].SUBTITLE_TRACK_SWITCH,
													events["default"].SUBTITLE_TRACK_LOADED,
													events["default"].SUBTITLE_FRAG_PROCESSED,
													events["default"].LEVEL_UPDATED
												) || this;
											_this.fragmentTracker = fragmentTracker;
											_this.config = hls.config;
											_this.state = State.STOPPED;
											_this.tracks = [];
											_this.tracksBuffered = [];
											_this.currentTrackId = -1;
											_this.decrypter = new decrypter["default"](
												hls,
												hls.config
											);
											_this.lastAVStart = 0;
											_this._onMediaSeeking = _this.onMediaSeeking.bind(
												subtitle_stream_controller_assertThisInitialized(_this)
											);
											return _this;
										}
										var _proto = SubtitleStreamController.prototype;
										_proto.startLoad = function startLoad() {
											this.stopLoad();
											this.state = State.IDLE;
											var currentTrack = this.tracks[this.currentTrackId];
											if (currentTrack && currentTrack.details) {
												this.setInterval(
													subtitle_stream_controller_TICK_INTERVAL
												);
												this.tick();
											}
										};
										_proto.onSubtitleFragProcessed =
											function onSubtitleFragProcessed(data) {
												var frag = data.frag,
													success = data.success;
												this.fragPrevious = frag;
												this.state = State.IDLE;
												if (!success) {
													return;
												}
												var buffered = this.tracksBuffered[this.currentTrackId];
												if (!buffered) {
													return;
												}
												var timeRange;
												var fragStart = frag.start;
												for (var i = 0; i < buffered.length; i++) {
													if (
														fragStart >= buffered[i].start &&
														fragStart <= buffered[i].end
													) {
														timeRange = buffered[i];
														break;
													}
												}
												var fragEnd = frag.start + frag.duration;
												if (timeRange) {
													timeRange.end = fragEnd;
												} else {
													timeRange = { start: fragStart, end: fragEnd };
													buffered.push(timeRange);
												}
											};
										_proto.onMediaAttached = function onMediaAttached(_ref) {
											var media = _ref.media;
											this.media = media;
											media.addEventListener("seeking", this._onMediaSeeking);
											this.state = State.IDLE;
										};
										_proto.onMediaDetaching = function onMediaDetaching() {
											var _this2 = this;
											if (!this.media) {
												return;
											}
											this.media.removeEventListener(
												"seeking",
												this._onMediaSeeking
											);
											this.fragmentTracker.removeAllFragments();
											this.currentTrackId = -1;
											this.tracks.forEach(function (track) {
												_this2.tracksBuffered[track.id] = [];
											});
											this.media = null;
											this.state = State.STOPPED;
										};
										_proto.onError = function onError(data) {
											var frag = data.frag;
											if (!frag || frag.type !== "subtitle") {
												return;
											}
											if (this.fragCurrent && this.fragCurrent.loader) {
												this.fragCurrent.loader.abort();
											}
											this.state = State.IDLE;
										};
										_proto.onSubtitleTracksUpdated =
											function onSubtitleTracksUpdated(data) {
												var _this3 = this;
												logger["logger"].log("subtitle tracks updated");
												this.tracksBuffered = [];
												this.tracks = data.subtitleTracks;
												this.tracks.forEach(function (track) {
													_this3.tracksBuffered[track.id] = [];
												});
											};
										_proto.onSubtitleTrackSwitch =
											function onSubtitleTrackSwitch(data) {
												this.currentTrackId = data.id;
												if (
													!this.tracks ||
													!this.tracks.length ||
													this.currentTrackId === -1
												) {
													this.clearInterval();
													return;
												}
												var currentTrack = this.tracks[this.currentTrackId];
												if (currentTrack && currentTrack.details) {
													this.setInterval(
														subtitle_stream_controller_TICK_INTERVAL
													);
												}
											};
										_proto.onSubtitleTrackLoaded =
											function onSubtitleTrackLoaded(data) {
												var id = data.id,
													details = data.details;
												var currentTrackId = this.currentTrackId,
													tracks = this.tracks;
												var currentTrack = tracks[currentTrackId];
												if (
													id >= tracks.length ||
													id !== currentTrackId ||
													!currentTrack
												) {
													return;
												}
												if (details.live) {
													mergeSubtitlePlaylists(
														currentTrack.details,
														details,
														this.lastAVStart
													);
												}
												currentTrack.details = details;
												this.setInterval(
													subtitle_stream_controller_TICK_INTERVAL
												);
											};
										_proto.onKeyLoaded = function onKeyLoaded() {
											if (this.state === State.KEY_LOADING) {
												this.state = State.IDLE;
											}
										};
										_proto.onFragLoaded = function onFragLoaded(data) {
											var fragCurrent = this.fragCurrent;
											var decryptData = data.frag.decryptdata;
											var fragLoaded = data.frag;
											var hls = this.hls;
											if (
												this.state === State.FRAG_LOADING &&
												fragCurrent &&
												data.frag.type === "subtitle" &&
												fragCurrent.sn === data.frag.sn
											) {
												if (
													data.payload.byteLength > 0 &&
													decryptData &&
													decryptData.key &&
													decryptData.method === "AES-128"
												) {
													var startTime =
														subtitle_stream_controller_performance.now();
													this.decrypter.decrypt(
														data.payload,
														decryptData.key.buffer,
														decryptData.iv.buffer,
														function (decryptedData) {
															var endTime =
																subtitle_stream_controller_performance.now();
															hls.trigger(events["default"].FRAG_DECRYPTED, {
																frag: fragLoaded,
																payload: decryptedData,
																stats: { tstart: startTime, tdecrypt: endTime },
															});
														}
													);
												}
											}
										};
										_proto.onLevelUpdated = function onLevelUpdated(_ref2) {
											var details = _ref2.details;
											var frags = details.fragments;
											this.lastAVStart = frags.length ? frags[0].start : 0;
										};
										_proto.doTick = function doTick() {
											if (!this.media) {
												this.state = State.IDLE;
												return;
											}
											switch (this.state) {
												case State.IDLE: {
													var config = this.config,
														currentTrackId = this.currentTrackId,
														fragmentTracker = this.fragmentTracker,
														media = this.media,
														tracks = this.tracks;
													if (
														!tracks ||
														!tracks[currentTrackId] ||
														!tracks[currentTrackId].details
													) {
														break;
													}
													var maxBufferHole = config.maxBufferHole,
														maxFragLookUpTolerance =
															config.maxFragLookUpTolerance;
													var maxConfigBuffer = Math.min(
														config.maxBufferLength,
														config.maxMaxBufferLength
													);
													var bufferedInfo = BufferHelper.bufferedInfo(
														this._getBuffered(),
														media.currentTime,
														maxBufferHole
													);
													var bufferEnd = bufferedInfo.end,
														bufferLen = bufferedInfo.len;
													var trackDetails = tracks[currentTrackId].details;
													var fragments = trackDetails.fragments;
													var fragLen = fragments.length;
													var end =
														fragments[fragLen - 1].start +
														fragments[fragLen - 1].duration;
													if (bufferLen > maxConfigBuffer) {
														return;
													}
													var foundFrag;
													var fragPrevious = this.fragPrevious;
													if (bufferEnd < end) {
														if (
															fragPrevious &&
															trackDetails.hasProgramDateTime
														) {
															foundFrag = findFragmentByPDT(
																fragments,
																fragPrevious.endProgramDateTime,
																maxFragLookUpTolerance
															);
														}
														if (!foundFrag) {
															foundFrag = findFragmentByPTS(
																fragPrevious,
																fragments,
																bufferEnd,
																maxFragLookUpTolerance
															);
														}
													} else {
														foundFrag = fragments[fragLen - 1];
													}
													if (foundFrag && foundFrag.encrypted) {
														logger["logger"].log(
															"Loading key for " + foundFrag.sn
														);
														this.state = State.KEY_LOADING;
														this.hls.trigger(events["default"].KEY_LOADING, {
															frag: foundFrag,
														});
													} else if (
														foundFrag &&
														fragmentTracker.getState(foundFrag) ===
															FragmentState.NOT_LOADED
													) {
														this.fragCurrent = foundFrag;
														this.state = State.FRAG_LOADING;
														this.hls.trigger(events["default"].FRAG_LOADING, {
															frag: foundFrag,
														});
													}
												}
											}
										};
										_proto.stopLoad = function stopLoad() {
											this.lastAVStart = 0;
											this.fragPrevious = null;
											_BaseStreamController.prototype.stopLoad.call(this);
										};
										_proto._getBuffered = function _getBuffered() {
											return this.tracksBuffered[this.currentTrackId] || [];
										};
										_proto.onMediaSeeking = function onMediaSeeking() {
											if (this.fragCurrent) {
												var currentTime = this.media
													? this.media.currentTime
													: 0;
												var tolerance = this.config.maxFragLookUpTolerance;
												var fragStartOffset =
													this.fragCurrent.start - tolerance;
												var fragEndOffset =
													this.fragCurrent.start +
													this.fragCurrent.duration +
													tolerance;
												if (
													currentTime < fragStartOffset ||
													currentTime > fragEndOffset
												) {
													if (this.fragCurrent.loader) {
														this.fragCurrent.loader.abort();
													}
													this.fragmentTracker.removeFragment(this.fragCurrent);
													this.fragCurrent = null;
													this.fragPrevious = null;
													this.state = State.IDLE;
													this.tick();
												}
											}
										};
										return SubtitleStreamController;
									})(base_stream_controller_BaseStreamController);
								var KeySystems;
								(function (KeySystems) {
									KeySystems["WIDEVINE"] = "com.widevine.alpha";
									KeySystems["PLAYREADY"] = "com.microsoft.playready";
								})(KeySystems || (KeySystems = {}));
								var requestMediaKeySystemAccess = (function () {
									if (
										typeof window !== "undefined" &&
										window.navigator &&
										window.navigator.requestMediaKeySystemAccess
									) {
										return window.navigator.requestMediaKeySystemAccess.bind(
											window.navigator
										);
									} else {
										return null;
									}
								})();
								function eme_controller_defineProperties(target, props) {
									for (var i = 0; i < props.length; i++) {
										var descriptor = props[i];
										descriptor.enumerable = descriptor.enumerable || false;
										descriptor.configurable = true;
										if ("value" in descriptor) descriptor.writable = true;
										Object.defineProperty(target, descriptor.key, descriptor);
									}
								}
								function eme_controller_createClass(
									Constructor,
									protoProps,
									staticProps
								) {
									if (protoProps)
										eme_controller_defineProperties(
											Constructor.prototype,
											protoProps
										);
									if (staticProps)
										eme_controller_defineProperties(Constructor, staticProps);
									return Constructor;
								}
								function eme_controller_inheritsLoose(subClass, superClass) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var MAX_LICENSE_REQUEST_FAILURES = 3;
								var createWidevineMediaKeySystemConfigurations =
									function createWidevineMediaKeySystemConfigurations(
										audioCodecs,
										videoCodecs,
										drmSystemOptions
									) {
										var baseConfig = {
											audioCapabilities: [],
											videoCapabilities: [],
										};
										audioCodecs.forEach(function (codec) {
											baseConfig.audioCapabilities.push({
												contentType: 'audio/mp4; codecs="' + codec + '"',
												robustness: drmSystemOptions.audioRobustness || "",
											});
										});
										videoCodecs.forEach(function (codec) {
											baseConfig.videoCapabilities.push({
												contentType: 'video/mp4; codecs="' + codec + '"',
												robustness: drmSystemOptions.videoRobustness || "",
											});
										});
										return [baseConfig];
									};
								var eme_controller_getSupportedMediaKeySystemConfigurations =
									function getSupportedMediaKeySystemConfigurations(
										keySystem,
										audioCodecs,
										videoCodecs,
										drmSystemOptions
									) {
										switch (keySystem) {
											case KeySystems.WIDEVINE:
												return createWidevineMediaKeySystemConfigurations(
													audioCodecs,
													videoCodecs,
													drmSystemOptions
												);
											default:
												throw new Error("Unknown key-system: " + keySystem);
										}
									};
								var eme_controller_EMEController = (function (_EventHandler) {
									eme_controller_inheritsLoose(EMEController, _EventHandler);
									function EMEController(hls) {
										var _this;
										_this =
											_EventHandler.call(
												this,
												hls,
												events["default"].MEDIA_ATTACHED,
												events["default"].MEDIA_DETACHED,
												events["default"].MANIFEST_PARSED
											) || this;
										_this._widevineLicenseUrl = void 0;
										_this._licenseXhrSetup = void 0;
										_this._emeEnabled = void 0;
										_this._requestMediaKeySystemAccess = void 0;
										_this._drmSystemOptions = void 0;
										_this._config = void 0;
										_this._mediaKeysList = [];
										_this._media = null;
										_this._hasSetMediaKeys = false;
										_this._requestLicenseFailureCount = 0;
										_this.mediaKeysPromise = null;
										_this._onMediaEncrypted = function (e) {
											logger["logger"].log(
												'Media is encrypted using "' +
													e.initDataType +
													'" init data type'
											);
											if (!_this.mediaKeysPromise) {
												logger["logger"].error(
													"Fatal: Media is encrypted but no CDM access or no keys have been requested"
												);
												_this.hls.trigger(events["default"].ERROR, {
													type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
													details: errors["ErrorDetails"].KEY_SYSTEM_NO_KEYS,
													fatal: true,
												});
												return;
											}
											var finallySetKeyAndStartSession =
												function finallySetKeyAndStartSession(mediaKeys) {
													if (!_this._media) {
														return;
													}
													_this._attemptSetMediaKeys(mediaKeys);
													_this._generateRequestWithPreferredKeySession(
														e.initDataType,
														e.initData
													);
												};
											_this.mediaKeysPromise
												.then(finallySetKeyAndStartSession)
												.catch(finallySetKeyAndStartSession);
										};
										_this._config = hls.config;
										_this._widevineLicenseUrl =
											_this._config.widevineLicenseUrl;
										_this._licenseXhrSetup = _this._config.licenseXhrSetup;
										_this._emeEnabled = _this._config.emeEnabled;
										_this._requestMediaKeySystemAccess =
											_this._config.requestMediaKeySystemAccessFunc;
										_this._drmSystemOptions = hls.config.drmSystemOptions;
										return _this;
									}
									var _proto = EMEController.prototype;
									_proto.getLicenseServerUrl = function getLicenseServerUrl(
										keySystem
									) {
										switch (keySystem) {
											case KeySystems.WIDEVINE:
												if (!this._widevineLicenseUrl) {
													break;
												}
												return this._widevineLicenseUrl;
										}
										throw new Error(
											'no license server URL configured for key-system "' +
												keySystem +
												'"'
										);
									};
									_proto._attemptKeySystemAccess =
										function _attemptKeySystemAccess(
											keySystem,
											audioCodecs,
											videoCodecs
										) {
											var _this2 = this;
											var mediaKeySystemConfigs =
												eme_controller_getSupportedMediaKeySystemConfigurations(
													keySystem,
													audioCodecs,
													videoCodecs,
													this._drmSystemOptions
												);
											logger["logger"].log(
												"Requesting encrypted media key-system access"
											);
											var keySystemAccessPromise =
												this.requestMediaKeySystemAccess(
													keySystem,
													mediaKeySystemConfigs
												);
											this.mediaKeysPromise = keySystemAccessPromise.then(
												function (mediaKeySystemAccess) {
													return _this2._onMediaKeySystemAccessObtained(
														keySystem,
														mediaKeySystemAccess
													);
												}
											);
											keySystemAccessPromise.catch(function (err) {
												logger["logger"].error(
													'Failed to obtain key-system "' +
														keySystem +
														'" access:',
													err
												);
											});
										};
									_proto._onMediaKeySystemAccessObtained =
										function _onMediaKeySystemAccessObtained(
											keySystem,
											mediaKeySystemAccess
										) {
											var _this3 = this;
											logger["logger"].log(
												'Access for key-system "' + keySystem + '" obtained'
											);
											var mediaKeysListItem = {
												mediaKeysSessionInitialized: false,
												mediaKeySystemAccess: mediaKeySystemAccess,
												mediaKeySystemDomain: keySystem,
											};
											this._mediaKeysList.push(mediaKeysListItem);
											var mediaKeysPromise = Promise.resolve()
												.then(function () {
													return mediaKeySystemAccess.createMediaKeys();
												})
												.then(function (mediaKeys) {
													mediaKeysListItem.mediaKeys = mediaKeys;
													logger["logger"].log(
														'Media-keys created for key-system "' +
															keySystem +
															'"'
													);
													_this3._onMediaKeysCreated();
													return mediaKeys;
												});
											mediaKeysPromise.catch(function (err) {
												logger["logger"].error(
													"Failed to create media-keys:",
													err
												);
											});
											return mediaKeysPromise;
										};
									_proto._onMediaKeysCreated = function _onMediaKeysCreated() {
										var _this4 = this;
										this._mediaKeysList.forEach(function (mediaKeysListItem) {
											if (!mediaKeysListItem.mediaKeysSession) {
												mediaKeysListItem.mediaKeysSession =
													mediaKeysListItem.mediaKeys.createSession();
												_this4._onNewMediaKeySession(
													mediaKeysListItem.mediaKeysSession
												);
											}
										});
									};
									_proto._onNewMediaKeySession = function _onNewMediaKeySession(
										keySession
									) {
										var _this5 = this;
										logger["logger"].log(
											"New key-system session " + keySession.sessionId
										);
										keySession.addEventListener(
											"message",
											function (event) {
												_this5._onKeySessionMessage(keySession, event.message);
											},
											false
										);
									};
									_proto._onKeySessionMessage = function _onKeySessionMessage(
										keySession,
										message
									) {
										logger["logger"].log(
											"Got EME message event, creating license request"
										);
										this._requestLicense(message, function (data) {
											logger["logger"].log(
												"Received license data (length: " +
													(data ? data.byteLength : data) +
													"), updating key-session"
											);
											keySession.update(data);
										});
									};
									_proto._attemptSetMediaKeys = function _attemptSetMediaKeys(
										mediaKeys
									) {
										if (!this._media) {
											throw new Error(
												"Attempted to set mediaKeys without first attaching a media element"
											);
										}
										if (!this._hasSetMediaKeys) {
											var keysListItem = this._mediaKeysList[0];
											if (!keysListItem || !keysListItem.mediaKeys) {
												logger["logger"].error(
													"Fatal: Media is encrypted but no CDM access or no keys have been obtained yet"
												);
												this.hls.trigger(events["default"].ERROR, {
													type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
													details: errors["ErrorDetails"].KEY_SYSTEM_NO_KEYS,
													fatal: true,
												});
												return;
											}
											logger["logger"].log("Setting keys for encrypted media");
											this._media.setMediaKeys(keysListItem.mediaKeys);
											this._hasSetMediaKeys = true;
										}
									};
									_proto._generateRequestWithPreferredKeySession =
										function _generateRequestWithPreferredKeySession(
											initDataType,
											initData
										) {
											var _this6 = this;
											var keysListItem = this._mediaKeysList[0];
											if (!keysListItem) {
												logger["logger"].error(
													"Fatal: Media is encrypted but not any key-system access has been obtained yet"
												);
												this.hls.trigger(events["default"].ERROR, {
													type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
													details: errors["ErrorDetails"].KEY_SYSTEM_NO_ACCESS,
													fatal: true,
												});
												return;
											}
											if (keysListItem.mediaKeysSessionInitialized) {
												logger["logger"].warn(
													"Key-Session already initialized but requested again"
												);
												return;
											}
											var keySession = keysListItem.mediaKeysSession;
											if (!keySession) {
												logger["logger"].error(
													"Fatal: Media is encrypted but no key-session existing"
												);
												this.hls.trigger(events["default"].ERROR, {
													type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
													details: errors["ErrorDetails"].KEY_SYSTEM_NO_SESSION,
													fatal: true,
												});
												return;
											}
											if (!initData) {
												logger["logger"].warn(
													"Fatal: initData required for generating a key session is null"
												);
												this.hls.trigger(events["default"].ERROR, {
													type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
													details:
														errors["ErrorDetails"].KEY_SYSTEM_NO_INIT_DATA,
													fatal: true,
												});
												return;
											}
											logger["logger"].log(
												'Generating key-session request for "' +
													initDataType +
													'" init data type'
											);
											keysListItem.mediaKeysSessionInitialized = true;
											keySession
												.generateRequest(initDataType, initData)
												.then(function () {
													logger["logger"].debug(
														"Key-session generation succeeded"
													);
												})
												.catch(function (err) {
													logger["logger"].error(
														"Error generating key-session request:",
														err
													);
													_this6.hls.trigger(events["default"].ERROR, {
														type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
														details:
															errors["ErrorDetails"].KEY_SYSTEM_NO_SESSION,
														fatal: false,
													});
												});
										};
									_proto._createLicenseXhr = function _createLicenseXhr(
										url,
										keyMessage,
										callback
									) {
										var xhr = new XMLHttpRequest();
										var licenseXhrSetup = this._licenseXhrSetup;
										try {
											if (licenseXhrSetup) {
												try {
													licenseXhrSetup(xhr, url);
												} catch (e) {
													xhr.open("POST", url, true);
													licenseXhrSetup(xhr, url);
												}
											}
											if (!xhr.readyState) {
												xhr.open("POST", url, true);
											}
										} catch (e) {
											throw new Error(
												"issue setting up KeySystem license XHR " + e
											);
										}
										xhr.responseType = "arraybuffer";
										xhr.onreadystatechange =
											this._onLicenseRequestReadyStageChange.bind(
												this,
												xhr,
												url,
												keyMessage,
												callback
											);
										return xhr;
									};
									_proto._onLicenseRequestReadyStageChange =
										function _onLicenseRequestReadyStageChange(
											xhr,
											url,
											keyMessage,
											callback
										) {
											switch (xhr.readyState) {
												case 4:
													if (xhr.status === 200) {
														this._requestLicenseFailureCount = 0;
														logger["logger"].log("License request succeeded");
														if (xhr.responseType !== "arraybuffer") {
															logger["logger"].warn(
																"xhr response type was not set to the expected arraybuffer for license request"
															);
														}
														callback(xhr.response);
													} else {
														logger["logger"].error(
															"License Request XHR failed (" +
																url +
																"). Status: " +
																xhr.status +
																" (" +
																xhr.statusText +
																")"
														);
														this._requestLicenseFailureCount++;
														if (
															this._requestLicenseFailureCount >
															MAX_LICENSE_REQUEST_FAILURES
														) {
															this.hls.trigger(events["default"].ERROR, {
																type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
																details:
																	errors["ErrorDetails"]
																		.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
																fatal: true,
															});
															return;
														}
														var attemptsLeft =
															MAX_LICENSE_REQUEST_FAILURES -
															this._requestLicenseFailureCount +
															1;
														logger["logger"].warn(
															"Retrying license request, " +
																attemptsLeft +
																" attempts left"
														);
														this._requestLicense(keyMessage, callback);
													}
													break;
											}
										};
									_proto._generateLicenseRequestChallenge =
										function _generateLicenseRequestChallenge(
											keysListItem,
											keyMessage
										) {
											switch (keysListItem.mediaKeySystemDomain) {
												case KeySystems.WIDEVINE:
													return keyMessage;
											}
											throw new Error(
												"unsupported key-system: " +
													keysListItem.mediaKeySystemDomain
											);
										};
									_proto._requestLicense = function _requestLicense(
										keyMessage,
										callback
									) {
										logger["logger"].log(
											"Requesting content license for key-system"
										);
										var keysListItem = this._mediaKeysList[0];
										if (!keysListItem) {
											logger["logger"].error(
												"Fatal error: Media is encrypted but no key-system access has been obtained yet"
											);
											this.hls.trigger(events["default"].ERROR, {
												type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
												details: errors["ErrorDetails"].KEY_SYSTEM_NO_ACCESS,
												fatal: true,
											});
											return;
										}
										try {
											var _url = this.getLicenseServerUrl(
												keysListItem.mediaKeySystemDomain
											);
											var _xhr = this._createLicenseXhr(
												_url,
												keyMessage,
												callback
											);
											logger["logger"].log(
												"Sending license request to URL: " + _url
											);
											var challenge = this._generateLicenseRequestChallenge(
												keysListItem,
												keyMessage
											);
											_xhr.send(challenge);
										} catch (e) {
											logger["logger"].error(
												"Failure requesting DRM license: " + e
											);
											this.hls.trigger(events["default"].ERROR, {
												type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
												details:
													errors["ErrorDetails"]
														.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
												fatal: true,
											});
										}
									};
									_proto.onMediaAttached = function onMediaAttached(data) {
										if (!this._emeEnabled) {
											return;
										}
										var media = data.media;
										this._media = media;
										media.addEventListener("encrypted", this._onMediaEncrypted);
									};
									_proto.onMediaDetached = function onMediaDetached() {
										var media = this._media;
										var mediaKeysList = this._mediaKeysList;
										if (!media) {
											return;
										}
										media.removeEventListener(
											"encrypted",
											this._onMediaEncrypted
										);
										this._media = null;
										this._mediaKeysList = [];
										Promise.all(
											mediaKeysList.map(function (mediaKeysListItem) {
												if (mediaKeysListItem.mediaKeysSession) {
													return mediaKeysListItem.mediaKeysSession
														.close()
														.catch(function () {});
												}
											})
										)
											.then(function () {
												return media.setMediaKeys(null);
											})
											.catch(function () {});
									};
									_proto.onManifestParsed = function onManifestParsed(data) {
										if (!this._emeEnabled) {
											return;
										}
										var audioCodecs = data.levels.map(function (level) {
											return level.audioCodec;
										});
										var videoCodecs = data.levels.map(function (level) {
											return level.videoCodec;
										});
										this._attemptKeySystemAccess(
											KeySystems.WIDEVINE,
											audioCodecs,
											videoCodecs
										);
									};
									eme_controller_createClass(EMEController, [
										{
											key: "requestMediaKeySystemAccess",
											get: function get() {
												if (!this._requestMediaKeySystemAccess) {
													throw new Error(
														"No requestMediaKeySystemAccess function configured"
													);
												}
												return this._requestMediaKeySystemAccess;
											},
										},
									]);
									return EMEController;
								})(event_handler);
								var eme_controller = eme_controller_EMEController;
								function ownKeys(object, enumerableOnly) {
									var keys = Object.keys(object);
									if (Object.getOwnPropertySymbols) {
										var symbols = Object.getOwnPropertySymbols(object);
										if (enumerableOnly)
											symbols = symbols.filter(function (sym) {
												return Object.getOwnPropertyDescriptor(
													object,
													sym
												).enumerable;
											});
										keys.push.apply(keys, symbols);
									}
									return keys;
								}
								function _objectSpread(target) {
									for (var i = 1; i < arguments.length; i++) {
										var source = arguments[i] != null ? arguments[i] : {};
										if (i % 2) {
											ownKeys(Object(source), true).forEach(function (key) {
												_defineProperty(target, key, source[key]);
											});
										} else if (Object.getOwnPropertyDescriptors) {
											Object.defineProperties(
												target,
												Object.getOwnPropertyDescriptors(source)
											);
										} else {
											ownKeys(Object(source)).forEach(function (key) {
												Object.defineProperty(
													target,
													key,
													Object.getOwnPropertyDescriptor(source, key)
												);
											});
										}
									}
									return target;
								}
								function _defineProperty(obj, key, value) {
									if (key in obj) {
										Object.defineProperty(obj, key, {
											value: value,
											enumerable: true,
											configurable: true,
											writable: true,
										});
									} else {
										obj[key] = value;
									}
									return obj;
								}
								var hlsDefaultConfig = _objectSpread(
									_objectSpread(
										{
											autoStartLoad: true,
											startPosition: -1,
											defaultAudioCodec: void 0,
											debug: false,
											capLevelOnFPSDrop: false,
											capLevelToPlayerSize: false,
											initialLiveManifestSize: 1,
											maxBufferLength: 30,
											maxBufferSize: 60 * 1e3 * 1e3,
											maxBufferHole: 0.5,
											lowBufferWatchdogPeriod: 0.5,
											highBufferWatchdogPeriod: 3,
											nudgeOffset: 0.1,
											nudgeMaxRetry: 3,
											maxFragLookUpTolerance: 0.25,
											liveSyncDurationCount: 3,
											liveMaxLatencyDurationCount: Infinity,
											liveSyncDuration: void 0,
											liveMaxLatencyDuration: void 0,
											liveDurationInfinity: false,
											liveBackBufferLength: Infinity,
											maxMaxBufferLength: 600,
											enableWorker: true,
											enableSoftwareAES: true,
											manifestLoadingTimeOut: 1e4,
											manifestLoadingMaxRetry: 1,
											manifestLoadingRetryDelay: 1e3,
											manifestLoadingMaxRetryTimeout: 64e3,
											startLevel: void 0,
											levelLoadingTimeOut: 1e4,
											levelLoadingMaxRetry: 4,
											levelLoadingRetryDelay: 1e3,
											levelLoadingMaxRetryTimeout: 64e3,
											fragLoadingTimeOut: 2e4,
											fragLoadingMaxRetry: 6,
											fragLoadingRetryDelay: 1e3,
											fragLoadingMaxRetryTimeout: 64e3,
											startFragPrefetch: false,
											fpsDroppedMonitoringPeriod: 5e3,
											fpsDroppedMonitoringThreshold: 0.2,
											appendErrorMaxRetry: 3,
											loader: xhr_loader,
											fLoader: void 0,
											pLoader: void 0,
											xhrSetup: void 0,
											licenseXhrSetup: void 0,
											abrController: abr_controller,
											bufferController: buffer_controller,
											capLevelController: cap_level_controller,
											fpsController: fps_controller,
											stretchShortVideoTrack: false,
											maxAudioFramesDrift: 1,
											forceKeyFrameOnDiscontinuity: true,
											abrEwmaFastLive: 3,
											abrEwmaSlowLive: 9,
											abrEwmaFastVoD: 3,
											abrEwmaSlowVoD: 9,
											abrEwmaDefaultEstimate: 5e5,
											abrBandWidthFactor: 0.95,
											abrBandWidthUpFactor: 0.7,
											abrMaxWithRealBitrate: false,
											maxStarvationDelay: 4,
											maxLoadingDelay: 4,
											minAutoBitrate: 0,
											emeEnabled: false,
											widevineLicenseUrl: void 0,
											drmSystemOptions: {},
											requestMediaKeySystemAccessFunc:
												requestMediaKeySystemAccess,
											testBandwidth: true,
										},
										timelineConfig()
									),
									{},
									{
										subtitleStreamController: true
											? subtitle_stream_controller_SubtitleStreamController
											: undefined,
										subtitleTrackController: true
											? subtitle_track_controller
											: undefined,
										timelineController: true ? timeline_controller : undefined,
										audioStreamController: true
											? audio_stream_controller
											: undefined,
										audioTrackController: true
											? audio_track_controller
											: undefined,
										emeController: true ? eme_controller : undefined,
									}
								);
								function timelineConfig() {
									return {
										cueHandler: cues_namespaceObject,
										enableCEA708Captions: true,
										enableWebVTT: true,
										captionsTextTrack1Label: "English",
										captionsTextTrack1LanguageCode: "en",
										captionsTextTrack2Label: "Spanish",
										captionsTextTrack2LanguageCode: "es",
										captionsTextTrack3Label: "Unknown CC",
										captionsTextTrack3LanguageCode: "",
										captionsTextTrack4Label: "Unknown CC",
										captionsTextTrack4LanguageCode: "",
										renderTextTracksNatively: true,
									};
								}
								function hls_ownKeys(object, enumerableOnly) {
									var keys = Object.keys(object);
									if (Object.getOwnPropertySymbols) {
										var symbols = Object.getOwnPropertySymbols(object);
										if (enumerableOnly)
											symbols = symbols.filter(function (sym) {
												return Object.getOwnPropertyDescriptor(
													object,
													sym
												).enumerable;
											});
										keys.push.apply(keys, symbols);
									}
									return keys;
								}
								function hls_objectSpread(target) {
									for (var i = 1; i < arguments.length; i++) {
										var source = arguments[i] != null ? arguments[i] : {};
										if (i % 2) {
											hls_ownKeys(Object(source), true).forEach(function (key) {
												hls_defineProperty(target, key, source[key]);
											});
										} else if (Object.getOwnPropertyDescriptors) {
											Object.defineProperties(
												target,
												Object.getOwnPropertyDescriptors(source)
											);
										} else {
											hls_ownKeys(Object(source)).forEach(function (key) {
												Object.defineProperty(
													target,
													key,
													Object.getOwnPropertyDescriptor(source, key)
												);
											});
										}
									}
									return target;
								}
								function hls_defineProperty(obj, key, value) {
									if (key in obj) {
										Object.defineProperty(obj, key, {
											value: value,
											enumerable: true,
											configurable: true,
											writable: true,
										});
									} else {
										obj[key] = value;
									}
									return obj;
								}
								function hls_assertThisInitialized(self) {
									if (self === void 0) {
										throw new ReferenceError(
											"this hasn't been initialised - super() hasn't been called"
										);
									}
									return self;
								}
								function hls_defineProperties(target, props) {
									for (var i = 0; i < props.length; i++) {
										var descriptor = props[i];
										descriptor.enumerable = descriptor.enumerable || false;
										descriptor.configurable = true;
										if ("value" in descriptor) descriptor.writable = true;
										Object.defineProperty(target, descriptor.key, descriptor);
									}
								}
								function hls_createClass(Constructor, protoProps, staticProps) {
									if (protoProps)
										hls_defineProperties(Constructor.prototype, protoProps);
									if (staticProps)
										hls_defineProperties(Constructor, staticProps);
									return Constructor;
								}
								function hls_inheritsLoose(subClass, superClass) {
									subClass.prototype = Object.create(superClass.prototype);
									subClass.prototype.constructor = subClass;
									subClass.__proto__ = superClass;
								}
								var hls_Hls = (function (_Observer) {
									hls_inheritsLoose(Hls, _Observer);
									Hls.isSupported = function isSupported() {
										return is_supported_isSupported();
									};
									hls_createClass(Hls, null, [
										{
											key: "version",
											get: function get() {
												return "0.14.17";
											},
										},
										{
											key: "Events",
											get: function get() {
												return events["default"];
											},
										},
										{
											key: "ErrorTypes",
											get: function get() {
												return errors["ErrorTypes"];
											},
										},
										{
											key: "ErrorDetails",
											get: function get() {
												return errors["ErrorDetails"];
											},
										},
										{
											key: "DefaultConfig",
											get: function get() {
												if (!Hls.defaultConfig) {
													return hlsDefaultConfig;
												}
												return Hls.defaultConfig;
											},
											set: function set(defaultConfig) {
												Hls.defaultConfig = defaultConfig;
											},
										},
									]);
									function Hls(userConfig) {
										var _this;
										if (userConfig === void 0) {
											userConfig = {};
										}
										_this = _Observer.call(this) || this;
										_this.config = void 0;
										_this._autoLevelCapping = void 0;
										_this.abrController = void 0;
										_this.capLevelController = void 0;
										_this.levelController = void 0;
										_this.streamController = void 0;
										_this.networkControllers = void 0;
										_this.audioTrackController = void 0;
										_this.subtitleTrackController = void 0;
										_this.emeController = void 0;
										_this.coreComponents = void 0;
										_this.media = null;
										_this.url = null;
										var defaultConfig = Hls.DefaultConfig;
										if (
											(userConfig.liveSyncDurationCount ||
												userConfig.liveMaxLatencyDurationCount) &&
											(userConfig.liveSyncDuration ||
												userConfig.liveMaxLatencyDuration)
										) {
											throw new Error(
												"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration"
											);
										}
										_this.config = hls_objectSpread(
											hls_objectSpread({}, defaultConfig),
											userConfig
										);
										var _assertThisInitialize =
												hls_assertThisInitialized(_this),
											config = _assertThisInitialize.config;
										if (
											config.liveMaxLatencyDurationCount !== void 0 &&
											config.liveMaxLatencyDurationCount <=
												config.liveSyncDurationCount
										) {
											throw new Error(
												'Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"'
											);
										}
										if (
											config.liveMaxLatencyDuration !== void 0 &&
											(config.liveSyncDuration === void 0 ||
												config.liveMaxLatencyDuration <=
													config.liveSyncDuration)
										) {
											throw new Error(
												'Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"'
											);
										}
										Object(logger["enableLogs"])(config.debug);
										_this._autoLevelCapping = -1;
										var abrController = (_this.abrController =
											new config.abrController(
												hls_assertThisInitialized(_this)
											));
										var bufferController = new config.bufferController(
											hls_assertThisInitialized(_this)
										);
										var capLevelController = (_this.capLevelController =
											new config.capLevelController(
												hls_assertThisInitialized(_this)
											));
										var fpsController = new config.fpsController(
											hls_assertThisInitialized(_this)
										);
										var playListLoader = new playlist_loader(
											hls_assertThisInitialized(_this)
										);
										var fragmentLoader = new fragment_loader(
											hls_assertThisInitialized(_this)
										);
										var keyLoader = new key_loader(
											hls_assertThisInitialized(_this)
										);
										var id3TrackController = new id3_track_controller(
											hls_assertThisInitialized(_this)
										);
										var levelController = (_this.levelController =
											new level_controller_LevelController(
												hls_assertThisInitialized(_this)
											));
										var fragmentTracker = new fragment_tracker_FragmentTracker(
											hls_assertThisInitialized(_this)
										);
										var streamController = (_this.streamController =
											new stream_controller(
												hls_assertThisInitialized(_this),
												fragmentTracker
											));
										var networkControllers = [
											levelController,
											streamController,
										];
										var Controller = config.audioStreamController;
										if (Controller) {
											networkControllers.push(
												new Controller(
													hls_assertThisInitialized(_this),
													fragmentTracker
												)
											);
										}
										_this.networkControllers = networkControllers;
										var coreComponents = [
											playListLoader,
											fragmentLoader,
											keyLoader,
											abrController,
											bufferController,
											capLevelController,
											fpsController,
											id3TrackController,
											fragmentTracker,
										];
										Controller = config.audioTrackController;
										if (Controller) {
											var audioTrackController = new Controller(
												hls_assertThisInitialized(_this)
											);
											_this.audioTrackController = audioTrackController;
											coreComponents.push(audioTrackController);
										}
										Controller = config.subtitleTrackController;
										if (Controller) {
											var subtitleTrackController = new Controller(
												hls_assertThisInitialized(_this)
											);
											_this.subtitleTrackController = subtitleTrackController;
											networkControllers.push(subtitleTrackController);
										}
										Controller = config.emeController;
										if (Controller) {
											var emeController = new Controller(
												hls_assertThisInitialized(_this)
											);
											_this.emeController = emeController;
											coreComponents.push(emeController);
										}
										Controller = config.subtitleStreamController;
										if (Controller) {
											networkControllers.push(
												new Controller(
													hls_assertThisInitialized(_this),
													fragmentTracker
												)
											);
										}
										Controller = config.timelineController;
										if (Controller) {
											coreComponents.push(
												new Controller(hls_assertThisInitialized(_this))
											);
										}
										_this.coreComponents = coreComponents;
										return _this;
									}
									var _proto = Hls.prototype;
									_proto.destroy = function destroy() {
										logger["logger"].log("destroy");
										this.trigger(events["default"].DESTROYING);
										this.detachMedia();
										this.coreComponents
											.concat(this.networkControllers)
											.forEach(function (component) {
												component.destroy();
											});
										this.url = null;
										this.removeAllListeners();
										this._autoLevelCapping = -1;
									};
									_proto.attachMedia = function attachMedia(media) {
										logger["logger"].log("attachMedia");
										this.media = media;
										this.trigger(events["default"].MEDIA_ATTACHING, {
											media: media,
										});
									};
									_proto.detachMedia = function detachMedia() {
										logger["logger"].log("detachMedia");
										this.trigger(events["default"].MEDIA_DETACHING);
										this.media = null;
									};
									_proto.loadSource = function loadSource(url) {
										url = url_toolkit["buildAbsoluteURL"](
											window.location.href,
											url,
											{ alwaysNormalize: true }
										);
										logger["logger"].log("loadSource:" + url);
										this.url = url;
										this.trigger(events["default"].MANIFEST_LOADING, {
											url: url,
										});
									};
									_proto.startLoad = function startLoad(startPosition) {
										if (startPosition === void 0) {
											startPosition = -1;
										}
										logger["logger"].log("startLoad(" + startPosition + ")");
										this.networkControllers.forEach(function (controller) {
											controller.startLoad(startPosition);
										});
									};
									_proto.stopLoad = function stopLoad() {
										logger["logger"].log("stopLoad");
										this.networkControllers.forEach(function (controller) {
											controller.stopLoad();
										});
									};
									_proto.swapAudioCodec = function swapAudioCodec() {
										logger["logger"].log("swapAudioCodec");
										this.streamController.swapAudioCodec();
									};
									_proto.recoverMediaError = function recoverMediaError() {
										logger["logger"].log("recoverMediaError");
										var media = this.media;
										this.detachMedia();
										if (media) {
											this.attachMedia(media);
										}
									};
									_proto.removeLevel = function removeLevel(levelIndex, urlId) {
										if (urlId === void 0) {
											urlId = 0;
										}
										this.levelController.removeLevel(levelIndex, urlId);
									};
									hls_createClass(Hls, [
										{
											key: "levels",
											get: function get() {
												return this.levelController.levels;
											},
										},
										{
											key: "currentLevel",
											get: function get() {
												return this.streamController.currentLevel;
											},
											set: function set(newLevel) {
												logger["logger"].log("set currentLevel:" + newLevel);
												this.loadLevel = newLevel;
												this.streamController.immediateLevelSwitch();
											},
										},
										{
											key: "nextLevel",
											get: function get() {
												return this.streamController.nextLevel;
											},
											set: function set(newLevel) {
												logger["logger"].log("set nextLevel:" + newLevel);
												this.levelController.manualLevel = newLevel;
												this.streamController.nextLevelSwitch();
											},
										},
										{
											key: "loadLevel",
											get: function get() {
												return this.levelController.level;
											},
											set: function set(newLevel) {
												logger["logger"].log("set loadLevel:" + newLevel);
												this.levelController.manualLevel = newLevel;
											},
										},
										{
											key: "nextLoadLevel",
											get: function get() {
												return this.levelController.nextLoadLevel;
											},
											set: function set(level) {
												this.levelController.nextLoadLevel = level;
											},
										},
										{
											key: "firstLevel",
											get: function get() {
												return Math.max(
													this.levelController.firstLevel,
													this.minAutoLevel
												);
											},
											set: function set(newLevel) {
												logger["logger"].log("set firstLevel:" + newLevel);
												this.levelController.firstLevel = newLevel;
											},
										},
										{
											key: "startLevel",
											get: function get() {
												return this.levelController.startLevel;
											},
											set: function set(newLevel) {
												logger["logger"].log("set startLevel:" + newLevel);
												if (newLevel !== -1) {
													newLevel = Math.max(newLevel, this.minAutoLevel);
												}
												this.levelController.startLevel = newLevel;
											},
										},
										{
											key: "capLevelToPlayerSize",
											set: function set(shouldStartCapping) {
												var newCapLevelToPlayerSize = !!shouldStartCapping;
												if (
													newCapLevelToPlayerSize !==
													this.config.capLevelToPlayerSize
												) {
													if (newCapLevelToPlayerSize) {
														this.capLevelController.startCapping();
													} else {
														this.capLevelController.stopCapping();
														this.autoLevelCapping = -1;
														this.streamController.nextLevelSwitch();
													}
													this.config.capLevelToPlayerSize =
														newCapLevelToPlayerSize;
												}
											},
										},
										{
											key: "autoLevelCapping",
											get: function get() {
												return this._autoLevelCapping;
											},
											set: function set(newLevel) {
												logger["logger"].log(
													"set autoLevelCapping:" + newLevel
												);
												this._autoLevelCapping = newLevel;
											},
										},
										{
											key: "bandwidthEstimate",
											get: function get() {
												var bwEstimator = this.abrController._bwEstimator;
												return bwEstimator ? bwEstimator.getEstimate() : NaN;
											},
										},
										{
											key: "autoLevelEnabled",
											get: function get() {
												return this.levelController.manualLevel === -1;
											},
										},
										{
											key: "manualLevel",
											get: function get() {
												return this.levelController.manualLevel;
											},
										},
										{
											key: "minAutoLevel",
											get: function get() {
												var levels = this.levels,
													minAutoBitrate = this.config.minAutoBitrate;
												var len = levels ? levels.length : 0;
												for (var i = 0; i < len; i++) {
													var levelNextBitrate = levels[i].realBitrate
														? Math.max(levels[i].realBitrate, levels[i].bitrate)
														: levels[i].bitrate;
													if (levelNextBitrate > minAutoBitrate) {
														return i;
													}
												}
												return 0;
											},
										},
										{
											key: "maxAutoLevel",
											get: function get() {
												var levels = this.levels,
													autoLevelCapping = this.autoLevelCapping;
												var maxAutoLevel;
												if (
													autoLevelCapping === -1 &&
													levels &&
													levels.length
												) {
													maxAutoLevel = levels.length - 1;
												} else {
													maxAutoLevel = autoLevelCapping;
												}
												return maxAutoLevel;
											},
										},
										{
											key: "nextAutoLevel",
											get: function get() {
												return Math.min(
													Math.max(
														this.abrController.nextAutoLevel,
														this.minAutoLevel
													),
													this.maxAutoLevel
												);
											},
											set: function set(nextLevel) {
												this.abrController.nextAutoLevel = Math.max(
													this.minAutoLevel,
													nextLevel
												);
											},
										},
										{
											key: "audioTracks",
											get: function get() {
												var audioTrackController = this.audioTrackController;
												return audioTrackController
													? audioTrackController.audioTracks
													: [];
											},
										},
										{
											key: "audioTrack",
											get: function get() {
												var audioTrackController = this.audioTrackController;
												return audioTrackController
													? audioTrackController.audioTrack
													: -1;
											},
											set: function set(audioTrackId) {
												var audioTrackController = this.audioTrackController;
												if (audioTrackController) {
													audioTrackController.audioTrack = audioTrackId;
												}
											},
										},
										{
											key: "liveSyncPosition",
											get: function get() {
												return this.streamController.liveSyncPosition;
											},
										},
										{
											key: "subtitleTracks",
											get: function get() {
												var subtitleTrackController =
													this.subtitleTrackController;
												return subtitleTrackController
													? subtitleTrackController.subtitleTracks
													: [];
											},
										},
										{
											key: "subtitleTrack",
											get: function get() {
												var subtitleTrackController =
													this.subtitleTrackController;
												return subtitleTrackController
													? subtitleTrackController.subtitleTrack
													: -1;
											},
											set: function set(subtitleTrackId) {
												var subtitleTrackController =
													this.subtitleTrackController;
												if (subtitleTrackController) {
													subtitleTrackController.subtitleTrack =
														subtitleTrackId;
												}
											},
										},
										{
											key: "subtitleDisplay",
											get: function get() {
												var subtitleTrackController =
													this.subtitleTrackController;
												return subtitleTrackController
													? subtitleTrackController.subtitleDisplay
													: false;
											},
											set: function set(value) {
												var subtitleTrackController =
													this.subtitleTrackController;
												if (subtitleTrackController) {
													subtitleTrackController.subtitleDisplay = value;
												}
											},
										},
									]);
									return Hls;
								})(Observer);
								hls_Hls.defaultConfig = void 0;
							},
							"./src/polyfills/number.js": function (
								module,
								__webpack_exports__,
								__webpack_require__
							) {
								"use strict";
								__webpack_require__.r(__webpack_exports__);
								__webpack_require__.d(
									__webpack_exports__,
									"isFiniteNumber",
									function () {
										return isFiniteNumber;
									}
								);
								__webpack_require__.d(
									__webpack_exports__,
									"MAX_SAFE_INTEGER",
									function () {
										return MAX_SAFE_INTEGER;
									}
								);
								var isFiniteNumber =
									Number.isFinite ||
									function (value) {
										return typeof value === "number" && isFinite(value);
									};
								var MAX_SAFE_INTEGER =
									Number.MAX_SAFE_INTEGER || 9007199254740991;
							},
							"./src/utils/get-self-scope.js": function (
								module,
								__webpack_exports__,
								__webpack_require__
							) {
								"use strict";
								__webpack_require__.r(__webpack_exports__);
								__webpack_require__.d(
									__webpack_exports__,
									"getSelfScope",
									function () {
										return getSelfScope;
									}
								);
								function getSelfScope() {
									if (typeof window === "undefined") {
										return self;
									} else {
										return window;
									}
								}
							},
							"./src/utils/logger.js": function (
								module,
								__webpack_exports__,
								__webpack_require__
							) {
								"use strict";
								__webpack_require__.r(__webpack_exports__);
								__webpack_require__.d(
									__webpack_exports__,
									"enableLogs",
									function () {
										return enableLogs;
									}
								);
								__webpack_require__.d(
									__webpack_exports__,
									"logger",
									function () {
										return logger;
									}
								);
								var _get_self_scope__WEBPACK_IMPORTED_MODULE_0__ =
									__webpack_require__("./src/utils/get-self-scope.js");
								function noop() {}
								var fakeLogger = {
									trace: noop,
									debug: noop,
									log: noop,
									warn: noop,
									info: noop,
									error: noop,
								};
								var exportedLogger = fakeLogger;
								function formatMsg(type, msg) {
									msg = "[" + type + "] > " + msg;
									return msg;
								}
								var global = Object(
									_get_self_scope__WEBPACK_IMPORTED_MODULE_0__["getSelfScope"]
								)();
								function consolePrintFn(type) {
									var func = global.console[type];
									if (func) {
										return function () {
											for (
												var _len = arguments.length,
													args = new Array(_len),
													_key = 0;
												_key < _len;
												_key++
											) {
												args[_key] = arguments[_key];
											}
											if (args[0]) {
												args[0] = formatMsg(type, args[0]);
											}
											func.apply(global.console, args);
										};
									}
									return noop;
								}
								function exportLoggerFunctions(debugConfig) {
									for (
										var _len2 = arguments.length,
											functions = new Array(_len2 > 1 ? _len2 - 1 : 0),
											_key2 = 1;
										_key2 < _len2;
										_key2++
									) {
										functions[_key2 - 1] = arguments[_key2];
									}
									functions.forEach(function (type) {
										exportedLogger[type] = debugConfig[type]
											? debugConfig[type].bind(debugConfig)
											: consolePrintFn(type);
									});
								}
								var enableLogs = function enableLogs(debugConfig) {
									if (
										(global.console && debugConfig === true) ||
										typeof debugConfig === "object"
									) {
										exportLoggerFunctions(
											debugConfig,
											"debug",
											"log",
											"info",
											"warn",
											"error"
										);
										try {
											exportedLogger.log();
										} catch (e) {
											exportedLogger = fakeLogger;
										}
									} else {
										exportedLogger = fakeLogger;
									}
								};
								var logger = exportedLogger;
							},
						})["default"];
					});
			},
			{},
		],
		9: [
			function (require, module, exports) {
				var root = require("./_root");
				var Symbol = root.Symbol;
				module.exports = Symbol;
			},
			{ "./_root": 34 },
		],
		10: [
			function (require, module, exports) {
				var baseTimes = require("./_baseTimes"),
					isArguments = require("./isArguments"),
					isArray = require("./isArray"),
					isBuffer = require("./isBuffer"),
					isIndex = require("./_isIndex"),
					isTypedArray = require("./isTypedArray");
				var objectProto = Object.prototype;
				var hasOwnProperty = objectProto.hasOwnProperty;
				function arrayLikeKeys(value, inherited) {
					var isArr = isArray(value),
						isArg = !isArr && isArguments(value),
						isBuff = !isArr && !isArg && isBuffer(value),
						isType = !isArr && !isArg && !isBuff && isTypedArray(value),
						skipIndexes = isArr || isArg || isBuff || isType,
						result = skipIndexes ? baseTimes(value.length, String) : [],
						length = result.length;
					for (var key in value) {
						if (
							(inherited || hasOwnProperty.call(value, key)) &&
							!(
								skipIndexes &&
								(key == "length" ||
									(isBuff && (key == "offset" || key == "parent")) ||
									(isType &&
										(key == "buffer" ||
											key == "byteLength" ||
											key == "byteOffset")) ||
									isIndex(key, length))
							)
						) {
							result.push(key);
						}
					}
					return result;
				}
				module.exports = arrayLikeKeys;
			},
			{
				"./_baseTimes": 21,
				"./_isIndex": 28,
				"./isArguments": 38,
				"./isArray": 39,
				"./isBuffer": 41,
				"./isTypedArray": 47,
			},
		],
		11: [
			function (require, module, exports) {
				function arrayMap(array, iteratee) {
					var index = -1,
						length = array == null ? 0 : array.length,
						result = Array(length);
					while (++index < length) {
						result[index] = iteratee(array[index], index, array);
					}
					return result;
				}
				module.exports = arrayMap;
			},
			{},
		],
		12: [
			function (require, module, exports) {
				var baseRandom = require("./_baseRandom");
				function arraySample(array) {
					var length = array.length;
					return length ? array[baseRandom(0, length - 1)] : undefined;
				}
				module.exports = arraySample;
			},
			{ "./_baseRandom": 18 },
		],
		13: [
			function (require, module, exports) {
				var copyArray = require("./_copyArray"),
					shuffleSelf = require("./_shuffleSelf");
				function arrayShuffle(array) {
					return shuffleSelf(copyArray(array));
				}
				module.exports = arrayShuffle;
			},
			{ "./_copyArray": 25, "./_shuffleSelf": 35 },
		],
		14: [
			function (require, module, exports) {
				var Symbol = require("./_Symbol"),
					getRawTag = require("./_getRawTag"),
					objectToString = require("./_objectToString");
				var nullTag = "[object Null]",
					undefinedTag = "[object Undefined]";
				var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
				function baseGetTag(value) {
					if (value == null) {
						return value === undefined ? undefinedTag : nullTag;
					}
					return symToStringTag && symToStringTag in Object(value)
						? getRawTag(value)
						: objectToString(value);
				}
				module.exports = baseGetTag;
			},
			{ "./_Symbol": 9, "./_getRawTag": 27, "./_objectToString": 32 },
		],
		15: [
			function (require, module, exports) {
				var baseGetTag = require("./_baseGetTag"),
					isObjectLike = require("./isObjectLike");
				var argsTag = "[object Arguments]";
				function baseIsArguments(value) {
					return isObjectLike(value) && baseGetTag(value) == argsTag;
				}
				module.exports = baseIsArguments;
			},
			{ "./_baseGetTag": 14, "./isObjectLike": 45 },
		],
		16: [
			function (require, module, exports) {
				var baseGetTag = require("./_baseGetTag"),
					isLength = require("./isLength"),
					isObjectLike = require("./isObjectLike");
				var argsTag = "[object Arguments]",
					arrayTag = "[object Array]",
					boolTag = "[object Boolean]",
					dateTag = "[object Date]",
					errorTag = "[object Error]",
					funcTag = "[object Function]",
					mapTag = "[object Map]",
					numberTag = "[object Number]",
					objectTag = "[object Object]",
					regexpTag = "[object RegExp]",
					setTag = "[object Set]",
					stringTag = "[object String]",
					weakMapTag = "[object WeakMap]";
				var arrayBufferTag = "[object ArrayBuffer]",
					dataViewTag = "[object DataView]",
					float32Tag = "[object Float32Array]",
					float64Tag = "[object Float64Array]",
					int8Tag = "[object Int8Array]",
					int16Tag = "[object Int16Array]",
					int32Tag = "[object Int32Array]",
					uint8Tag = "[object Uint8Array]",
					uint8ClampedTag = "[object Uint8ClampedArray]",
					uint16Tag = "[object Uint16Array]",
					uint32Tag = "[object Uint32Array]";
				var typedArrayTags = {};
				typedArrayTags[float32Tag] =
					typedArrayTags[float64Tag] =
					typedArrayTags[int8Tag] =
					typedArrayTags[int16Tag] =
					typedArrayTags[int32Tag] =
					typedArrayTags[uint8Tag] =
					typedArrayTags[uint8ClampedTag] =
					typedArrayTags[uint16Tag] =
					typedArrayTags[uint32Tag] =
						true;
				typedArrayTags[argsTag] =
					typedArrayTags[arrayTag] =
					typedArrayTags[arrayBufferTag] =
					typedArrayTags[boolTag] =
					typedArrayTags[dataViewTag] =
					typedArrayTags[dateTag] =
					typedArrayTags[errorTag] =
					typedArrayTags[funcTag] =
					typedArrayTags[mapTag] =
					typedArrayTags[numberTag] =
					typedArrayTags[objectTag] =
					typedArrayTags[regexpTag] =
					typedArrayTags[setTag] =
					typedArrayTags[stringTag] =
					typedArrayTags[weakMapTag] =
						false;
				function baseIsTypedArray(value) {
					return (
						isObjectLike(value) &&
						isLength(value.length) &&
						!!typedArrayTags[baseGetTag(value)]
					);
				}
				module.exports = baseIsTypedArray;
			},
			{ "./_baseGetTag": 14, "./isLength": 43, "./isObjectLike": 45 },
		],
		17: [
			function (require, module, exports) {
				var isPrototype = require("./_isPrototype"),
					nativeKeys = require("./_nativeKeys");
				var objectProto = Object.prototype;
				var hasOwnProperty = objectProto.hasOwnProperty;
				function baseKeys(object) {
					if (!isPrototype(object)) {
						return nativeKeys(object);
					}
					var result = [];
					for (var key in Object(object)) {
						if (hasOwnProperty.call(object, key) && key != "constructor") {
							result.push(key);
						}
					}
					return result;
				}
				module.exports = baseKeys;
			},
			{ "./_isPrototype": 29, "./_nativeKeys": 30 },
		],
		18: [
			function (require, module, exports) {
				var nativeFloor = Math.floor,
					nativeRandom = Math.random;
				function baseRandom(lower, upper) {
					return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
				}
				module.exports = baseRandom;
			},
			{},
		],
		19: [
			function (require, module, exports) {
				var arraySample = require("./_arraySample"),
					values = require("./values");
				function baseSample(collection) {
					return arraySample(values(collection));
				}
				module.exports = baseSample;
			},
			{ "./_arraySample": 12, "./values": 54 },
		],
		20: [
			function (require, module, exports) {
				var shuffleSelf = require("./_shuffleSelf"),
					values = require("./values");
				function baseShuffle(collection) {
					return shuffleSelf(values(collection));
				}
				module.exports = baseShuffle;
			},
			{ "./_shuffleSelf": 35, "./values": 54 },
		],
		21: [
			function (require, module, exports) {
				function baseTimes(n, iteratee) {
					var index = -1,
						result = Array(n);
					while (++index < n) {
						result[index] = iteratee(index);
					}
					return result;
				}
				module.exports = baseTimes;
			},
			{},
		],
		22: [
			function (require, module, exports) {
				var trimmedEndIndex = require("./_trimmedEndIndex");
				var reTrimStart = /^\s+/;
				function baseTrim(string) {
					return string
						? string
								.slice(0, trimmedEndIndex(string) + 1)
								.replace(reTrimStart, "")
						: string;
				}
				module.exports = baseTrim;
			},
			{ "./_trimmedEndIndex": 36 },
		],
		23: [
			function (require, module, exports) {
				function baseUnary(func) {
					return function (value) {
						return func(value);
					};
				}
				module.exports = baseUnary;
			},
			{},
		],
		24: [
			function (require, module, exports) {
				var arrayMap = require("./_arrayMap");
				function baseValues(object, props) {
					return arrayMap(props, function (key) {
						return object[key];
					});
				}
				module.exports = baseValues;
			},
			{ "./_arrayMap": 11 },
		],
		25: [
			function (require, module, exports) {
				function copyArray(source, array) {
					var index = -1,
						length = source.length;
					array || (array = Array(length));
					while (++index < length) {
						array[index] = source[index];
					}
					return array;
				}
				module.exports = copyArray;
			},
			{},
		],
		26: [
			function (require, module, exports) {
				(function (global) {
					(function () {
						var freeGlobal =
							typeof global == "object" &&
							global &&
							global.Object === Object &&
							global;
						module.exports = freeGlobal;
					}.call(this));
				}.call(
					this,
					typeof global !== "undefined"
						? global
						: typeof self !== "undefined"
						? self
						: typeof window !== "undefined"
						? window
						: {}
				));
			},
			{},
		],
		27: [
			function (require, module, exports) {
				var Symbol = require("./_Symbol");
				var objectProto = Object.prototype;
				var hasOwnProperty = objectProto.hasOwnProperty;
				var nativeObjectToString = objectProto.toString;
				var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
				function getRawTag(value) {
					var isOwn = hasOwnProperty.call(value, symToStringTag),
						tag = value[symToStringTag];
					try {
						value[symToStringTag] = undefined;
						var unmasked = true;
					} catch (e) {}
					var result = nativeObjectToString.call(value);
					if (unmasked) {
						if (isOwn) {
							value[symToStringTag] = tag;
						} else {
							delete value[symToStringTag];
						}
					}
					return result;
				}
				module.exports = getRawTag;
			},
			{ "./_Symbol": 9 },
		],
		28: [
			function (require, module, exports) {
				var MAX_SAFE_INTEGER = 9007199254740991;
				var reIsUint = /^(?:0|[1-9]\d*)$/;
				function isIndex(value, length) {
					var type = typeof value;
					length = length == null ? MAX_SAFE_INTEGER : length;
					return (
						!!length &&
						(type == "number" || (type != "symbol" && reIsUint.test(value))) &&
						value > -1 &&
						value % 1 == 0 &&
						value < length
					);
				}
				module.exports = isIndex;
			},
			{},
		],
		29: [
			function (require, module, exports) {
				var objectProto = Object.prototype;
				function isPrototype(value) {
					var Ctor = value && value.constructor,
						proto =
							(typeof Ctor == "function" && Ctor.prototype) || objectProto;
					return value === proto;
				}
				module.exports = isPrototype;
			},
			{},
		],
		30: [
			function (require, module, exports) {
				var overArg = require("./_overArg");
				var nativeKeys = overArg(Object.keys, Object);
				module.exports = nativeKeys;
			},
			{ "./_overArg": 33 },
		],
		31: [
			function (require, module, exports) {
				var freeGlobal = require("./_freeGlobal");
				var freeExports =
					typeof exports == "object" && exports && !exports.nodeType && exports;
				var freeModule =
					freeExports &&
					typeof module == "object" &&
					module &&
					!module.nodeType &&
					module;
				var moduleExports = freeModule && freeModule.exports === freeExports;
				var freeProcess = moduleExports && freeGlobal.process;
				var nodeUtil = (function () {
					try {
						var types =
							freeModule &&
							freeModule.require &&
							freeModule.require("util").types;
						if (types) {
							return types;
						}
						return (
							freeProcess && freeProcess.binding && freeProcess.binding("util")
						);
					} catch (e) {}
				})();
				module.exports = nodeUtil;
			},
			{ "./_freeGlobal": 26 },
		],
		32: [
			function (require, module, exports) {
				var objectProto = Object.prototype;
				var nativeObjectToString = objectProto.toString;
				function objectToString(value) {
					return nativeObjectToString.call(value);
				}
				module.exports = objectToString;
			},
			{},
		],
		33: [
			function (require, module, exports) {
				function overArg(func, transform) {
					return function (arg) {
						return func(transform(arg));
					};
				}
				module.exports = overArg;
			},
			{},
		],
		34: [
			function (require, module, exports) {
				var freeGlobal = require("./_freeGlobal");
				var freeSelf =
					typeof self == "object" && self && self.Object === Object && self;
				var root = freeGlobal || freeSelf || Function("return this")();
				module.exports = root;
			},
			{ "./_freeGlobal": 26 },
		],
		35: [
			function (require, module, exports) {
				var baseRandom = require("./_baseRandom");
				function shuffleSelf(array, size) {
					var index = -1,
						length = array.length,
						lastIndex = length - 1;
					size = size === undefined ? length : size;
					while (++index < size) {
						var rand = baseRandom(index, lastIndex),
							value = array[rand];
						array[rand] = array[index];
						array[index] = value;
					}
					array.length = size;
					return array;
				}
				module.exports = shuffleSelf;
			},
			{ "./_baseRandom": 18 },
		],
		36: [
			function (require, module, exports) {
				var reWhitespace = /\s/;
				function trimmedEndIndex(string) {
					var index = string.length;
					while (index-- && reWhitespace.test(string.charAt(index))) {}
					return index;
				}
				module.exports = trimmedEndIndex;
			},
			{},
		],
		37: [
			function (require, module, exports) {
				var isObject = require("./isObject"),
					now = require("./now"),
					toNumber = require("./toNumber");
				var FUNC_ERROR_TEXT = "Expected a function";
				var nativeMax = Math.max,
					nativeMin = Math.min;
				function debounce(func, wait, options) {
					var lastArgs,
						lastThis,
						maxWait,
						result,
						timerId,
						lastCallTime,
						lastInvokeTime = 0,
						leading = false,
						maxing = false,
						trailing = true;
					if (typeof func != "function") {
						throw new TypeError(FUNC_ERROR_TEXT);
					}
					wait = toNumber(wait) || 0;
					if (isObject(options)) {
						leading = !!options.leading;
						maxing = "maxWait" in options;
						maxWait = maxing
							? nativeMax(toNumber(options.maxWait) || 0, wait)
							: maxWait;
						trailing = "trailing" in options ? !!options.trailing : trailing;
					}
					function invokeFunc(time) {
						var args = lastArgs,
							thisArg = lastThis;
						lastArgs = lastThis = undefined;
						lastInvokeTime = time;
						result = func.apply(thisArg, args);
						return result;
					}
					function leadingEdge(time) {
						lastInvokeTime = time;
						timerId = setTimeout(timerExpired, wait);
						return leading ? invokeFunc(time) : result;
					}
					function remainingWait(time) {
						var timeSinceLastCall = time - lastCallTime,
							timeSinceLastInvoke = time - lastInvokeTime,
							timeWaiting = wait - timeSinceLastCall;
						return maxing
							? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
							: timeWaiting;
					}
					function shouldInvoke(time) {
						var timeSinceLastCall = time - lastCallTime,
							timeSinceLastInvoke = time - lastInvokeTime;
						return (
							lastCallTime === undefined ||
							timeSinceLastCall >= wait ||
							timeSinceLastCall < 0 ||
							(maxing && timeSinceLastInvoke >= maxWait)
						);
					}
					function timerExpired() {
						var time = now();
						if (shouldInvoke(time)) {
							return trailingEdge(time);
						}
						timerId = setTimeout(timerExpired, remainingWait(time));
					}
					function trailingEdge(time) {
						timerId = undefined;
						if (trailing && lastArgs) {
							return invokeFunc(time);
						}
						lastArgs = lastThis = undefined;
						return result;
					}
					function cancel() {
						if (timerId !== undefined) {
							clearTimeout(timerId);
						}
						lastInvokeTime = 0;
						lastArgs = lastCallTime = lastThis = timerId = undefined;
					}
					function flush() {
						return timerId === undefined ? result : trailingEdge(now());
					}
					function debounced() {
						var time = now(),
							isInvoking = shouldInvoke(time);
						lastArgs = arguments;
						lastThis = this;
						lastCallTime = time;
						if (isInvoking) {
							if (timerId === undefined) {
								return leadingEdge(lastCallTime);
							}
							if (maxing) {
								clearTimeout(timerId);
								timerId = setTimeout(timerExpired, wait);
								return invokeFunc(lastCallTime);
							}
						}
						if (timerId === undefined) {
							timerId = setTimeout(timerExpired, wait);
						}
						return result;
					}
					debounced.cancel = cancel;
					debounced.flush = flush;
					return debounced;
				}
				module.exports = debounce;
			},
			{ "./isObject": 44, "./now": 49, "./toNumber": 53 },
		],
		38: [
			function (require, module, exports) {
				var baseIsArguments = require("./_baseIsArguments"),
					isObjectLike = require("./isObjectLike");
				var objectProto = Object.prototype;
				var hasOwnProperty = objectProto.hasOwnProperty;
				var propertyIsEnumerable = objectProto.propertyIsEnumerable;
				var isArguments = baseIsArguments(
					(function () {
						return arguments;
					})()
				)
					? baseIsArguments
					: function (value) {
							return (
								isObjectLike(value) &&
								hasOwnProperty.call(value, "callee") &&
								!propertyIsEnumerable.call(value, "callee")
							);
					  };
				module.exports = isArguments;
			},
			{ "./_baseIsArguments": 15, "./isObjectLike": 45 },
		],
		39: [
			function (require, module, exports) {
				var isArray = Array.isArray;
				module.exports = isArray;
			},
			{},
		],
		40: [
			function (require, module, exports) {
				var isFunction = require("./isFunction"),
					isLength = require("./isLength");
				function isArrayLike(value) {
					return value != null && isLength(value.length) && !isFunction(value);
				}
				module.exports = isArrayLike;
			},
			{ "./isFunction": 42, "./isLength": 43 },
		],
		41: [
			function (require, module, exports) {
				var root = require("./_root"),
					stubFalse = require("./stubFalse");
				var freeExports =
					typeof exports == "object" && exports && !exports.nodeType && exports;
				var freeModule =
					freeExports &&
					typeof module == "object" &&
					module &&
					!module.nodeType &&
					module;
				var moduleExports = freeModule && freeModule.exports === freeExports;
				var Buffer = moduleExports ? root.Buffer : undefined;
				var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
				var isBuffer = nativeIsBuffer || stubFalse;
				module.exports = isBuffer;
			},
			{ "./_root": 34, "./stubFalse": 52 },
		],
		42: [
			function (require, module, exports) {
				var baseGetTag = require("./_baseGetTag"),
					isObject = require("./isObject");
				var asyncTag = "[object AsyncFunction]",
					funcTag = "[object Function]",
					genTag = "[object GeneratorFunction]",
					proxyTag = "[object Proxy]";
				function isFunction(value) {
					if (!isObject(value)) {
						return false;
					}
					var tag = baseGetTag(value);
					return (
						tag == funcTag ||
						tag == genTag ||
						tag == asyncTag ||
						tag == proxyTag
					);
				}
				module.exports = isFunction;
			},
			{ "./_baseGetTag": 14, "./isObject": 44 },
		],
		43: [
			function (require, module, exports) {
				var MAX_SAFE_INTEGER = 9007199254740991;
				function isLength(value) {
					return (
						typeof value == "number" &&
						value > -1 &&
						value % 1 == 0 &&
						value <= MAX_SAFE_INTEGER
					);
				}
				module.exports = isLength;
			},
			{},
		],
		44: [
			function (require, module, exports) {
				function isObject(value) {
					var type = typeof value;
					return value != null && (type == "object" || type == "function");
				}
				module.exports = isObject;
			},
			{},
		],
		45: [
			function (require, module, exports) {
				function isObjectLike(value) {
					return value != null && typeof value == "object";
				}
				module.exports = isObjectLike;
			},
			{},
		],
		46: [
			function (require, module, exports) {
				var baseGetTag = require("./_baseGetTag"),
					isObjectLike = require("./isObjectLike");
				var symbolTag = "[object Symbol]";
				function isSymbol(value) {
					return (
						typeof value == "symbol" ||
						(isObjectLike(value) && baseGetTag(value) == symbolTag)
					);
				}
				module.exports = isSymbol;
			},
			{ "./_baseGetTag": 14, "./isObjectLike": 45 },
		],
		47: [
			function (require, module, exports) {
				var baseIsTypedArray = require("./_baseIsTypedArray"),
					baseUnary = require("./_baseUnary"),
					nodeUtil = require("./_nodeUtil");
				var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
				var isTypedArray = nodeIsTypedArray
					? baseUnary(nodeIsTypedArray)
					: baseIsTypedArray;
				module.exports = isTypedArray;
			},
			{ "./_baseIsTypedArray": 16, "./_baseUnary": 23, "./_nodeUtil": 31 },
		],
		48: [
			function (require, module, exports) {
				var arrayLikeKeys = require("./_arrayLikeKeys"),
					baseKeys = require("./_baseKeys"),
					isArrayLike = require("./isArrayLike");
				function keys(object) {
					return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
				}
				module.exports = keys;
			},
			{ "./_arrayLikeKeys": 10, "./_baseKeys": 17, "./isArrayLike": 40 },
		],
		49: [
			function (require, module, exports) {
				var root = require("./_root");
				var now = function () {
					return root.Date.now();
				};
				module.exports = now;
			},
			{ "./_root": 34 },
		],
		50: [
			function (require, module, exports) {
				var arraySample = require("./_arraySample"),
					baseSample = require("./_baseSample"),
					isArray = require("./isArray");
				function sample(collection) {
					var func = isArray(collection) ? arraySample : baseSample;
					return func(collection);
				}
				module.exports = sample;
			},
			{ "./_arraySample": 12, "./_baseSample": 19, "./isArray": 39 },
		],
		51: [
			function (require, module, exports) {
				var arrayShuffle = require("./_arrayShuffle"),
					baseShuffle = require("./_baseShuffle"),
					isArray = require("./isArray");
				function shuffle(collection) {
					var func = isArray(collection) ? arrayShuffle : baseShuffle;
					return func(collection);
				}
				module.exports = shuffle;
			},
			{ "./_arrayShuffle": 13, "./_baseShuffle": 20, "./isArray": 39 },
		],
		52: [
			function (require, module, exports) {
				function stubFalse() {
					return false;
				}
				module.exports = stubFalse;
			},
			{},
		],
		53: [
			function (require, module, exports) {
				var baseTrim = require("./_baseTrim"),
					isObject = require("./isObject"),
					isSymbol = require("./isSymbol");
				var NAN = 0 / 0;
				var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
				var reIsBinary = /^0b[01]+$/i;
				var reIsOctal = /^0o[0-7]+$/i;
				var freeParseInt = parseInt;
				function toNumber(value) {
					if (typeof value == "number") {
						return value;
					}
					if (isSymbol(value)) {
						return NAN;
					}
					if (isObject(value)) {
						var other =
							typeof value.valueOf == "function" ? value.valueOf() : value;
						value = isObject(other) ? other + "" : other;
					}
					if (typeof value != "string") {
						return value === 0 ? value : +value;
					}
					value = baseTrim(value);
					var isBinary = reIsBinary.test(value);
					return isBinary || reIsOctal.test(value)
						? freeParseInt(value.slice(2), isBinary ? 2 : 8)
						: reIsBadHex.test(value)
						? NAN
						: +value;
				}
				module.exports = toNumber;
			},
			{ "./_baseTrim": 22, "./isObject": 44, "./isSymbol": 46 },
		],
		54: [
			function (require, module, exports) {
				var baseValues = require("./_baseValues"),
					keys = require("./keys");
				function values(object) {
					return object == null ? [] : baseValues(object, keys(object));
				}
				module.exports = values;
			},
			{ "./_baseValues": 24, "./keys": 48 },
		],
		55: [
			function (require, module, exports) {
				var process = (module.exports = {});
				var cachedSetTimeout;
				var cachedClearTimeout;
				function defaultSetTimout() {
					throw new Error("setTimeout has not been defined");
				}
				function defaultClearTimeout() {
					throw new Error("clearTimeout has not been defined");
				}
				(function () {
					try {
						if (typeof setTimeout === "function") {
							cachedSetTimeout = setTimeout;
						} else {
							cachedSetTimeout = defaultSetTimout;
						}
					} catch (e) {
						cachedSetTimeout = defaultSetTimout;
					}
					try {
						if (typeof clearTimeout === "function") {
							cachedClearTimeout = clearTimeout;
						} else {
							cachedClearTimeout = defaultClearTimeout;
						}
					} catch (e) {
						cachedClearTimeout = defaultClearTimeout;
					}
				})();
				function runTimeout(fun) {
					if (cachedSetTimeout === setTimeout) {
						return setTimeout(fun, 0);
					}
					if (
						(cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
						setTimeout
					) {
						cachedSetTimeout = setTimeout;
						return setTimeout(fun, 0);
					}
					try {
						return cachedSetTimeout(fun, 0);
					} catch (e) {
						try {
							return cachedSetTimeout.call(null, fun, 0);
						} catch (e) {
							return cachedSetTimeout.call(this, fun, 0);
						}
					}
				}
				function runClearTimeout(marker) {
					if (cachedClearTimeout === clearTimeout) {
						return clearTimeout(marker);
					}
					if (
						(cachedClearTimeout === defaultClearTimeout ||
							!cachedClearTimeout) &&
						clearTimeout
					) {
						cachedClearTimeout = clearTimeout;
						return clearTimeout(marker);
					}
					try {
						return cachedClearTimeout(marker);
					} catch (e) {
						try {
							return cachedClearTimeout.call(null, marker);
						} catch (e) {
							return cachedClearTimeout.call(this, marker);
						}
					}
				}
				var queue = [];
				var draining = false;
				var currentQueue;
				var queueIndex = -1;
				function cleanUpNextTick() {
					if (!draining || !currentQueue) {
						return;
					}
					draining = false;
					if (currentQueue.length) {
						queue = currentQueue.concat(queue);
					} else {
						queueIndex = -1;
					}
					if (queue.length) {
						drainQueue();
					}
				}
				function drainQueue() {
					if (draining) {
						return;
					}
					var timeout = runTimeout(cleanUpNextTick);
					draining = true;
					var len = queue.length;
					while (len) {
						currentQueue = queue;
						queue = [];
						while (++queueIndex < len) {
							if (currentQueue) {
								currentQueue[queueIndex].run();
							}
						}
						queueIndex = -1;
						len = queue.length;
					}
					currentQueue = null;
					draining = false;
					runClearTimeout(timeout);
				}
				process.nextTick = function (fun) {
					var args = new Array(arguments.length - 1);
					if (arguments.length > 1) {
						for (var i = 1; i < arguments.length; i++) {
							args[i - 1] = arguments[i];
						}
					}
					queue.push(new Item(fun, args));
					if (queue.length === 1 && !draining) {
						runTimeout(drainQueue);
					}
				};
				function Item(fun, array) {
					this.fun = fun;
					this.array = array;
				}
				Item.prototype.run = function () {
					this.fun.apply(null, this.array);
				};
				process.title = "browser";
				process.browser = true;
				process.env = {};
				process.argv = [];
				process.version = "";
				process.versions = {};
				function noop() {}
				process.on = noop;
				process.addListener = noop;
				process.once = noop;
				process.off = noop;
				process.removeListener = noop;
				process.removeAllListeners = noop;
				process.emit = noop;
				process.prependListener = noop;
				process.prependOnceListener = noop;
				process.listeners = function (name) {
					return [];
				};
				process.binding = function (name) {
					throw new Error("process.binding is not supported");
				};
				process.cwd = function () {
					return "/";
				};
				process.chdir = function (dir) {
					throw new Error("process.chdir is not supported");
				};
				process.umask = function () {
					return 0;
				};
			},
			{},
		],
		56: [
			function (require, module, exports) {
				(function (global, factory) {
					typeof exports === "object" && typeof module !== "undefined"
						? (module.exports = factory())
						: typeof define === "function" && define.amd
						? define(factory)
						: ((global = global || self), (global.Swiper = factory()));
				})(this, function () {
					"use strict";
					var doc =
						typeof document === "undefined"
							? {
									body: {},
									addEventListener: function addEventListener() {},
									removeEventListener: function removeEventListener() {},
									activeElement: { blur: function blur() {}, nodeName: "" },
									querySelector: function querySelector() {
										return null;
									},
									querySelectorAll: function querySelectorAll() {
										return [];
									},
									getElementById: function getElementById() {
										return null;
									},
									createEvent: function createEvent() {
										return { initEvent: function initEvent() {} };
									},
									createElement: function createElement() {
										return {
											children: [],
											childNodes: [],
											style: {},
											setAttribute: function setAttribute() {},
											getElementsByTagName: function getElementsByTagName() {
												return [];
											},
										};
									},
									location: { hash: "" },
							  }
							: document;
					var win =
						typeof window === "undefined"
							? {
									document: doc,
									navigator: { userAgent: "" },
									location: {},
									history: {},
									CustomEvent: function CustomEvent() {
										return this;
									},
									addEventListener: function addEventListener() {},
									removeEventListener: function removeEventListener() {},
									getComputedStyle: function getComputedStyle() {
										return {
											getPropertyValue: function getPropertyValue() {
												return "";
											},
										};
									},
									Image: function Image() {},
									Date: function Date() {},
									screen: {},
									setTimeout: function setTimeout() {},
									clearTimeout: function clearTimeout() {},
							  }
							: window;
					var Dom7 = function Dom7(arr) {
						var self = this;
						for (var i = 0; i < arr.length; i += 1) {
							self[i] = arr[i];
						}
						self.length = arr.length;
						return this;
					};
					function $(selector, context) {
						var arr = [];
						var i = 0;
						if (selector && !context) {
							if (selector instanceof Dom7) {
								return selector;
							}
						}
						if (selector) {
							if (typeof selector === "string") {
								var els;
								var tempParent;
								var html = selector.trim();
								if (html.indexOf("<") >= 0 && html.indexOf(">") >= 0) {
									var toCreate = "div";
									if (html.indexOf("<li") === 0) {
										toCreate = "ul";
									}
									if (html.indexOf("<tr") === 0) {
										toCreate = "tbody";
									}
									if (html.indexOf("<td") === 0 || html.indexOf("<th") === 0) {
										toCreate = "tr";
									}
									if (html.indexOf("<tbody") === 0) {
										toCreate = "table";
									}
									if (html.indexOf("<option") === 0) {
										toCreate = "select";
									}
									tempParent = doc.createElement(toCreate);
									tempParent.innerHTML = html;
									for (i = 0; i < tempParent.childNodes.length; i += 1) {
										arr.push(tempParent.childNodes[i]);
									}
								} else {
									if (
										!context &&
										selector[0] === "#" &&
										!selector.match(/[ .<>:~]/)
									) {
										els = [doc.getElementById(selector.trim().split("#")[1])];
									} else {
										els = (context || doc).querySelectorAll(selector.trim());
									}
									for (i = 0; i < els.length; i += 1) {
										if (els[i]) {
											arr.push(els[i]);
										}
									}
								}
							} else if (
								selector.nodeType ||
								selector === win ||
								selector === doc
							) {
								arr.push(selector);
							} else if (selector.length > 0 && selector[0].nodeType) {
								for (i = 0; i < selector.length; i += 1) {
									arr.push(selector[i]);
								}
							}
						}
						return new Dom7(arr);
					}
					$.fn = Dom7.prototype;
					$.Class = Dom7;
					$.Dom7 = Dom7;
					function unique(arr) {
						var uniqueArray = [];
						for (var i = 0; i < arr.length; i += 1) {
							if (uniqueArray.indexOf(arr[i]) === -1) {
								uniqueArray.push(arr[i]);
							}
						}
						return uniqueArray;
					}
					function addClass(className) {
						if (typeof className === "undefined") {
							return this;
						}
						var classes = className.split(" ");
						for (var i = 0; i < classes.length; i += 1) {
							for (var j = 0; j < this.length; j += 1) {
								if (
									typeof this[j] !== "undefined" &&
									typeof this[j].classList !== "undefined"
								) {
									this[j].classList.add(classes[i]);
								}
							}
						}
						return this;
					}
					function removeClass(className) {
						var classes = className.split(" ");
						for (var i = 0; i < classes.length; i += 1) {
							for (var j = 0; j < this.length; j += 1) {
								if (
									typeof this[j] !== "undefined" &&
									typeof this[j].classList !== "undefined"
								) {
									this[j].classList.remove(classes[i]);
								}
							}
						}
						return this;
					}
					function hasClass(className) {
						if (!this[0]) {
							return false;
						}
						return this[0].classList.contains(className);
					}
					function toggleClass(className) {
						var classes = className.split(" ");
						for (var i = 0; i < classes.length; i += 1) {
							for (var j = 0; j < this.length; j += 1) {
								if (
									typeof this[j] !== "undefined" &&
									typeof this[j].classList !== "undefined"
								) {
									this[j].classList.toggle(classes[i]);
								}
							}
						}
						return this;
					}
					function attr(attrs, value) {
						var arguments$1 = arguments;
						if (arguments.length === 1 && typeof attrs === "string") {
							if (this[0]) {
								return this[0].getAttribute(attrs);
							}
							return undefined;
						}
						for (var i = 0; i < this.length; i += 1) {
							if (arguments$1.length === 2) {
								this[i].setAttribute(attrs, value);
							} else {
								for (var attrName in attrs) {
									this[i][attrName] = attrs[attrName];
									this[i].setAttribute(attrName, attrs[attrName]);
								}
							}
						}
						return this;
					}
					function removeAttr(attr) {
						for (var i = 0; i < this.length; i += 1) {
							this[i].removeAttribute(attr);
						}
						return this;
					}
					function data(key, value) {
						var el;
						if (typeof value === "undefined") {
							el = this[0];
							if (el) {
								if (
									el.dom7ElementDataStorage &&
									key in el.dom7ElementDataStorage
								) {
									return el.dom7ElementDataStorage[key];
								}
								var dataKey = el.getAttribute("data-" + key);
								if (dataKey) {
									return dataKey;
								}
								return undefined;
							}
							return undefined;
						}
						for (var i = 0; i < this.length; i += 1) {
							el = this[i];
							if (!el.dom7ElementDataStorage) {
								el.dom7ElementDataStorage = {};
							}
							el.dom7ElementDataStorage[key] = value;
						}
						return this;
					}
					function transform(transform) {
						for (var i = 0; i < this.length; i += 1) {
							var elStyle = this[i].style;
							elStyle.webkitTransform = transform;
							elStyle.transform = transform;
						}
						return this;
					}
					function transition(duration) {
						if (typeof duration !== "string") {
							duration = duration + "ms";
						}
						for (var i = 0; i < this.length; i += 1) {
							var elStyle = this[i].style;
							elStyle.webkitTransitionDuration = duration;
							elStyle.transitionDuration = duration;
						}
						return this;
					}
					function on() {
						var assign;
						var args = [],
							len = arguments.length;
						while (len--) args[len] = arguments[len];
						var eventType = args[0];
						var targetSelector = args[1];
						var listener = args[2];
						var capture = args[3];
						if (typeof args[1] === "function") {
							(assign = args),
								(eventType = assign[0]),
								(listener = assign[1]),
								(capture = assign[2]);
							targetSelector = undefined;
						}
						if (!capture) {
							capture = false;
						}
						function handleLiveEvent(e) {
							var target = e.target;
							if (!target) {
								return;
							}
							var eventData = e.target.dom7EventData || [];
							if (eventData.indexOf(e) < 0) {
								eventData.unshift(e);
							}
							if ($(target).is(targetSelector)) {
								listener.apply(target, eventData);
							} else {
								var parents = $(target).parents();
								for (var k = 0; k < parents.length; k += 1) {
									if ($(parents[k]).is(targetSelector)) {
										listener.apply(parents[k], eventData);
									}
								}
							}
						}
						function handleEvent(e) {
							var eventData = e && e.target ? e.target.dom7EventData || [] : [];
							if (eventData.indexOf(e) < 0) {
								eventData.unshift(e);
							}
							listener.apply(this, eventData);
						}
						var events = eventType.split(" ");
						var j;
						for (var i = 0; i < this.length; i += 1) {
							var el = this[i];
							if (!targetSelector) {
								for (j = 0; j < events.length; j += 1) {
									var event = events[j];
									if (!el.dom7Listeners) {
										el.dom7Listeners = {};
									}
									if (!el.dom7Listeners[event]) {
										el.dom7Listeners[event] = [];
									}
									el.dom7Listeners[event].push({
										listener: listener,
										proxyListener: handleEvent,
									});
									el.addEventListener(event, handleEvent, capture);
								}
							} else {
								for (j = 0; j < events.length; j += 1) {
									var event$1 = events[j];
									if (!el.dom7LiveListeners) {
										el.dom7LiveListeners = {};
									}
									if (!el.dom7LiveListeners[event$1]) {
										el.dom7LiveListeners[event$1] = [];
									}
									el.dom7LiveListeners[event$1].push({
										listener: listener,
										proxyListener: handleLiveEvent,
									});
									el.addEventListener(event$1, handleLiveEvent, capture);
								}
							}
						}
						return this;
					}
					function off() {
						var assign;
						var args = [],
							len = arguments.length;
						while (len--) args[len] = arguments[len];
						var eventType = args[0];
						var targetSelector = args[1];
						var listener = args[2];
						var capture = args[3];
						if (typeof args[1] === "function") {
							(assign = args),
								(eventType = assign[0]),
								(listener = assign[1]),
								(capture = assign[2]);
							targetSelector = undefined;
						}
						if (!capture) {
							capture = false;
						}
						var events = eventType.split(" ");
						for (var i = 0; i < events.length; i += 1) {
							var event = events[i];
							for (var j = 0; j < this.length; j += 1) {
								var el = this[j];
								var handlers = void 0;
								if (!targetSelector && el.dom7Listeners) {
									handlers = el.dom7Listeners[event];
								} else if (targetSelector && el.dom7LiveListeners) {
									handlers = el.dom7LiveListeners[event];
								}
								if (handlers && handlers.length) {
									for (var k = handlers.length - 1; k >= 0; k -= 1) {
										var handler = handlers[k];
										if (listener && handler.listener === listener) {
											el.removeEventListener(
												event,
												handler.proxyListener,
												capture
											);
											handlers.splice(k, 1);
										} else if (
											listener &&
											handler.listener &&
											handler.listener.dom7proxy &&
											handler.listener.dom7proxy === listener
										) {
											el.removeEventListener(
												event,
												handler.proxyListener,
												capture
											);
											handlers.splice(k, 1);
										} else if (!listener) {
											el.removeEventListener(
												event,
												handler.proxyListener,
												capture
											);
											handlers.splice(k, 1);
										}
									}
								}
							}
						}
						return this;
					}
					function trigger() {
						var args = [],
							len = arguments.length;
						while (len--) args[len] = arguments[len];
						var events = args[0].split(" ");
						var eventData = args[1];
						for (var i = 0; i < events.length; i += 1) {
							var event = events[i];
							for (var j = 0; j < this.length; j += 1) {
								var el = this[j];
								var evt = void 0;
								try {
									evt = new win.CustomEvent(event, {
										detail: eventData,
										bubbles: true,
										cancelable: true,
									});
								} catch (e) {
									evt = doc.createEvent("Event");
									evt.initEvent(event, true, true);
									evt.detail = eventData;
								}
								el.dom7EventData = args.filter(function (data, dataIndex) {
									return dataIndex > 0;
								});
								el.dispatchEvent(evt);
								el.dom7EventData = [];
								delete el.dom7EventData;
							}
						}
						return this;
					}
					function transitionEnd(callback) {
						var events = ["webkitTransitionEnd", "transitionend"];
						var dom = this;
						var i;
						function fireCallBack(e) {
							if (e.target !== this) {
								return;
							}
							callback.call(this, e);
							for (i = 0; i < events.length; i += 1) {
								dom.off(events[i], fireCallBack);
							}
						}
						if (callback) {
							for (i = 0; i < events.length; i += 1) {
								dom.on(events[i], fireCallBack);
							}
						}
						return this;
					}
					function outerWidth(includeMargins) {
						if (this.length > 0) {
							if (includeMargins) {
								var styles = this.styles();
								return (
									this[0].offsetWidth +
									parseFloat(styles.getPropertyValue("margin-right")) +
									parseFloat(styles.getPropertyValue("margin-left"))
								);
							}
							return this[0].offsetWidth;
						}
						return null;
					}
					function outerHeight(includeMargins) {
						if (this.length > 0) {
							if (includeMargins) {
								var styles = this.styles();
								return (
									this[0].offsetHeight +
									parseFloat(styles.getPropertyValue("margin-top")) +
									parseFloat(styles.getPropertyValue("margin-bottom"))
								);
							}
							return this[0].offsetHeight;
						}
						return null;
					}
					function offset() {
						if (this.length > 0) {
							var el = this[0];
							var box = el.getBoundingClientRect();
							var body = doc.body;
							var clientTop = el.clientTop || body.clientTop || 0;
							var clientLeft = el.clientLeft || body.clientLeft || 0;
							var scrollTop = el === win ? win.scrollY : el.scrollTop;
							var scrollLeft = el === win ? win.scrollX : el.scrollLeft;
							return {
								top: box.top + scrollTop - clientTop,
								left: box.left + scrollLeft - clientLeft,
							};
						}
						return null;
					}
					function styles() {
						if (this[0]) {
							return win.getComputedStyle(this[0], null);
						}
						return {};
					}
					function css(props, value) {
						var i;
						if (arguments.length === 1) {
							if (typeof props === "string") {
								if (this[0]) {
									return win
										.getComputedStyle(this[0], null)
										.getPropertyValue(props);
								}
							} else {
								for (i = 0; i < this.length; i += 1) {
									for (var prop in props) {
										this[i].style[prop] = props[prop];
									}
								}
								return this;
							}
						}
						if (arguments.length === 2 && typeof props === "string") {
							for (i = 0; i < this.length; i += 1) {
								this[i].style[props] = value;
							}
							return this;
						}
						return this;
					}
					function each(callback) {
						if (!callback) {
							return this;
						}
						for (var i = 0; i < this.length; i += 1) {
							if (callback.call(this[i], i, this[i]) === false) {
								return this;
							}
						}
						return this;
					}
					function html(html) {
						if (typeof html === "undefined") {
							return this[0] ? this[0].innerHTML : undefined;
						}
						for (var i = 0; i < this.length; i += 1) {
							this[i].innerHTML = html;
						}
						return this;
					}
					function text(text) {
						if (typeof text === "undefined") {
							if (this[0]) {
								return this[0].textContent.trim();
							}
							return null;
						}
						for (var i = 0; i < this.length; i += 1) {
							this[i].textContent = text;
						}
						return this;
					}
					function is(selector) {
						var el = this[0];
						var compareWith;
						var i;
						if (!el || typeof selector === "undefined") {
							return false;
						}
						if (typeof selector === "string") {
							if (el.matches) {
								return el.matches(selector);
							} else if (el.webkitMatchesSelector) {
								return el.webkitMatchesSelector(selector);
							} else if (el.msMatchesSelector) {
								return el.msMatchesSelector(selector);
							}
							compareWith = $(selector);
							for (i = 0; i < compareWith.length; i += 1) {
								if (compareWith[i] === el) {
									return true;
								}
							}
							return false;
						} else if (selector === doc) {
							return el === doc;
						} else if (selector === win) {
							return el === win;
						}
						if (selector.nodeType || selector instanceof Dom7) {
							compareWith = selector.nodeType ? [selector] : selector;
							for (i = 0; i < compareWith.length; i += 1) {
								if (compareWith[i] === el) {
									return true;
								}
							}
							return false;
						}
						return false;
					}
					function index() {
						var child = this[0];
						var i;
						if (child) {
							i = 0;
							while ((child = child.previousSibling) !== null) {
								if (child.nodeType === 1) {
									i += 1;
								}
							}
							return i;
						}
						return undefined;
					}
					function eq(index) {
						if (typeof index === "undefined") {
							return this;
						}
						var length = this.length;
						var returnIndex;
						if (index > length - 1) {
							return new Dom7([]);
						}
						if (index < 0) {
							returnIndex = length + index;
							if (returnIndex < 0) {
								return new Dom7([]);
							}
							return new Dom7([this[returnIndex]]);
						}
						return new Dom7([this[index]]);
					}
					function append() {
						var args = [],
							len = arguments.length;
						while (len--) args[len] = arguments[len];
						var newChild;
						for (var k = 0; k < args.length; k += 1) {
							newChild = args[k];
							for (var i = 0; i < this.length; i += 1) {
								if (typeof newChild === "string") {
									var tempDiv = doc.createElement("div");
									tempDiv.innerHTML = newChild;
									while (tempDiv.firstChild) {
										this[i].appendChild(tempDiv.firstChild);
									}
								} else if (newChild instanceof Dom7) {
									for (var j = 0; j < newChild.length; j += 1) {
										this[i].appendChild(newChild[j]);
									}
								} else {
									this[i].appendChild(newChild);
								}
							}
						}
						return this;
					}
					function prepend(newChild) {
						var i;
						var j;
						for (i = 0; i < this.length; i += 1) {
							if (typeof newChild === "string") {
								var tempDiv = doc.createElement("div");
								tempDiv.innerHTML = newChild;
								for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
									this[i].insertBefore(
										tempDiv.childNodes[j],
										this[i].childNodes[0]
									);
								}
							} else if (newChild instanceof Dom7) {
								for (j = 0; j < newChild.length; j += 1) {
									this[i].insertBefore(newChild[j], this[i].childNodes[0]);
								}
							} else {
								this[i].insertBefore(newChild, this[i].childNodes[0]);
							}
						}
						return this;
					}
					function next(selector) {
						if (this.length > 0) {
							if (selector) {
								if (
									this[0].nextElementSibling &&
									$(this[0].nextElementSibling).is(selector)
								) {
									return new Dom7([this[0].nextElementSibling]);
								}
								return new Dom7([]);
							}
							if (this[0].nextElementSibling) {
								return new Dom7([this[0].nextElementSibling]);
							}
							return new Dom7([]);
						}
						return new Dom7([]);
					}
					function nextAll(selector) {
						var nextEls = [];
						var el = this[0];
						if (!el) {
							return new Dom7([]);
						}
						while (el.nextElementSibling) {
							var next = el.nextElementSibling;
							if (selector) {
								if ($(next).is(selector)) {
									nextEls.push(next);
								}
							} else {
								nextEls.push(next);
							}
							el = next;
						}
						return new Dom7(nextEls);
					}
					function prev(selector) {
						if (this.length > 0) {
							var el = this[0];
							if (selector) {
								if (
									el.previousElementSibling &&
									$(el.previousElementSibling).is(selector)
								) {
									return new Dom7([el.previousElementSibling]);
								}
								return new Dom7([]);
							}
							if (el.previousElementSibling) {
								return new Dom7([el.previousElementSibling]);
							}
							return new Dom7([]);
						}
						return new Dom7([]);
					}
					function prevAll(selector) {
						var prevEls = [];
						var el = this[0];
						if (!el) {
							return new Dom7([]);
						}
						while (el.previousElementSibling) {
							var prev = el.previousElementSibling;
							if (selector) {
								if ($(prev).is(selector)) {
									prevEls.push(prev);
								}
							} else {
								prevEls.push(prev);
							}
							el = prev;
						}
						return new Dom7(prevEls);
					}
					function parent(selector) {
						var parents = [];
						for (var i = 0; i < this.length; i += 1) {
							if (this[i].parentNode !== null) {
								if (selector) {
									if ($(this[i].parentNode).is(selector)) {
										parents.push(this[i].parentNode);
									}
								} else {
									parents.push(this[i].parentNode);
								}
							}
						}
						return $(unique(parents));
					}
					function parents(selector) {
						var parents = [];
						for (var i = 0; i < this.length; i += 1) {
							var parent = this[i].parentNode;
							while (parent) {
								if (selector) {
									if ($(parent).is(selector)) {
										parents.push(parent);
									}
								} else {
									parents.push(parent);
								}
								parent = parent.parentNode;
							}
						}
						return $(unique(parents));
					}
					function closest(selector) {
						var closest = this;
						if (typeof selector === "undefined") {
							return new Dom7([]);
						}
						if (!closest.is(selector)) {
							closest = closest.parents(selector).eq(0);
						}
						return closest;
					}
					function find(selector) {
						var foundElements = [];
						for (var i = 0; i < this.length; i += 1) {
							var found = this[i].querySelectorAll(selector);
							for (var j = 0; j < found.length; j += 1) {
								foundElements.push(found[j]);
							}
						}
						return new Dom7(foundElements);
					}
					function children(selector) {
						var children = [];
						for (var i = 0; i < this.length; i += 1) {
							var childNodes = this[i].childNodes;
							for (var j = 0; j < childNodes.length; j += 1) {
								if (!selector) {
									if (childNodes[j].nodeType === 1) {
										children.push(childNodes[j]);
									}
								} else if (
									childNodes[j].nodeType === 1 &&
									$(childNodes[j]).is(selector)
								) {
									children.push(childNodes[j]);
								}
							}
						}
						return new Dom7(unique(children));
					}
					function remove() {
						for (var i = 0; i < this.length; i += 1) {
							if (this[i].parentNode) {
								this[i].parentNode.removeChild(this[i]);
							}
						}
						return this;
					}
					function add() {
						var args = [],
							len = arguments.length;
						while (len--) args[len] = arguments[len];
						var dom = this;
						var i;
						var j;
						for (i = 0; i < args.length; i += 1) {
							var toAdd = $(args[i]);
							for (j = 0; j < toAdd.length; j += 1) {
								dom[dom.length] = toAdd[j];
								dom.length += 1;
							}
						}
						return dom;
					}
					var Methods = {
						addClass: addClass,
						removeClass: removeClass,
						hasClass: hasClass,
						toggleClass: toggleClass,
						attr: attr,
						removeAttr: removeAttr,
						data: data,
						transform: transform,
						transition: transition,
						on: on,
						off: off,
						trigger: trigger,
						transitionEnd: transitionEnd,
						outerWidth: outerWidth,
						outerHeight: outerHeight,
						offset: offset,
						css: css,
						each: each,
						html: html,
						text: text,
						is: is,
						index: index,
						eq: eq,
						append: append,
						prepend: prepend,
						next: next,
						nextAll: nextAll,
						prev: prev,
						prevAll: prevAll,
						parent: parent,
						parents: parents,
						closest: closest,
						find: find,
						children: children,
						remove: remove,
						add: add,
						styles: styles,
					};
					Object.keys(Methods).forEach(function (methodName) {
						$.fn[methodName] = $.fn[methodName] || Methods[methodName];
					});
					var Utils = {
						deleteProps: function deleteProps(obj) {
							var object = obj;
							Object.keys(object).forEach(function (key) {
								try {
									object[key] = null;
								} catch (e) {}
								try {
									delete object[key];
								} catch (e) {}
							});
						},
						nextTick: function nextTick(callback, delay) {
							if (delay === void 0) delay = 0;
							return setTimeout(callback, delay);
						},
						now: function now() {
							return Date.now();
						},
						getTranslate: function getTranslate(el, axis) {
							if (axis === void 0) axis = "x";
							var matrix;
							var curTransform;
							var transformMatrix;
							var curStyle = win.getComputedStyle(el, null);
							if (win.WebKitCSSMatrix) {
								curTransform = curStyle.transform || curStyle.webkitTransform;
								if (curTransform.split(",").length > 6) {
									curTransform = curTransform
										.split(", ")
										.map(function (a) {
											return a.replace(",", ".");
										})
										.join(", ");
								}
								transformMatrix = new win.WebKitCSSMatrix(
									curTransform === "none" ? "" : curTransform
								);
							} else {
								transformMatrix =
									curStyle.MozTransform ||
									curStyle.OTransform ||
									curStyle.MsTransform ||
									curStyle.msTransform ||
									curStyle.transform ||
									curStyle
										.getPropertyValue("transform")
										.replace("translate(", "matrix(1, 0, 0, 1,");
								matrix = transformMatrix.toString().split(",");
							}
							if (axis === "x") {
								if (win.WebKitCSSMatrix) {
									curTransform = transformMatrix.m41;
								} else if (matrix.length === 16) {
									curTransform = parseFloat(matrix[12]);
								} else {
									curTransform = parseFloat(matrix[4]);
								}
							}
							if (axis === "y") {
								if (win.WebKitCSSMatrix) {
									curTransform = transformMatrix.m42;
								} else if (matrix.length === 16) {
									curTransform = parseFloat(matrix[13]);
								} else {
									curTransform = parseFloat(matrix[5]);
								}
							}
							return curTransform || 0;
						},
						parseUrlQuery: function parseUrlQuery(url) {
							var query = {};
							var urlToParse = url || win.location.href;
							var i;
							var params;
							var param;
							var length;
							if (typeof urlToParse === "string" && urlToParse.length) {
								urlToParse =
									urlToParse.indexOf("?") > -1
										? urlToParse.replace(/\S*\?/, "")
										: "";
								params = urlToParse.split("&").filter(function (paramsPart) {
									return paramsPart !== "";
								});
								length = params.length;
								for (i = 0; i < length; i += 1) {
									param = params[i].replace(/#\S+/g, "").split("=");
									query[decodeURIComponent(param[0])] =
										typeof param[1] === "undefined"
											? undefined
											: decodeURIComponent(param[1]) || "";
								}
							}
							return query;
						},
						isObject: function isObject(o) {
							return (
								typeof o === "object" &&
								o !== null &&
								o.constructor &&
								o.constructor === Object
							);
						},
						extend: function extend() {
							var args = [],
								len$1 = arguments.length;
							while (len$1--) args[len$1] = arguments[len$1];
							var to = Object(args[0]);
							for (var i = 1; i < args.length; i += 1) {
								var nextSource = args[i];
								if (nextSource !== undefined && nextSource !== null) {
									var keysArray = Object.keys(Object(nextSource));
									for (
										var nextIndex = 0, len = keysArray.length;
										nextIndex < len;
										nextIndex += 1
									) {
										var nextKey = keysArray[nextIndex];
										var desc = Object.getOwnPropertyDescriptor(
											nextSource,
											nextKey
										);
										if (desc !== undefined && desc.enumerable) {
											if (
												Utils.isObject(to[nextKey]) &&
												Utils.isObject(nextSource[nextKey])
											) {
												Utils.extend(to[nextKey], nextSource[nextKey]);
											} else if (
												!Utils.isObject(to[nextKey]) &&
												Utils.isObject(nextSource[nextKey])
											) {
												to[nextKey] = {};
												Utils.extend(to[nextKey], nextSource[nextKey]);
											} else {
												to[nextKey] = nextSource[nextKey];
											}
										}
									}
								}
							}
							return to;
						},
					};
					var Support = (function Support() {
						var testDiv = doc.createElement("div");
						return {
							touch:
								(win.Modernizr && win.Modernizr.touch === true) ||
								(function checkTouch() {
									return !!(
										win.navigator.maxTouchPoints > 0 ||
										"ontouchstart" in win ||
										(win.DocumentTouch && doc instanceof win.DocumentTouch)
									);
								})(),
							pointerEvents: !!(
								win.navigator.pointerEnabled ||
								win.PointerEvent ||
								("maxTouchPoints" in win.navigator &&
									win.navigator.maxTouchPoints > 0)
							),
							prefixedPointerEvents: !!win.navigator.msPointerEnabled,
							transition: (function checkTransition() {
								var style = testDiv.style;
								return (
									"transition" in style ||
									"webkitTransition" in style ||
									"MozTransition" in style
								);
							})(),
							transforms3d:
								(win.Modernizr && win.Modernizr.csstransforms3d === true) ||
								(function checkTransforms3d() {
									var style = testDiv.style;
									return (
										"webkitPerspective" in style ||
										"MozPerspective" in style ||
										"OPerspective" in style ||
										"MsPerspective" in style ||
										"perspective" in style
									);
								})(),
							flexbox: (function checkFlexbox() {
								var style = testDiv.style;
								var styles =
									"alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient".split(
										" "
									);
								for (var i = 0; i < styles.length; i += 1) {
									if (styles[i] in style) {
										return true;
									}
								}
								return false;
							})(),
							observer: (function checkObserver() {
								return (
									"MutationObserver" in win || "WebkitMutationObserver" in win
								);
							})(),
							passiveListener: (function checkPassiveListener() {
								var supportsPassive = false;
								try {
									var opts = Object.defineProperty({}, "passive", {
										get: function get() {
											supportsPassive = true;
										},
									});
									win.addEventListener("testPassiveListener", null, opts);
								} catch (e) {}
								return supportsPassive;
							})(),
							gestures: (function checkGestures() {
								return "ongesturestart" in win;
							})(),
						};
					})();
					var Browser = (function Browser() {
						function isSafari() {
							var ua = win.navigator.userAgent.toLowerCase();
							return (
								ua.indexOf("safari") >= 0 &&
								ua.indexOf("chrome") < 0 &&
								ua.indexOf("android") < 0
							);
						}
						return {
							isIE:
								!!win.navigator.userAgent.match(/Trident/g) ||
								!!win.navigator.userAgent.match(/MSIE/g),
							isEdge: !!win.navigator.userAgent.match(/Edge/g),
							isSafari: isSafari(),
							isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
								win.navigator.userAgent
							),
						};
					})();
					var SwiperClass = function SwiperClass(params) {
						if (params === void 0) params = {};
						var self = this;
						self.params = params;
						self.eventsListeners = {};
						if (self.params && self.params.on) {
							Object.keys(self.params.on).forEach(function (eventName) {
								self.on(eventName, self.params.on[eventName]);
							});
						}
					};
					var staticAccessors = { components: { configurable: true } };
					SwiperClass.prototype.on = function on(events, handler, priority) {
						var self = this;
						if (typeof handler !== "function") {
							return self;
						}
						var method = priority ? "unshift" : "push";
						events.split(" ").forEach(function (event) {
							if (!self.eventsListeners[event]) {
								self.eventsListeners[event] = [];
							}
							self.eventsListeners[event][method](handler);
						});
						return self;
					};
					SwiperClass.prototype.once = function once(
						events,
						handler,
						priority
					) {
						var self = this;
						if (typeof handler !== "function") {
							return self;
						}
						function onceHandler() {
							var args = [],
								len = arguments.length;
							while (len--) args[len] = arguments[len];
							handler.apply(self, args);
							self.off(events, onceHandler);
							if (onceHandler.f7proxy) {
								delete onceHandler.f7proxy;
							}
						}
						onceHandler.f7proxy = handler;
						return self.on(events, onceHandler, priority);
					};
					SwiperClass.prototype.off = function off(events, handler) {
						var self = this;
						if (!self.eventsListeners) {
							return self;
						}
						events.split(" ").forEach(function (event) {
							if (typeof handler === "undefined") {
								self.eventsListeners[event] = [];
							} else if (
								self.eventsListeners[event] &&
								self.eventsListeners[event].length
							) {
								self.eventsListeners[event].forEach(function (
									eventHandler,
									index
								) {
									if (
										eventHandler === handler ||
										(eventHandler.f7proxy && eventHandler.f7proxy === handler)
									) {
										self.eventsListeners[event].splice(index, 1);
									}
								});
							}
						});
						return self;
					};
					SwiperClass.prototype.emit = function emit() {
						var args = [],
							len = arguments.length;
						while (len--) args[len] = arguments[len];
						var self = this;
						if (!self.eventsListeners) {
							return self;
						}
						var events;
						var data;
						var context;
						if (typeof args[0] === "string" || Array.isArray(args[0])) {
							events = args[0];
							data = args.slice(1, args.length);
							context = self;
						} else {
							events = args[0].events;
							data = args[0].data;
							context = args[0].context || self;
						}
						var eventsArray = Array.isArray(events)
							? events
							: events.split(" ");
						eventsArray.forEach(function (event) {
							if (self.eventsListeners && self.eventsListeners[event]) {
								var handlers = [];
								self.eventsListeners[event].forEach(function (eventHandler) {
									handlers.push(eventHandler);
								});
								handlers.forEach(function (eventHandler) {
									eventHandler.apply(context, data);
								});
							}
						});
						return self;
					};
					SwiperClass.prototype.useModulesParams = function useModulesParams(
						instanceParams
					) {
						var instance = this;
						if (!instance.modules) {
							return;
						}
						Object.keys(instance.modules).forEach(function (moduleName) {
							var module = instance.modules[moduleName];
							if (module.params) {
								Utils.extend(instanceParams, module.params);
							}
						});
					};
					SwiperClass.prototype.useModules = function useModules(
						modulesParams
					) {
						if (modulesParams === void 0) modulesParams = {};
						var instance = this;
						if (!instance.modules) {
							return;
						}
						Object.keys(instance.modules).forEach(function (moduleName) {
							var module = instance.modules[moduleName];
							var moduleParams = modulesParams[moduleName] || {};
							if (module.instance) {
								Object.keys(module.instance).forEach(function (modulePropName) {
									var moduleProp = module.instance[modulePropName];
									if (typeof moduleProp === "function") {
										instance[modulePropName] = moduleProp.bind(instance);
									} else {
										instance[modulePropName] = moduleProp;
									}
								});
							}
							if (module.on && instance.on) {
								Object.keys(module.on).forEach(function (moduleEventName) {
									instance.on(moduleEventName, module.on[moduleEventName]);
								});
							}
							if (module.create) {
								module.create.bind(instance)(moduleParams);
							}
						});
					};
					staticAccessors.components.set = function (components) {
						var Class = this;
						if (!Class.use) {
							return;
						}
						Class.use(components);
					};
					SwiperClass.installModule = function installModule(module) {
						var params = [],
							len = arguments.length - 1;
						while (len-- > 0) params[len] = arguments[len + 1];
						var Class = this;
						if (!Class.prototype.modules) {
							Class.prototype.modules = {};
						}
						var name =
							module.name ||
							Object.keys(Class.prototype.modules).length + "_" + Utils.now();
						Class.prototype.modules[name] = module;
						if (module.proto) {
							Object.keys(module.proto).forEach(function (key) {
								Class.prototype[key] = module.proto[key];
							});
						}
						if (module.static) {
							Object.keys(module.static).forEach(function (key) {
								Class[key] = module.static[key];
							});
						}
						if (module.install) {
							module.install.apply(Class, params);
						}
						return Class;
					};
					SwiperClass.use = function use(module) {
						var params = [],
							len = arguments.length - 1;
						while (len-- > 0) params[len] = arguments[len + 1];
						var Class = this;
						if (Array.isArray(module)) {
							module.forEach(function (m) {
								return Class.installModule(m);
							});
							return Class;
						}
						return Class.installModule.apply(Class, [module].concat(params));
					};
					Object.defineProperties(SwiperClass, staticAccessors);
					function updateSize() {
						var swiper = this;
						var width;
						var height;
						var $el = swiper.$el;
						if (typeof swiper.params.width !== "undefined") {
							width = swiper.params.width;
						} else {
							width = $el[0].clientWidth;
						}
						if (typeof swiper.params.height !== "undefined") {
							height = swiper.params.height;
						} else {
							height = $el[0].clientHeight;
						}
						if (
							(width === 0 && swiper.isHorizontal()) ||
							(height === 0 && swiper.isVertical())
						) {
							return;
						}
						width =
							width -
							parseInt($el.css("padding-left"), 10) -
							parseInt($el.css("padding-right"), 10);
						height =
							height -
							parseInt($el.css("padding-top"), 10) -
							parseInt($el.css("padding-bottom"), 10);
						Utils.extend(swiper, {
							width: width,
							height: height,
							size: swiper.isHorizontal() ? width : height,
						});
					}
					function updateSlides() {
						var swiper = this;
						var params = swiper.params;
						var $wrapperEl = swiper.$wrapperEl;
						var swiperSize = swiper.size;
						var rtl = swiper.rtlTranslate;
						var wrongRTL = swiper.wrongRTL;
						var isVirtual = swiper.virtual && params.virtual.enabled;
						var previousSlidesLength = isVirtual
							? swiper.virtual.slides.length
							: swiper.slides.length;
						var slides = $wrapperEl.children("." + swiper.params.slideClass);
						var slidesLength = isVirtual
							? swiper.virtual.slides.length
							: slides.length;
						var snapGrid = [];
						var slidesGrid = [];
						var slidesSizesGrid = [];
						var offsetBefore = params.slidesOffsetBefore;
						if (typeof offsetBefore === "function") {
							offsetBefore = params.slidesOffsetBefore.call(swiper);
						}
						var offsetAfter = params.slidesOffsetAfter;
						if (typeof offsetAfter === "function") {
							offsetAfter = params.slidesOffsetAfter.call(swiper);
						}
						var previousSnapGridLength = swiper.snapGrid.length;
						var previousSlidesGridLength = swiper.snapGrid.length;
						var spaceBetween = params.spaceBetween;
						var slidePosition = -offsetBefore;
						var prevSlideSize = 0;
						var index = 0;
						if (typeof swiperSize === "undefined") {
							return;
						}
						if (
							typeof spaceBetween === "string" &&
							spaceBetween.indexOf("%") >= 0
						) {
							spaceBetween =
								(parseFloat(spaceBetween.replace("%", "")) / 100) * swiperSize;
						}
						swiper.virtualSize = -spaceBetween;
						if (rtl) {
							slides.css({ marginLeft: "", marginTop: "" });
						} else {
							slides.css({ marginRight: "", marginBottom: "" });
						}
						var slidesNumberEvenToRows;
						if (params.slidesPerColumn > 1) {
							if (
								Math.floor(slidesLength / params.slidesPerColumn) ===
								slidesLength / swiper.params.slidesPerColumn
							) {
								slidesNumberEvenToRows = slidesLength;
							} else {
								slidesNumberEvenToRows =
									Math.ceil(slidesLength / params.slidesPerColumn) *
									params.slidesPerColumn;
							}
							if (
								params.slidesPerView !== "auto" &&
								params.slidesPerColumnFill === "row"
							) {
								slidesNumberEvenToRows = Math.max(
									slidesNumberEvenToRows,
									params.slidesPerView * params.slidesPerColumn
								);
							}
						}
						var slideSize;
						var slidesPerColumn = params.slidesPerColumn;
						var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
						var numFullColumns = Math.floor(
							slidesLength / params.slidesPerColumn
						);
						for (var i = 0; i < slidesLength; i += 1) {
							slideSize = 0;
							var slide = slides.eq(i);
							if (params.slidesPerColumn > 1) {
								var newSlideOrderIndex = void 0;
								var column = void 0;
								var row = void 0;
								if (
									params.slidesPerColumnFill === "column" ||
									(params.slidesPerColumnFill === "row" &&
										params.slidesPerGroup > 1)
								) {
									if (params.slidesPerColumnFill === "column") {
										column = Math.floor(i / slidesPerColumn);
										row = i - column * slidesPerColumn;
										if (
											column > numFullColumns ||
											(column === numFullColumns && row === slidesPerColumn - 1)
										) {
											row += 1;
											if (row >= slidesPerColumn) {
												row = 0;
												column += 1;
											}
										}
									} else {
										var groupIndex = Math.floor(i / params.slidesPerGroup);
										row =
											Math.floor(i / params.slidesPerView) -
											groupIndex * params.slidesPerColumn;
										column =
											i -
											row * params.slidesPerView -
											groupIndex * params.slidesPerView;
									}
									newSlideOrderIndex =
										column + (row * slidesNumberEvenToRows) / slidesPerColumn;
									slide.css({
										"-webkit-box-ordinal-group": newSlideOrderIndex,
										"-moz-box-ordinal-group": newSlideOrderIndex,
										"-ms-flex-order": newSlideOrderIndex,
										"-webkit-order": newSlideOrderIndex,
										order: newSlideOrderIndex,
									});
								} else {
									row = Math.floor(i / slidesPerRow);
									column = i - row * slidesPerRow;
								}
								slide
									.css(
										"margin-" + (swiper.isHorizontal() ? "top" : "left"),
										row !== 0 &&
											params.spaceBetween &&
											params.spaceBetween + "px"
									)
									.attr("data-swiper-column", column)
									.attr("data-swiper-row", row);
							}
							if (slide.css("display") === "none") {
								continue;
							}
							if (params.slidesPerView === "auto") {
								var slideStyles = win.getComputedStyle(slide[0], null);
								var currentTransform = slide[0].style.transform;
								var currentWebKitTransform = slide[0].style.webkitTransform;
								if (currentTransform) {
									slide[0].style.transform = "none";
								}
								if (currentWebKitTransform) {
									slide[0].style.webkitTransform = "none";
								}
								if (params.roundLengths) {
									slideSize = swiper.isHorizontal()
										? slide.outerWidth(true)
										: slide.outerHeight(true);
								} else {
									if (swiper.isHorizontal()) {
										var width = parseFloat(
											slideStyles.getPropertyValue("width")
										);
										var paddingLeft = parseFloat(
											slideStyles.getPropertyValue("padding-left")
										);
										var paddingRight = parseFloat(
											slideStyles.getPropertyValue("padding-right")
										);
										var marginLeft = parseFloat(
											slideStyles.getPropertyValue("margin-left")
										);
										var marginRight = parseFloat(
											slideStyles.getPropertyValue("margin-right")
										);
										var boxSizing = slideStyles.getPropertyValue("box-sizing");
										if (
											boxSizing &&
											boxSizing === "border-box" &&
											!Browser.isIE
										) {
											slideSize = width + marginLeft + marginRight;
										} else {
											slideSize =
												width +
												paddingLeft +
												paddingRight +
												marginLeft +
												marginRight;
										}
									} else {
										var height = parseFloat(
											slideStyles.getPropertyValue("height")
										);
										var paddingTop = parseFloat(
											slideStyles.getPropertyValue("padding-top")
										);
										var paddingBottom = parseFloat(
											slideStyles.getPropertyValue("padding-bottom")
										);
										var marginTop = parseFloat(
											slideStyles.getPropertyValue("margin-top")
										);
										var marginBottom = parseFloat(
											slideStyles.getPropertyValue("margin-bottom")
										);
										var boxSizing$1 =
											slideStyles.getPropertyValue("box-sizing");
										if (
											boxSizing$1 &&
											boxSizing$1 === "border-box" &&
											!Browser.isIE
										) {
											slideSize = height + marginTop + marginBottom;
										} else {
											slideSize =
												height +
												paddingTop +
												paddingBottom +
												marginTop +
												marginBottom;
										}
									}
								}
								if (currentTransform) {
									slide[0].style.transform = currentTransform;
								}
								if (currentWebKitTransform) {
									slide[0].style.webkitTransform = currentWebKitTransform;
								}
								if (params.roundLengths) {
									slideSize = Math.floor(slideSize);
								}
							} else {
								slideSize =
									(swiperSize - (params.slidesPerView - 1) * spaceBetween) /
									params.slidesPerView;
								if (params.roundLengths) {
									slideSize = Math.floor(slideSize);
								}
								if (slides[i]) {
									if (swiper.isHorizontal()) {
										slides[i].style.width = slideSize + "px";
									} else {
										slides[i].style.height = slideSize + "px";
									}
								}
							}
							if (slides[i]) {
								slides[i].swiperSlideSize = slideSize;
							}
							slidesSizesGrid.push(slideSize);
							if (params.centeredSlides) {
								slidePosition =
									slidePosition +
									slideSize / 2 +
									prevSlideSize / 2 +
									spaceBetween;
								if (prevSlideSize === 0 && i !== 0) {
									slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
								}
								if (i === 0) {
									slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
								}
								if (Math.abs(slidePosition) < 1 / 1e3) {
									slidePosition = 0;
								}
								if (params.roundLengths) {
									slidePosition = Math.floor(slidePosition);
								}
								if (index % params.slidesPerGroup === 0) {
									snapGrid.push(slidePosition);
								}
								slidesGrid.push(slidePosition);
							} else {
								if (params.roundLengths) {
									slidePosition = Math.floor(slidePosition);
								}
								if (index % params.slidesPerGroup === 0) {
									snapGrid.push(slidePosition);
								}
								slidesGrid.push(slidePosition);
								slidePosition = slidePosition + slideSize + spaceBetween;
							}
							swiper.virtualSize += slideSize + spaceBetween;
							prevSlideSize = slideSize;
							index += 1;
						}
						swiper.virtualSize =
							Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
						var newSlidesGrid;
						if (
							rtl &&
							wrongRTL &&
							(params.effect === "slide" || params.effect === "coverflow")
						) {
							$wrapperEl.css({
								width: swiper.virtualSize + params.spaceBetween + "px",
							});
						}
						if (!Support.flexbox || params.setWrapperSize) {
							if (swiper.isHorizontal()) {
								$wrapperEl.css({
									width: swiper.virtualSize + params.spaceBetween + "px",
								});
							} else {
								$wrapperEl.css({
									height: swiper.virtualSize + params.spaceBetween + "px",
								});
							}
						}
						if (params.slidesPerColumn > 1) {
							swiper.virtualSize =
								(slideSize + params.spaceBetween) * slidesNumberEvenToRows;
							swiper.virtualSize =
								Math.ceil(swiper.virtualSize / params.slidesPerColumn) -
								params.spaceBetween;
							if (swiper.isHorizontal()) {
								$wrapperEl.css({
									width: swiper.virtualSize + params.spaceBetween + "px",
								});
							} else {
								$wrapperEl.css({
									height: swiper.virtualSize + params.spaceBetween + "px",
								});
							}
							if (params.centeredSlides) {
								newSlidesGrid = [];
								for (var i$1 = 0; i$1 < snapGrid.length; i$1 += 1) {
									var slidesGridItem = snapGrid[i$1];
									if (params.roundLengths) {
										slidesGridItem = Math.floor(slidesGridItem);
									}
									if (snapGrid[i$1] < swiper.virtualSize + snapGrid[0]) {
										newSlidesGrid.push(slidesGridItem);
									}
								}
								snapGrid = newSlidesGrid;
							}
						}
						if (!params.centeredSlides) {
							newSlidesGrid = [];
							for (var i$2 = 0; i$2 < snapGrid.length; i$2 += 1) {
								var slidesGridItem$1 = snapGrid[i$2];
								if (params.roundLengths) {
									slidesGridItem$1 = Math.floor(slidesGridItem$1);
								}
								if (snapGrid[i$2] <= swiper.virtualSize - swiperSize) {
									newSlidesGrid.push(slidesGridItem$1);
								}
							}
							snapGrid = newSlidesGrid;
							if (
								Math.floor(swiper.virtualSize - swiperSize) -
									Math.floor(snapGrid[snapGrid.length - 1]) >
								1
							) {
								snapGrid.push(swiper.virtualSize - swiperSize);
							}
						}
						if (snapGrid.length === 0) {
							snapGrid = [0];
						}
						if (params.spaceBetween !== 0) {
							if (swiper.isHorizontal()) {
								if (rtl) {
									slides.css({ marginLeft: spaceBetween + "px" });
								} else {
									slides.css({ marginRight: spaceBetween + "px" });
								}
							} else {
								slides.css({ marginBottom: spaceBetween + "px" });
							}
						}
						if (params.centerInsufficientSlides) {
							var allSlidesSize = 0;
							slidesSizesGrid.forEach(function (slideSizeValue) {
								allSlidesSize +=
									slideSizeValue +
									(params.spaceBetween ? params.spaceBetween : 0);
							});
							allSlidesSize -= params.spaceBetween;
							if (allSlidesSize < swiperSize) {
								var allSlidesOffset = (swiperSize - allSlidesSize) / 2;
								snapGrid.forEach(function (snap, snapIndex) {
									snapGrid[snapIndex] = snap - allSlidesOffset;
								});
								slidesGrid.forEach(function (snap, snapIndex) {
									slidesGrid[snapIndex] = snap + allSlidesOffset;
								});
							}
						}
						Utils.extend(swiper, {
							slides: slides,
							snapGrid: snapGrid,
							slidesGrid: slidesGrid,
							slidesSizesGrid: slidesSizesGrid,
						});
						if (slidesLength !== previousSlidesLength) {
							swiper.emit("slidesLengthChange");
						}
						if (snapGrid.length !== previousSnapGridLength) {
							if (swiper.params.watchOverflow) {
								swiper.checkOverflow();
							}
							swiper.emit("snapGridLengthChange");
						}
						if (slidesGrid.length !== previousSlidesGridLength) {
							swiper.emit("slidesGridLengthChange");
						}
						if (params.watchSlidesProgress || params.watchSlidesVisibility) {
							swiper.updateSlidesOffset();
						}
					}
					function updateAutoHeight(speed) {
						var swiper = this;
						var activeSlides = [];
						var newHeight = 0;
						var i;
						if (typeof speed === "number") {
							swiper.setTransition(speed);
						} else if (speed === true) {
							swiper.setTransition(swiper.params.speed);
						}
						if (
							swiper.params.slidesPerView !== "auto" &&
							swiper.params.slidesPerView > 1
						) {
							for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
								var index = swiper.activeIndex + i;
								if (index > swiper.slides.length) {
									break;
								}
								activeSlides.push(swiper.slides.eq(index)[0]);
							}
						} else {
							activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
						}
						for (i = 0; i < activeSlides.length; i += 1) {
							if (typeof activeSlides[i] !== "undefined") {
								var height = activeSlides[i].offsetHeight;
								newHeight = height > newHeight ? height : newHeight;
							}
						}
						if (newHeight) {
							swiper.$wrapperEl.css("height", newHeight + "px");
						}
					}
					function updateSlidesOffset() {
						var swiper = this;
						var slides = swiper.slides;
						for (var i = 0; i < slides.length; i += 1) {
							slides[i].swiperSlideOffset = swiper.isHorizontal()
								? slides[i].offsetLeft
								: slides[i].offsetTop;
						}
					}
					function updateSlidesProgress(translate) {
						if (translate === void 0) translate = (this && this.translate) || 0;
						var swiper = this;
						var params = swiper.params;
						var slides = swiper.slides;
						var rtl = swiper.rtlTranslate;
						if (slides.length === 0) {
							return;
						}
						if (typeof slides[0].swiperSlideOffset === "undefined") {
							swiper.updateSlidesOffset();
						}
						var offsetCenter = -translate;
						if (rtl) {
							offsetCenter = translate;
						}
						slides.removeClass(params.slideVisibleClass);
						swiper.visibleSlidesIndexes = [];
						swiper.visibleSlides = [];
						for (var i = 0; i < slides.length; i += 1) {
							var slide = slides[i];
							var slideProgress =
								(offsetCenter +
									(params.centeredSlides ? swiper.minTranslate() : 0) -
									slide.swiperSlideOffset) /
								(slide.swiperSlideSize + params.spaceBetween);
							if (params.watchSlidesVisibility) {
								var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
								var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
								var isVisible =
									(slideBefore >= 0 && slideBefore < swiper.size - 1) ||
									(slideAfter > 1 && slideAfter <= swiper.size) ||
									(slideBefore <= 0 && slideAfter >= swiper.size);
								if (isVisible) {
									swiper.visibleSlides.push(slide);
									swiper.visibleSlidesIndexes.push(i);
									slides.eq(i).addClass(params.slideVisibleClass);
								}
							}
							slide.progress = rtl ? -slideProgress : slideProgress;
						}
						swiper.visibleSlides = $(swiper.visibleSlides);
					}
					function updateProgress(translate) {
						if (translate === void 0) translate = (this && this.translate) || 0;
						var swiper = this;
						var params = swiper.params;
						var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
						var progress = swiper.progress;
						var isBeginning = swiper.isBeginning;
						var isEnd = swiper.isEnd;
						var wasBeginning = isBeginning;
						var wasEnd = isEnd;
						if (translatesDiff === 0) {
							progress = 0;
							isBeginning = true;
							isEnd = true;
						} else {
							progress = (translate - swiper.minTranslate()) / translatesDiff;
							isBeginning = progress <= 0;
							isEnd = progress >= 1;
						}
						Utils.extend(swiper, {
							progress: progress,
							isBeginning: isBeginning,
							isEnd: isEnd,
						});
						if (params.watchSlidesProgress || params.watchSlidesVisibility) {
							swiper.updateSlidesProgress(translate);
						}
						if (isBeginning && !wasBeginning) {
							swiper.emit("reachBeginning toEdge");
						}
						if (isEnd && !wasEnd) {
							swiper.emit("reachEnd toEdge");
						}
						if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
							swiper.emit("fromEdge");
						}
						swiper.emit("progress", progress);
					}
					function updateSlidesClasses() {
						var swiper = this;
						var slides = swiper.slides;
						var params = swiper.params;
						var $wrapperEl = swiper.$wrapperEl;
						var activeIndex = swiper.activeIndex;
						var realIndex = swiper.realIndex;
						var isVirtual = swiper.virtual && params.virtual.enabled;
						slides.removeClass(
							params.slideActiveClass +
								" " +
								params.slideNextClass +
								" " +
								params.slidePrevClass +
								" " +
								params.slideDuplicateActiveClass +
								" " +
								params.slideDuplicateNextClass +
								" " +
								params.slideDuplicatePrevClass
						);
						var activeSlide;
						if (isVirtual) {
							activeSlide = swiper.$wrapperEl.find(
								"." +
									params.slideClass +
									'[data-swiper-slide-index="' +
									activeIndex +
									'"]'
							);
						} else {
							activeSlide = slides.eq(activeIndex);
						}
						activeSlide.addClass(params.slideActiveClass);
						if (params.loop) {
							if (activeSlide.hasClass(params.slideDuplicateClass)) {
								$wrapperEl
									.children(
										"." +
											params.slideClass +
											":not(." +
											params.slideDuplicateClass +
											')[data-swiper-slide-index="' +
											realIndex +
											'"]'
									)
									.addClass(params.slideDuplicateActiveClass);
							} else {
								$wrapperEl
									.children(
										"." +
											params.slideClass +
											"." +
											params.slideDuplicateClass +
											'[data-swiper-slide-index="' +
											realIndex +
											'"]'
									)
									.addClass(params.slideDuplicateActiveClass);
							}
						}
						var nextSlide = activeSlide
							.nextAll("." + params.slideClass)
							.eq(0)
							.addClass(params.slideNextClass);
						if (params.loop && nextSlide.length === 0) {
							nextSlide = slides.eq(0);
							nextSlide.addClass(params.slideNextClass);
						}
						var prevSlide = activeSlide
							.prevAll("." + params.slideClass)
							.eq(0)
							.addClass(params.slidePrevClass);
						if (params.loop && prevSlide.length === 0) {
							prevSlide = slides.eq(-1);
							prevSlide.addClass(params.slidePrevClass);
						}
						if (params.loop) {
							if (nextSlide.hasClass(params.slideDuplicateClass)) {
								$wrapperEl
									.children(
										"." +
											params.slideClass +
											":not(." +
											params.slideDuplicateClass +
											')[data-swiper-slide-index="' +
											nextSlide.attr("data-swiper-slide-index") +
											'"]'
									)
									.addClass(params.slideDuplicateNextClass);
							} else {
								$wrapperEl
									.children(
										"." +
											params.slideClass +
											"." +
											params.slideDuplicateClass +
											'[data-swiper-slide-index="' +
											nextSlide.attr("data-swiper-slide-index") +
											'"]'
									)
									.addClass(params.slideDuplicateNextClass);
							}
							if (prevSlide.hasClass(params.slideDuplicateClass)) {
								$wrapperEl
									.children(
										"." +
											params.slideClass +
											":not(." +
											params.slideDuplicateClass +
											')[data-swiper-slide-index="' +
											prevSlide.attr("data-swiper-slide-index") +
											'"]'
									)
									.addClass(params.slideDuplicatePrevClass);
							} else {
								$wrapperEl
									.children(
										"." +
											params.slideClass +
											"." +
											params.slideDuplicateClass +
											'[data-swiper-slide-index="' +
											prevSlide.attr("data-swiper-slide-index") +
											'"]'
									)
									.addClass(params.slideDuplicatePrevClass);
							}
						}
					}
					function updateActiveIndex(newActiveIndex) {
						var swiper = this;
						var translate = swiper.rtlTranslate
							? swiper.translate
							: -swiper.translate;
						var slidesGrid = swiper.slidesGrid;
						var snapGrid = swiper.snapGrid;
						var params = swiper.params;
						var previousIndex = swiper.activeIndex;
						var previousRealIndex = swiper.realIndex;
						var previousSnapIndex = swiper.snapIndex;
						var activeIndex = newActiveIndex;
						var snapIndex;
						if (typeof activeIndex === "undefined") {
							for (var i = 0; i < slidesGrid.length; i += 1) {
								if (typeof slidesGrid[i + 1] !== "undefined") {
									if (
										translate >= slidesGrid[i] &&
										translate <
											slidesGrid[i + 1] -
												(slidesGrid[i + 1] - slidesGrid[i]) / 2
									) {
										activeIndex = i;
									} else if (
										translate >= slidesGrid[i] &&
										translate < slidesGrid[i + 1]
									) {
										activeIndex = i + 1;
									}
								} else if (translate >= slidesGrid[i]) {
									activeIndex = i;
								}
							}
							if (params.normalizeSlideIndex) {
								if (activeIndex < 0 || typeof activeIndex === "undefined") {
									activeIndex = 0;
								}
							}
						}
						if (snapGrid.indexOf(translate) >= 0) {
							snapIndex = snapGrid.indexOf(translate);
						} else {
							snapIndex = Math.floor(activeIndex / params.slidesPerGroup);
						}
						if (snapIndex >= snapGrid.length) {
							snapIndex = snapGrid.length - 1;
						}
						if (activeIndex === previousIndex) {
							if (snapIndex !== previousSnapIndex) {
								swiper.snapIndex = snapIndex;
								swiper.emit("snapIndexChange");
							}
							return;
						}
						var realIndex = parseInt(
							swiper.slides.eq(activeIndex).attr("data-swiper-slide-index") ||
								activeIndex,
							10
						);
						Utils.extend(swiper, {
							snapIndex: snapIndex,
							realIndex: realIndex,
							previousIndex: previousIndex,
							activeIndex: activeIndex,
						});
						swiper.emit("activeIndexChange");
						swiper.emit("snapIndexChange");
						if (previousRealIndex !== realIndex) {
							swiper.emit("realIndexChange");
						}
						if (swiper.initialized || swiper.runCallbacksOnInit) {
							swiper.emit("slideChange");
						}
					}
					function updateClickedSlide(e) {
						var swiper = this;
						var params = swiper.params;
						var slide = $(e.target).closest("." + params.slideClass)[0];
						var slideFound = false;
						if (slide) {
							for (var i = 0; i < swiper.slides.length; i += 1) {
								if (swiper.slides[i] === slide) {
									slideFound = true;
								}
							}
						}
						if (slide && slideFound) {
							swiper.clickedSlide = slide;
							if (swiper.virtual && swiper.params.virtual.enabled) {
								swiper.clickedIndex = parseInt(
									$(slide).attr("data-swiper-slide-index"),
									10
								);
							} else {
								swiper.clickedIndex = $(slide).index();
							}
						} else {
							swiper.clickedSlide = undefined;
							swiper.clickedIndex = undefined;
							return;
						}
						if (
							params.slideToClickedSlide &&
							swiper.clickedIndex !== undefined &&
							swiper.clickedIndex !== swiper.activeIndex
						) {
							swiper.slideToClickedSlide();
						}
					}
					var update = {
						updateSize: updateSize,
						updateSlides: updateSlides,
						updateAutoHeight: updateAutoHeight,
						updateSlidesOffset: updateSlidesOffset,
						updateSlidesProgress: updateSlidesProgress,
						updateProgress: updateProgress,
						updateSlidesClasses: updateSlidesClasses,
						updateActiveIndex: updateActiveIndex,
						updateClickedSlide: updateClickedSlide,
					};
					function getTranslate(axis) {
						if (axis === void 0) axis = this.isHorizontal() ? "x" : "y";
						var swiper = this;
						var params = swiper.params;
						var rtl = swiper.rtlTranslate;
						var translate = swiper.translate;
						var $wrapperEl = swiper.$wrapperEl;
						if (params.virtualTranslate) {
							return rtl ? -translate : translate;
						}
						var currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
						if (rtl) {
							currentTranslate = -currentTranslate;
						}
						return currentTranslate || 0;
					}
					function setTranslate(translate, byController) {
						var swiper = this;
						var rtl = swiper.rtlTranslate;
						var params = swiper.params;
						var $wrapperEl = swiper.$wrapperEl;
						var progress = swiper.progress;
						var x = 0;
						var y = 0;
						var z = 0;
						if (swiper.isHorizontal()) {
							x = rtl ? -translate : translate;
						} else {
							y = translate;
						}
						if (params.roundLengths) {
							x = Math.floor(x);
							y = Math.floor(y);
						}
						if (!params.virtualTranslate) {
							if (Support.transforms3d) {
								$wrapperEl.transform(
									"translate3d(" + x + "px, " + y + "px, " + z + "px)"
								);
							} else {
								$wrapperEl.transform("translate(" + x + "px, " + y + "px)");
							}
						}
						swiper.previousTranslate = swiper.translate;
						swiper.translate = swiper.isHorizontal() ? x : y;
						var newProgress;
						var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
						if (translatesDiff === 0) {
							newProgress = 0;
						} else {
							newProgress =
								(translate - swiper.minTranslate()) / translatesDiff;
						}
						if (newProgress !== progress) {
							swiper.updateProgress(translate);
						}
						swiper.emit("setTranslate", swiper.translate, byController);
					}
					function minTranslate() {
						return -this.snapGrid[0];
					}
					function maxTranslate() {
						return -this.snapGrid[this.snapGrid.length - 1];
					}
					var translate = {
						getTranslate: getTranslate,
						setTranslate: setTranslate,
						minTranslate: minTranslate,
						maxTranslate: maxTranslate,
					};
					function setTransition(duration, byController) {
						var swiper = this;
						swiper.$wrapperEl.transition(duration);
						swiper.emit("setTransition", duration, byController);
					}
					function transitionStart(runCallbacks, direction) {
						if (runCallbacks === void 0) runCallbacks = true;
						var swiper = this;
						var activeIndex = swiper.activeIndex;
						var params = swiper.params;
						var previousIndex = swiper.previousIndex;
						if (params.autoHeight) {
							swiper.updateAutoHeight();
						}
						var dir = direction;
						if (!dir) {
							if (activeIndex > previousIndex) {
								dir = "next";
							} else if (activeIndex < previousIndex) {
								dir = "prev";
							} else {
								dir = "reset";
							}
						}
						swiper.emit("transitionStart");
						if (runCallbacks && activeIndex !== previousIndex) {
							if (dir === "reset") {
								swiper.emit("slideResetTransitionStart");
								return;
							}
							swiper.emit("slideChangeTransitionStart");
							if (dir === "next") {
								swiper.emit("slideNextTransitionStart");
							} else {
								swiper.emit("slidePrevTransitionStart");
							}
						}
					}
					function transitionEnd$1(runCallbacks, direction) {
						if (runCallbacks === void 0) runCallbacks = true;
						var swiper = this;
						var activeIndex = swiper.activeIndex;
						var previousIndex = swiper.previousIndex;
						swiper.animating = false;
						swiper.setTransition(0);
						var dir = direction;
						if (!dir) {
							if (activeIndex > previousIndex) {
								dir = "next";
							} else if (activeIndex < previousIndex) {
								dir = "prev";
							} else {
								dir = "reset";
							}
						}
						swiper.emit("transitionEnd");
						if (runCallbacks && activeIndex !== previousIndex) {
							if (dir === "reset") {
								swiper.emit("slideResetTransitionEnd");
								return;
							}
							swiper.emit("slideChangeTransitionEnd");
							if (dir === "next") {
								swiper.emit("slideNextTransitionEnd");
							} else {
								swiper.emit("slidePrevTransitionEnd");
							}
						}
					}
					var transition$1 = {
						setTransition: setTransition,
						transitionStart: transitionStart,
						transitionEnd: transitionEnd$1,
					};
					function slideTo(index, speed, runCallbacks, internal) {
						if (index === void 0) index = 0;
						if (speed === void 0) speed = this.params.speed;
						if (runCallbacks === void 0) runCallbacks = true;
						var swiper = this;
						var slideIndex = index;
						if (slideIndex < 0) {
							slideIndex = 0;
						}
						var params = swiper.params;
						var snapGrid = swiper.snapGrid;
						var slidesGrid = swiper.slidesGrid;
						var previousIndex = swiper.previousIndex;
						var activeIndex = swiper.activeIndex;
						var rtl = swiper.rtlTranslate;
						if (swiper.animating && params.preventInteractionOnTransition) {
							return false;
						}
						var snapIndex = Math.floor(slideIndex / params.slidesPerGroup);
						if (snapIndex >= snapGrid.length) {
							snapIndex = snapGrid.length - 1;
						}
						if (
							(activeIndex || params.initialSlide || 0) ===
								(previousIndex || 0) &&
							runCallbacks
						) {
							swiper.emit("beforeSlideChangeStart");
						}
						var translate = -snapGrid[snapIndex];
						swiper.updateProgress(translate);
						if (params.normalizeSlideIndex) {
							for (var i = 0; i < slidesGrid.length; i += 1) {
								if (
									-Math.floor(translate * 100) >=
									Math.floor(slidesGrid[i] * 100)
								) {
									slideIndex = i;
								}
							}
						}
						if (swiper.initialized && slideIndex !== activeIndex) {
							if (
								!swiper.allowSlideNext &&
								translate < swiper.translate &&
								translate < swiper.minTranslate()
							) {
								return false;
							}
							if (
								!swiper.allowSlidePrev &&
								translate > swiper.translate &&
								translate > swiper.maxTranslate()
							) {
								if ((activeIndex || 0) !== slideIndex) {
									return false;
								}
							}
						}
						var direction;
						if (slideIndex > activeIndex) {
							direction = "next";
						} else if (slideIndex < activeIndex) {
							direction = "prev";
						} else {
							direction = "reset";
						}
						if (
							(rtl && -translate === swiper.translate) ||
							(!rtl && translate === swiper.translate)
						) {
							swiper.updateActiveIndex(slideIndex);
							if (params.autoHeight) {
								swiper.updateAutoHeight();
							}
							swiper.updateSlidesClasses();
							if (params.effect !== "slide") {
								swiper.setTranslate(translate);
							}
							if (direction !== "reset") {
								swiper.transitionStart(runCallbacks, direction);
								swiper.transitionEnd(runCallbacks, direction);
							}
							return false;
						}
						if (speed === 0 || !Support.transition) {
							swiper.setTransition(0);
							swiper.setTranslate(translate);
							swiper.updateActiveIndex(slideIndex);
							swiper.updateSlidesClasses();
							swiper.emit("beforeTransitionStart", speed, internal);
							swiper.transitionStart(runCallbacks, direction);
							swiper.transitionEnd(runCallbacks, direction);
						} else {
							swiper.setTransition(speed);
							swiper.setTranslate(translate);
							swiper.updateActiveIndex(slideIndex);
							swiper.updateSlidesClasses();
							swiper.emit("beforeTransitionStart", speed, internal);
							swiper.transitionStart(runCallbacks, direction);
							if (!swiper.animating) {
								swiper.animating = true;
								if (!swiper.onSlideToWrapperTransitionEnd) {
									swiper.onSlideToWrapperTransitionEnd = function transitionEnd(
										e
									) {
										if (!swiper || swiper.destroyed) {
											return;
										}
										if (e.target !== this) {
											return;
										}
										swiper.$wrapperEl[0].removeEventListener(
											"transitionend",
											swiper.onSlideToWrapperTransitionEnd
										);
										swiper.$wrapperEl[0].removeEventListener(
											"webkitTransitionEnd",
											swiper.onSlideToWrapperTransitionEnd
										);
										swiper.onSlideToWrapperTransitionEnd = null;
										delete swiper.onSlideToWrapperTransitionEnd;
										swiper.transitionEnd(runCallbacks, direction);
									};
								}
								swiper.$wrapperEl[0].addEventListener(
									"transitionend",
									swiper.onSlideToWrapperTransitionEnd
								);
								swiper.$wrapperEl[0].addEventListener(
									"webkitTransitionEnd",
									swiper.onSlideToWrapperTransitionEnd
								);
							}
						}
						return true;
					}
					function slideToLoop(index, speed, runCallbacks, internal) {
						if (index === void 0) index = 0;
						if (speed === void 0) speed = this.params.speed;
						if (runCallbacks === void 0) runCallbacks = true;
						var swiper = this;
						var newIndex = index;
						if (swiper.params.loop) {
							newIndex += swiper.loopedSlides;
						}
						return swiper.slideTo(newIndex, speed, runCallbacks, internal);
					}
					function slideNext(speed, runCallbacks, internal) {
						if (speed === void 0) speed = this.params.speed;
						if (runCallbacks === void 0) runCallbacks = true;
						var swiper = this;
						var params = swiper.params;
						var animating = swiper.animating;
						if (params.loop) {
							if (animating) {
								return false;
							}
							swiper.loopFix();
							swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
							return swiper.slideTo(
								swiper.activeIndex + params.slidesPerGroup,
								speed,
								runCallbacks,
								internal
							);
						}
						return swiper.slideTo(
							swiper.activeIndex + params.slidesPerGroup,
							speed,
							runCallbacks,
							internal
						);
					}
					function slidePrev(speed, runCallbacks, internal) {
						if (speed === void 0) speed = this.params.speed;
						if (runCallbacks === void 0) runCallbacks = true;
						var swiper = this;
						var params = swiper.params;
						var animating = swiper.animating;
						var snapGrid = swiper.snapGrid;
						var slidesGrid = swiper.slidesGrid;
						var rtlTranslate = swiper.rtlTranslate;
						if (params.loop) {
							if (animating) {
								return false;
							}
							swiper.loopFix();
							swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
						}
						var translate = rtlTranslate ? swiper.translate : -swiper.translate;
						function normalize(val) {
							if (val < 0) {
								return -Math.floor(Math.abs(val));
							}
							return Math.floor(val);
						}
						var normalizedTranslate = normalize(translate);
						var normalizedSnapGrid = snapGrid.map(function (val) {
							return normalize(val);
						});
						var normalizedSlidesGrid = slidesGrid.map(function (val) {
							return normalize(val);
						});
						var currentSnap =
							snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
						var prevSnap =
							snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
						var prevIndex;
						if (typeof prevSnap !== "undefined") {
							prevIndex = slidesGrid.indexOf(prevSnap);
							if (prevIndex < 0) {
								prevIndex = swiper.activeIndex - 1;
							}
						}
						return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
					}
					function slideReset(speed, runCallbacks, internal) {
						if (speed === void 0) speed = this.params.speed;
						if (runCallbacks === void 0) runCallbacks = true;
						var swiper = this;
						return swiper.slideTo(
							swiper.activeIndex,
							speed,
							runCallbacks,
							internal
						);
					}
					function slideToClosest(speed, runCallbacks, internal) {
						if (speed === void 0) speed = this.params.speed;
						if (runCallbacks === void 0) runCallbacks = true;
						var swiper = this;
						var index = swiper.activeIndex;
						var snapIndex = Math.floor(index / swiper.params.slidesPerGroup);
						if (snapIndex < swiper.snapGrid.length - 1) {
							var translate = swiper.rtlTranslate
								? swiper.translate
								: -swiper.translate;
							var currentSnap = swiper.snapGrid[snapIndex];
							var nextSnap = swiper.snapGrid[snapIndex + 1];
							if (translate - currentSnap > (nextSnap - currentSnap) / 2) {
								index = swiper.params.slidesPerGroup;
							}
						}
						return swiper.slideTo(index, speed, runCallbacks, internal);
					}
					function slideToClickedSlide() {
						var swiper = this;
						var params = swiper.params;
						var $wrapperEl = swiper.$wrapperEl;
						var slidesPerView =
							params.slidesPerView === "auto"
								? swiper.slidesPerViewDynamic()
								: params.slidesPerView;
						var slideToIndex = swiper.clickedIndex;
						var realIndex;
						if (params.loop) {
							if (swiper.animating) {
								return;
							}
							realIndex = parseInt(
								$(swiper.clickedSlide).attr("data-swiper-slide-index"),
								10
							);
							if (params.centeredSlides) {
								if (
									slideToIndex < swiper.loopedSlides - slidesPerView / 2 ||
									slideToIndex >
										swiper.slides.length -
											swiper.loopedSlides +
											slidesPerView / 2
								) {
									swiper.loopFix();
									slideToIndex = $wrapperEl
										.children(
											"." +
												params.slideClass +
												'[data-swiper-slide-index="' +
												realIndex +
												'"]:not(.' +
												params.slideDuplicateClass +
												")"
										)
										.eq(0)
										.index();
									Utils.nextTick(function () {
										swiper.slideTo(slideToIndex);
									});
								} else {
									swiper.slideTo(slideToIndex);
								}
							} else if (slideToIndex > swiper.slides.length - slidesPerView) {
								swiper.loopFix();
								slideToIndex = $wrapperEl
									.children(
										"." +
											params.slideClass +
											'[data-swiper-slide-index="' +
											realIndex +
											'"]:not(.' +
											params.slideDuplicateClass +
											")"
									)
									.eq(0)
									.index();
								Utils.nextTick(function () {
									swiper.slideTo(slideToIndex);
								});
							} else {
								swiper.slideTo(slideToIndex);
							}
						} else {
							swiper.slideTo(slideToIndex);
						}
					}
					var slide = {
						slideTo: slideTo,
						slideToLoop: slideToLoop,
						slideNext: slideNext,
						slidePrev: slidePrev,
						slideReset: slideReset,
						slideToClosest: slideToClosest,
						slideToClickedSlide: slideToClickedSlide,
					};
					function loopCreate() {
						var swiper = this;
						var params = swiper.params;
						var $wrapperEl = swiper.$wrapperEl;
						$wrapperEl
							.children(
								"." + params.slideClass + "." + params.slideDuplicateClass
							)
							.remove();
						var slides = $wrapperEl.children("." + params.slideClass);
						if (params.loopFillGroupWithBlank) {
							var blankSlidesNum =
								params.slidesPerGroup - (slides.length % params.slidesPerGroup);
							if (blankSlidesNum !== params.slidesPerGroup) {
								for (var i = 0; i < blankSlidesNum; i += 1) {
									var blankNode = $(doc.createElement("div")).addClass(
										params.slideClass + " " + params.slideBlankClass
									);
									$wrapperEl.append(blankNode);
								}
								slides = $wrapperEl.children("." + params.slideClass);
							}
						}
						if (params.slidesPerView === "auto" && !params.loopedSlides) {
							params.loopedSlides = slides.length;
						}
						swiper.loopedSlides = parseInt(
							params.loopedSlides || params.slidesPerView,
							10
						);
						swiper.loopedSlides += params.loopAdditionalSlides;
						if (swiper.loopedSlides > slides.length) {
							swiper.loopedSlides = slides.length;
						}
						var prependSlides = [];
						var appendSlides = [];
						slides.each(function (index, el) {
							var slide = $(el);
							if (index < swiper.loopedSlides) {
								appendSlides.push(el);
							}
							if (
								index < slides.length &&
								index >= slides.length - swiper.loopedSlides
							) {
								prependSlides.push(el);
							}
							slide.attr("data-swiper-slide-index", index);
						});
						for (var i$1 = 0; i$1 < appendSlides.length; i$1 += 1) {
							$wrapperEl.append(
								$(appendSlides[i$1].cloneNode(true)).addClass(
									params.slideDuplicateClass
								)
							);
						}
						for (var i$2 = prependSlides.length - 1; i$2 >= 0; i$2 -= 1) {
							$wrapperEl.prepend(
								$(prependSlides[i$2].cloneNode(true)).addClass(
									params.slideDuplicateClass
								)
							);
						}
					}
					function loopFix() {
						var swiper = this;
						var params = swiper.params;
						var activeIndex = swiper.activeIndex;
						var slides = swiper.slides;
						var loopedSlides = swiper.loopedSlides;
						var allowSlidePrev = swiper.allowSlidePrev;
						var allowSlideNext = swiper.allowSlideNext;
						var snapGrid = swiper.snapGrid;
						var rtl = swiper.rtlTranslate;
						var newIndex;
						swiper.allowSlidePrev = true;
						swiper.allowSlideNext = true;
						var snapTranslate = -snapGrid[activeIndex];
						var diff = snapTranslate - swiper.getTranslate();
						if (activeIndex < loopedSlides) {
							newIndex = slides.length - loopedSlides * 3 + activeIndex;
							newIndex += loopedSlides;
							var slideChanged = swiper.slideTo(newIndex, 0, false, true);
							if (slideChanged && diff !== 0) {
								swiper.setTranslate(
									(rtl ? -swiper.translate : swiper.translate) - diff
								);
							}
						} else if (
							(params.slidesPerView === "auto" &&
								activeIndex >= loopedSlides * 2) ||
							activeIndex >= slides.length - loopedSlides
						) {
							newIndex = -slides.length + activeIndex + loopedSlides;
							newIndex += loopedSlides;
							var slideChanged$1 = swiper.slideTo(newIndex, 0, false, true);
							if (slideChanged$1 && diff !== 0) {
								swiper.setTranslate(
									(rtl ? -swiper.translate : swiper.translate) - diff
								);
							}
						}
						swiper.allowSlidePrev = allowSlidePrev;
						swiper.allowSlideNext = allowSlideNext;
					}
					function loopDestroy() {
						var swiper = this;
						var $wrapperEl = swiper.$wrapperEl;
						var params = swiper.params;
						var slides = swiper.slides;
						$wrapperEl
							.children(
								"." +
									params.slideClass +
									"." +
									params.slideDuplicateClass +
									",." +
									params.slideClass +
									"." +
									params.slideBlankClass
							)
							.remove();
						slides.removeAttr("data-swiper-slide-index");
					}
					var loop = {
						loopCreate: loopCreate,
						loopFix: loopFix,
						loopDestroy: loopDestroy,
					};
					function setGrabCursor(moving) {
						var swiper = this;
						if (
							Support.touch ||
							!swiper.params.simulateTouch ||
							(swiper.params.watchOverflow && swiper.isLocked)
						) {
							return;
						}
						var el = swiper.el;
						el.style.cursor = "move";
						el.style.cursor = moving ? "-webkit-grabbing" : "-webkit-grab";
						el.style.cursor = moving ? "-moz-grabbin" : "-moz-grab";
						el.style.cursor = moving ? "grabbing" : "grab";
					}
					function unsetGrabCursor() {
						var swiper = this;
						if (
							Support.touch ||
							(swiper.params.watchOverflow && swiper.isLocked)
						) {
							return;
						}
						swiper.el.style.cursor = "";
					}
					var grabCursor = {
						setGrabCursor: setGrabCursor,
						unsetGrabCursor: unsetGrabCursor,
					};
					function appendSlide(slides) {
						var swiper = this;
						var $wrapperEl = swiper.$wrapperEl;
						var params = swiper.params;
						if (params.loop) {
							swiper.loopDestroy();
						}
						if (typeof slides === "object" && "length" in slides) {
							for (var i = 0; i < slides.length; i += 1) {
								if (slides[i]) {
									$wrapperEl.append(slides[i]);
								}
							}
						} else {
							$wrapperEl.append(slides);
						}
						if (params.loop) {
							swiper.loopCreate();
						}
						if (!(params.observer && Support.observer)) {
							swiper.update();
						}
					}
					function prependSlide(slides) {
						var swiper = this;
						var params = swiper.params;
						var $wrapperEl = swiper.$wrapperEl;
						var activeIndex = swiper.activeIndex;
						if (params.loop) {
							swiper.loopDestroy();
						}
						var newActiveIndex = activeIndex + 1;
						if (typeof slides === "object" && "length" in slides) {
							for (var i = 0; i < slides.length; i += 1) {
								if (slides[i]) {
									$wrapperEl.prepend(slides[i]);
								}
							}
							newActiveIndex = activeIndex + slides.length;
						} else {
							$wrapperEl.prepend(slides);
						}
						if (params.loop) {
							swiper.loopCreate();
						}
						if (!(params.observer && Support.observer)) {
							swiper.update();
						}
						swiper.slideTo(newActiveIndex, 0, false);
					}
					function addSlide(index, slides) {
						var swiper = this;
						var $wrapperEl = swiper.$wrapperEl;
						var params = swiper.params;
						var activeIndex = swiper.activeIndex;
						var activeIndexBuffer = activeIndex;
						if (params.loop) {
							activeIndexBuffer -= swiper.loopedSlides;
							swiper.loopDestroy();
							swiper.slides = $wrapperEl.children("." + params.slideClass);
						}
						var baseLength = swiper.slides.length;
						if (index <= 0) {
							swiper.prependSlide(slides);
							return;
						}
						if (index >= baseLength) {
							swiper.appendSlide(slides);
							return;
						}
						var newActiveIndex =
							activeIndexBuffer > index
								? activeIndexBuffer + 1
								: activeIndexBuffer;
						var slidesBuffer = [];
						for (var i = baseLength - 1; i >= index; i -= 1) {
							var currentSlide = swiper.slides.eq(i);
							currentSlide.remove();
							slidesBuffer.unshift(currentSlide);
						}
						if (typeof slides === "object" && "length" in slides) {
							for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
								if (slides[i$1]) {
									$wrapperEl.append(slides[i$1]);
								}
							}
							newActiveIndex =
								activeIndexBuffer > index
									? activeIndexBuffer + slides.length
									: activeIndexBuffer;
						} else {
							$wrapperEl.append(slides);
						}
						for (var i$2 = 0; i$2 < slidesBuffer.length; i$2 += 1) {
							$wrapperEl.append(slidesBuffer[i$2]);
						}
						if (params.loop) {
							swiper.loopCreate();
						}
						if (!(params.observer && Support.observer)) {
							swiper.update();
						}
						if (params.loop) {
							swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
						} else {
							swiper.slideTo(newActiveIndex, 0, false);
						}
					}
					function removeSlide(slidesIndexes) {
						var swiper = this;
						var params = swiper.params;
						var $wrapperEl = swiper.$wrapperEl;
						var activeIndex = swiper.activeIndex;
						var activeIndexBuffer = activeIndex;
						if (params.loop) {
							activeIndexBuffer -= swiper.loopedSlides;
							swiper.loopDestroy();
							swiper.slides = $wrapperEl.children("." + params.slideClass);
						}
						var newActiveIndex = activeIndexBuffer;
						var indexToRemove;
						if (
							typeof slidesIndexes === "object" &&
							"length" in slidesIndexes
						) {
							for (var i = 0; i < slidesIndexes.length; i += 1) {
								indexToRemove = slidesIndexes[i];
								if (swiper.slides[indexToRemove]) {
									swiper.slides.eq(indexToRemove).remove();
								}
								if (indexToRemove < newActiveIndex) {
									newActiveIndex -= 1;
								}
							}
							newActiveIndex = Math.max(newActiveIndex, 0);
						} else {
							indexToRemove = slidesIndexes;
							if (swiper.slides[indexToRemove]) {
								swiper.slides.eq(indexToRemove).remove();
							}
							if (indexToRemove < newActiveIndex) {
								newActiveIndex -= 1;
							}
							newActiveIndex = Math.max(newActiveIndex, 0);
						}
						if (params.loop) {
							swiper.loopCreate();
						}
						if (!(params.observer && Support.observer)) {
							swiper.update();
						}
						if (params.loop) {
							swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
						} else {
							swiper.slideTo(newActiveIndex, 0, false);
						}
					}
					function removeAllSlides() {
						var swiper = this;
						var slidesIndexes = [];
						for (var i = 0; i < swiper.slides.length; i += 1) {
							slidesIndexes.push(i);
						}
						swiper.removeSlide(slidesIndexes);
					}
					var manipulation = {
						appendSlide: appendSlide,
						prependSlide: prependSlide,
						addSlide: addSlide,
						removeSlide: removeSlide,
						removeAllSlides: removeAllSlides,
					};
					var Device = (function Device() {
						var ua = win.navigator.userAgent;
						var device = {
							ios: false,
							android: false,
							androidChrome: false,
							desktop: false,
							windows: false,
							iphone: false,
							ipod: false,
							ipad: false,
							cordova: win.cordova || win.phonegap,
							phonegap: win.cordova || win.phonegap,
						};
						var windows = ua.match(/(Windows Phone);?[\s\/]+([\d.]+)?/);
						var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
						var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
						var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
						var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
						if (windows) {
							device.os = "windows";
							device.osVersion = windows[2];
							device.windows = true;
						}
						if (android && !windows) {
							device.os = "android";
							device.osVersion = android[2];
							device.android = true;
							device.androidChrome = ua.toLowerCase().indexOf("chrome") >= 0;
						}
						if (ipad || iphone || ipod) {
							device.os = "ios";
							device.ios = true;
						}
						if (iphone && !ipod) {
							device.osVersion = iphone[2].replace(/_/g, ".");
							device.iphone = true;
						}
						if (ipad) {
							device.osVersion = ipad[2].replace(/_/g, ".");
							device.ipad = true;
						}
						if (ipod) {
							device.osVersion = ipod[3] ? ipod[3].replace(/_/g, ".") : null;
							device.iphone = true;
						}
						if (device.ios && device.osVersion && ua.indexOf("Version/") >= 0) {
							if (device.osVersion.split(".")[0] === "10") {
								device.osVersion = ua
									.toLowerCase()
									.split("version/")[1]
									.split(" ")[0];
							}
						}
						device.desktop = !(device.os || device.android || device.webView);
						device.webView =
							(iphone || ipad || ipod) &&
							ua.match(/.*AppleWebKit(?!.*Safari)/i);
						if (device.os && device.os === "ios") {
							var osVersionArr = device.osVersion.split(".");
							var metaViewport = doc.querySelector('meta[name="viewport"]');
							device.minimalUi =
								!device.webView &&
								(ipod || iphone) &&
								(osVersionArr[0] * 1 === 7
									? osVersionArr[1] * 1 >= 1
									: osVersionArr[0] * 1 > 7) &&
								metaViewport &&
								metaViewport.getAttribute("content").indexOf("minimal-ui") >= 0;
						}
						device.pixelRatio = win.devicePixelRatio || 1;
						return device;
					})();
					function onTouchStart(event) {
						var swiper = this;
						var data = swiper.touchEventsData;
						var params = swiper.params;
						var touches = swiper.touches;
						if (swiper.animating && params.preventInteractionOnTransition) {
							return;
						}
						var e = event;
						if (e.originalEvent) {
							e = e.originalEvent;
						}
						data.isTouchEvent = e.type === "touchstart";
						if (!data.isTouchEvent && "which" in e && e.which === 3) {
							return;
						}
						if (!data.isTouchEvent && "button" in e && e.button > 0) {
							return;
						}
						if (data.isTouched && data.isMoved) {
							return;
						}
						if (
							params.noSwiping &&
							$(e.target).closest(
								params.noSwipingSelector
									? params.noSwipingSelector
									: "." + params.noSwipingClass
							)[0]
						) {
							swiper.allowClick = true;
							return;
						}
						if (params.swipeHandler) {
							if (!$(e).closest(params.swipeHandler)[0]) {
								return;
							}
						}
						touches.currentX =
							e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
						touches.currentY =
							e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
						var startX = touches.currentX;
						var startY = touches.currentY;
						var edgeSwipeDetection =
							params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
						var edgeSwipeThreshold =
							params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
						if (
							edgeSwipeDetection &&
							(startX <= edgeSwipeThreshold ||
								startX >= win.screen.width - edgeSwipeThreshold)
						) {
							return;
						}
						Utils.extend(data, {
							isTouched: true,
							isMoved: false,
							allowTouchCallbacks: true,
							isScrolling: undefined,
							startMoving: undefined,
						});
						touches.startX = startX;
						touches.startY = startY;
						data.touchStartTime = Utils.now();
						swiper.allowClick = true;
						swiper.updateSize();
						swiper.swipeDirection = undefined;
						if (params.threshold > 0) {
							data.allowThresholdMove = false;
						}
						if (e.type !== "touchstart") {
							var preventDefault = true;
							if ($(e.target).is(data.formElements)) {
								preventDefault = false;
							}
							if (
								doc.activeElement &&
								$(doc.activeElement).is(data.formElements) &&
								doc.activeElement !== e.target
							) {
								doc.activeElement.blur();
							}
							var shouldPreventDefault =
								preventDefault &&
								swiper.allowTouchMove &&
								params.touchStartPreventDefault;
							if (
								params.touchStartForcePreventDefault ||
								shouldPreventDefault
							) {
								e.preventDefault();
							}
						}
						swiper.emit("touchStart", e);
					}
					function onTouchMove(event) {
						var swiper = this;
						var data = swiper.touchEventsData;
						var params = swiper.params;
						var touches = swiper.touches;
						var rtl = swiper.rtlTranslate;
						var e = event;
						if (e.originalEvent) {
							e = e.originalEvent;
						}
						if (!data.isTouched) {
							if (data.startMoving && data.isScrolling) {
								swiper.emit("touchMoveOpposite", e);
							}
							return;
						}
						if (data.isTouchEvent && e.type === "mousemove") {
							return;
						}
						var pageX =
							e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
						var pageY =
							e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
						if (e.preventedByNestedSwiper) {
							touches.startX = pageX;
							touches.startY = pageY;
							return;
						}
						if (!swiper.allowTouchMove) {
							swiper.allowClick = false;
							if (data.isTouched) {
								Utils.extend(touches, {
									startX: pageX,
									startY: pageY,
									currentX: pageX,
									currentY: pageY,
								});
								data.touchStartTime = Utils.now();
							}
							return;
						}
						if (
							data.isTouchEvent &&
							params.touchReleaseOnEdges &&
							!params.loop
						) {
							if (swiper.isVertical()) {
								if (
									(pageY < touches.startY &&
										swiper.translate <= swiper.maxTranslate()) ||
									(pageY > touches.startY &&
										swiper.translate >= swiper.minTranslate())
								) {
									data.isTouched = false;
									data.isMoved = false;
									return;
								}
							} else if (
								(pageX < touches.startX &&
									swiper.translate <= swiper.maxTranslate()) ||
								(pageX > touches.startX &&
									swiper.translate >= swiper.minTranslate())
							) {
								return;
							}
						}
						if (data.isTouchEvent && doc.activeElement) {
							if (
								e.target === doc.activeElement &&
								$(e.target).is(data.formElements)
							) {
								data.isMoved = true;
								swiper.allowClick = false;
								return;
							}
						}
						if (data.allowTouchCallbacks) {
							swiper.emit("touchMove", e);
						}
						if (e.targetTouches && e.targetTouches.length > 1) {
							return;
						}
						touches.currentX = pageX;
						touches.currentY = pageY;
						var diffX = touches.currentX - touches.startX;
						var diffY = touches.currentY - touches.startY;
						if (
							swiper.params.threshold &&
							Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) <
								swiper.params.threshold
						) {
							return;
						}
						if (typeof data.isScrolling === "undefined") {
							var touchAngle;
							if (
								(swiper.isHorizontal() &&
									touches.currentY === touches.startY) ||
								(swiper.isVertical() && touches.currentX === touches.startX)
							) {
								data.isScrolling = false;
							} else {
								if (diffX * diffX + diffY * diffY >= 25) {
									touchAngle =
										(Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) /
										Math.PI;
									data.isScrolling = swiper.isHorizontal()
										? touchAngle > params.touchAngle
										: 90 - touchAngle > params.touchAngle;
								}
							}
						}
						if (data.isScrolling) {
							swiper.emit("touchMoveOpposite", e);
						}
						if (typeof data.startMoving === "undefined") {
							if (
								touches.currentX !== touches.startX ||
								touches.currentY !== touches.startY
							) {
								data.startMoving = true;
							}
						}
						if (data.isScrolling) {
							data.isTouched = false;
							return;
						}
						if (!data.startMoving) {
							return;
						}
						swiper.allowClick = false;
						e.preventDefault();
						if (params.touchMoveStopPropagation && !params.nested) {
							e.stopPropagation();
						}
						if (!data.isMoved) {
							if (params.loop) {
								swiper.loopFix();
							}
							data.startTranslate = swiper.getTranslate();
							swiper.setTransition(0);
							if (swiper.animating) {
								swiper.$wrapperEl.trigger("webkitTransitionEnd transitionend");
							}
							data.allowMomentumBounce = false;
							if (
								params.grabCursor &&
								(swiper.allowSlideNext === true ||
									swiper.allowSlidePrev === true)
							) {
								swiper.setGrabCursor(true);
							}
							swiper.emit("sliderFirstMove", e);
						}
						swiper.emit("sliderMove", e);
						data.isMoved = true;
						var diff = swiper.isHorizontal() ? diffX : diffY;
						touches.diff = diff;
						diff *= params.touchRatio;
						if (rtl) {
							diff = -diff;
						}
						swiper.swipeDirection = diff > 0 ? "prev" : "next";
						data.currentTranslate = diff + data.startTranslate;
						var disableParentSwiper = true;
						var resistanceRatio = params.resistanceRatio;
						if (params.touchReleaseOnEdges) {
							resistanceRatio = 0;
						}
						if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
							disableParentSwiper = false;
							if (params.resistance) {
								data.currentTranslate =
									swiper.minTranslate() -
									1 +
									Math.pow(
										-swiper.minTranslate() + data.startTranslate + diff,
										resistanceRatio
									);
							}
						} else if (
							diff < 0 &&
							data.currentTranslate < swiper.maxTranslate()
						) {
							disableParentSwiper = false;
							if (params.resistance) {
								data.currentTranslate =
									swiper.maxTranslate() +
									1 -
									Math.pow(
										swiper.maxTranslate() - data.startTranslate - diff,
										resistanceRatio
									);
							}
						}
						if (disableParentSwiper) {
							e.preventedByNestedSwiper = true;
						}
						if (
							!swiper.allowSlideNext &&
							swiper.swipeDirection === "next" &&
							data.currentTranslate < data.startTranslate
						) {
							data.currentTranslate = data.startTranslate;
						}
						if (
							!swiper.allowSlidePrev &&
							swiper.swipeDirection === "prev" &&
							data.currentTranslate > data.startTranslate
						) {
							data.currentTranslate = data.startTranslate;
						}
						if (params.threshold > 0) {
							if (
								Math.abs(diff) > params.threshold ||
								data.allowThresholdMove
							) {
								if (!data.allowThresholdMove) {
									data.allowThresholdMove = true;
									touches.startX = touches.currentX;
									touches.startY = touches.currentY;
									data.currentTranslate = data.startTranslate;
									touches.diff = swiper.isHorizontal()
										? touches.currentX - touches.startX
										: touches.currentY - touches.startY;
									return;
								}
							} else {
								data.currentTranslate = data.startTranslate;
								return;
							}
						}
						if (!params.followFinger) {
							return;
						}
						if (
							params.freeMode ||
							params.watchSlidesProgress ||
							params.watchSlidesVisibility
						) {
							swiper.updateActiveIndex();
							swiper.updateSlidesClasses();
						}
						if (params.freeMode) {
							if (data.velocities.length === 0) {
								data.velocities.push({
									position:
										touches[swiper.isHorizontal() ? "startX" : "startY"],
									time: data.touchStartTime,
								});
							}
							data.velocities.push({
								position:
									touches[swiper.isHorizontal() ? "currentX" : "currentY"],
								time: Utils.now(),
							});
						}
						swiper.updateProgress(data.currentTranslate);
						swiper.setTranslate(data.currentTranslate);
					}
					function onTouchEnd(event) {
						var swiper = this;
						var data = swiper.touchEventsData;
						var params = swiper.params;
						var touches = swiper.touches;
						var rtl = swiper.rtlTranslate;
						var $wrapperEl = swiper.$wrapperEl;
						var slidesGrid = swiper.slidesGrid;
						var snapGrid = swiper.snapGrid;
						var e = event;
						if (e.originalEvent) {
							e = e.originalEvent;
						}
						if (data.allowTouchCallbacks) {
							swiper.emit("touchEnd", e);
						}
						data.allowTouchCallbacks = false;
						if (!data.isTouched) {
							if (data.isMoved && params.grabCursor) {
								swiper.setGrabCursor(false);
							}
							data.isMoved = false;
							data.startMoving = false;
							return;
						}
						if (
							params.grabCursor &&
							data.isMoved &&
							data.isTouched &&
							(swiper.allowSlideNext === true || swiper.allowSlidePrev === true)
						) {
							swiper.setGrabCursor(false);
						}
						var touchEndTime = Utils.now();
						var timeDiff = touchEndTime - data.touchStartTime;
						if (swiper.allowClick) {
							swiper.updateClickedSlide(e);
							swiper.emit("tap", e);
							if (timeDiff < 300 && touchEndTime - data.lastClickTime > 300) {
								if (data.clickTimeout) {
									clearTimeout(data.clickTimeout);
								}
								data.clickTimeout = Utils.nextTick(function () {
									if (!swiper || swiper.destroyed) {
										return;
									}
									swiper.emit("click", e);
								}, 300);
							}
							if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
								if (data.clickTimeout) {
									clearTimeout(data.clickTimeout);
								}
								swiper.emit("doubleTap", e);
							}
						}
						data.lastClickTime = Utils.now();
						Utils.nextTick(function () {
							if (!swiper.destroyed) {
								swiper.allowClick = true;
							}
						});
						if (
							!data.isTouched ||
							!data.isMoved ||
							!swiper.swipeDirection ||
							touches.diff === 0 ||
							data.currentTranslate === data.startTranslate
						) {
							data.isTouched = false;
							data.isMoved = false;
							data.startMoving = false;
							return;
						}
						data.isTouched = false;
						data.isMoved = false;
						data.startMoving = false;
						var currentPos;
						if (params.followFinger) {
							currentPos = rtl ? swiper.translate : -swiper.translate;
						} else {
							currentPos = -data.currentTranslate;
						}
						if (params.freeMode) {
							if (currentPos < -swiper.minTranslate()) {
								swiper.slideTo(swiper.activeIndex);
								return;
							}
							if (currentPos > -swiper.maxTranslate()) {
								if (swiper.slides.length < snapGrid.length) {
									swiper.slideTo(snapGrid.length - 1);
								} else {
									swiper.slideTo(swiper.slides.length - 1);
								}
								return;
							}
							if (params.freeModeMomentum) {
								if (data.velocities.length > 1) {
									var lastMoveEvent = data.velocities.pop();
									var velocityEvent = data.velocities.pop();
									var distance =
										lastMoveEvent.position - velocityEvent.position;
									var time = lastMoveEvent.time - velocityEvent.time;
									swiper.velocity = distance / time;
									swiper.velocity /= 2;
									if (
										Math.abs(swiper.velocity) < params.freeModeMinimumVelocity
									) {
										swiper.velocity = 0;
									}
									if (time > 150 || Utils.now() - lastMoveEvent.time > 300) {
										swiper.velocity = 0;
									}
								} else {
									swiper.velocity = 0;
								}
								swiper.velocity *= params.freeModeMomentumVelocityRatio;
								data.velocities.length = 0;
								var momentumDuration = 1e3 * params.freeModeMomentumRatio;
								var momentumDistance = swiper.velocity * momentumDuration;
								var newPosition = swiper.translate + momentumDistance;
								if (rtl) {
									newPosition = -newPosition;
								}
								var doBounce = false;
								var afterBouncePosition;
								var bounceAmount =
									Math.abs(swiper.velocity) *
									20 *
									params.freeModeMomentumBounceRatio;
								var needsLoopFix;
								if (newPosition < swiper.maxTranslate()) {
									if (params.freeModeMomentumBounce) {
										if (newPosition + swiper.maxTranslate() < -bounceAmount) {
											newPosition = swiper.maxTranslate() - bounceAmount;
										}
										afterBouncePosition = swiper.maxTranslate();
										doBounce = true;
										data.allowMomentumBounce = true;
									} else {
										newPosition = swiper.maxTranslate();
									}
									if (params.loop && params.centeredSlides) {
										needsLoopFix = true;
									}
								} else if (newPosition > swiper.minTranslate()) {
									if (params.freeModeMomentumBounce) {
										if (newPosition - swiper.minTranslate() > bounceAmount) {
											newPosition = swiper.minTranslate() + bounceAmount;
										}
										afterBouncePosition = swiper.minTranslate();
										doBounce = true;
										data.allowMomentumBounce = true;
									} else {
										newPosition = swiper.minTranslate();
									}
									if (params.loop && params.centeredSlides) {
										needsLoopFix = true;
									}
								} else if (params.freeModeSticky) {
									var nextSlide;
									for (var j = 0; j < snapGrid.length; j += 1) {
										if (snapGrid[j] > -newPosition) {
											nextSlide = j;
											break;
										}
									}
									if (
										Math.abs(snapGrid[nextSlide] - newPosition) <
											Math.abs(snapGrid[nextSlide - 1] - newPosition) ||
										swiper.swipeDirection === "next"
									) {
										newPosition = snapGrid[nextSlide];
									} else {
										newPosition = snapGrid[nextSlide - 1];
									}
									newPosition = -newPosition;
								}
								if (needsLoopFix) {
									swiper.once("transitionEnd", function () {
										swiper.loopFix();
									});
								}
								if (swiper.velocity !== 0) {
									if (rtl) {
										momentumDuration = Math.abs(
											(-newPosition - swiper.translate) / swiper.velocity
										);
									} else {
										momentumDuration = Math.abs(
											(newPosition - swiper.translate) / swiper.velocity
										);
									}
								} else if (params.freeModeSticky) {
									swiper.slideToClosest();
									return;
								}
								if (params.freeModeMomentumBounce && doBounce) {
									swiper.updateProgress(afterBouncePosition);
									swiper.setTransition(momentumDuration);
									swiper.setTranslate(newPosition);
									swiper.transitionStart(true, swiper.swipeDirection);
									swiper.animating = true;
									$wrapperEl.transitionEnd(function () {
										if (
											!swiper ||
											swiper.destroyed ||
											!data.allowMomentumBounce
										) {
											return;
										}
										swiper.emit("momentumBounce");
										swiper.setTransition(params.speed);
										swiper.setTranslate(afterBouncePosition);
										$wrapperEl.transitionEnd(function () {
											if (!swiper || swiper.destroyed) {
												return;
											}
											swiper.transitionEnd();
										});
									});
								} else if (swiper.velocity) {
									swiper.updateProgress(newPosition);
									swiper.setTransition(momentumDuration);
									swiper.setTranslate(newPosition);
									swiper.transitionStart(true, swiper.swipeDirection);
									if (!swiper.animating) {
										swiper.animating = true;
										$wrapperEl.transitionEnd(function () {
											if (!swiper || swiper.destroyed) {
												return;
											}
											swiper.transitionEnd();
										});
									}
								} else {
									swiper.updateProgress(newPosition);
								}
								swiper.updateActiveIndex();
								swiper.updateSlidesClasses();
							} else if (params.freeModeSticky) {
								swiper.slideToClosest();
								return;
							}
							if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
								swiper.updateProgress();
								swiper.updateActiveIndex();
								swiper.updateSlidesClasses();
							}
							return;
						}
						var stopIndex = 0;
						var groupSize = swiper.slidesSizesGrid[0];
						for (var i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {
							if (
								typeof slidesGrid[i + params.slidesPerGroup] !== "undefined"
							) {
								if (
									currentPos >= slidesGrid[i] &&
									currentPos < slidesGrid[i + params.slidesPerGroup]
								) {
									stopIndex = i;
									groupSize =
										slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];
								}
							} else if (currentPos >= slidesGrid[i]) {
								stopIndex = i;
								groupSize =
									slidesGrid[slidesGrid.length - 1] -
									slidesGrid[slidesGrid.length - 2];
							}
						}
						var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
						if (timeDiff > params.longSwipesMs) {
							if (!params.longSwipes) {
								swiper.slideTo(swiper.activeIndex);
								return;
							}
							if (swiper.swipeDirection === "next") {
								if (ratio >= params.longSwipesRatio) {
									swiper.slideTo(stopIndex + params.slidesPerGroup);
								} else {
									swiper.slideTo(stopIndex);
								}
							}
							if (swiper.swipeDirection === "prev") {
								if (ratio > 1 - params.longSwipesRatio) {
									swiper.slideTo(stopIndex + params.slidesPerGroup);
								} else {
									swiper.slideTo(stopIndex);
								}
							}
						} else {
							if (!params.shortSwipes) {
								swiper.slideTo(swiper.activeIndex);
								return;
							}
							if (swiper.swipeDirection === "next") {
								swiper.slideTo(stopIndex + params.slidesPerGroup);
							}
							if (swiper.swipeDirection === "prev") {
								swiper.slideTo(stopIndex);
							}
						}
					}
					function onResize() {
						var swiper = this;
						var params = swiper.params;
						var el = swiper.el;
						if (el && el.offsetWidth === 0) {
							return;
						}
						if (params.breakpoints) {
							swiper.setBreakpoint();
						}
						var allowSlideNext = swiper.allowSlideNext;
						var allowSlidePrev = swiper.allowSlidePrev;
						var snapGrid = swiper.snapGrid;
						swiper.allowSlideNext = true;
						swiper.allowSlidePrev = true;
						swiper.updateSize();
						swiper.updateSlides();
						if (params.freeMode) {
							var newTranslate = Math.min(
								Math.max(swiper.translate, swiper.maxTranslate()),
								swiper.minTranslate()
							);
							swiper.setTranslate(newTranslate);
							swiper.updateActiveIndex();
							swiper.updateSlidesClasses();
							if (params.autoHeight) {
								swiper.updateAutoHeight();
							}
						} else {
							swiper.updateSlidesClasses();
							if (
								(params.slidesPerView === "auto" || params.slidesPerView > 1) &&
								swiper.isEnd &&
								!swiper.params.centeredSlides
							) {
								swiper.slideTo(swiper.slides.length - 1, 0, false, true);
							} else {
								swiper.slideTo(swiper.activeIndex, 0, false, true);
							}
						}
						if (
							swiper.autoplay &&
							swiper.autoplay.running &&
							swiper.autoplay.paused
						) {
							swiper.autoplay.run();
						}
						swiper.allowSlidePrev = allowSlidePrev;
						swiper.allowSlideNext = allowSlideNext;
						if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
							swiper.checkOverflow();
						}
					}
					function onClick(e) {
						var swiper = this;
						if (!swiper.allowClick) {
							if (swiper.params.preventClicks) {
								e.preventDefault();
							}
							if (swiper.params.preventClicksPropagation && swiper.animating) {
								e.stopPropagation();
								e.stopImmediatePropagation();
							}
						}
					}
					function attachEvents() {
						var swiper = this;
						var params = swiper.params;
						var touchEvents = swiper.touchEvents;
						var el = swiper.el;
						var wrapperEl = swiper.wrapperEl;
						{
							swiper.onTouchStart = onTouchStart.bind(swiper);
							swiper.onTouchMove = onTouchMove.bind(swiper);
							swiper.onTouchEnd = onTouchEnd.bind(swiper);
						}
						swiper.onClick = onClick.bind(swiper);
						var target =
							params.touchEventsTarget === "container" ? el : wrapperEl;
						var capture = !!params.nested;
						{
							if (
								!Support.touch &&
								(Support.pointerEvents || Support.prefixedPointerEvents)
							) {
								target.addEventListener(
									touchEvents.start,
									swiper.onTouchStart,
									false
								);
								doc.addEventListener(
									touchEvents.move,
									swiper.onTouchMove,
									capture
								);
								doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
							} else {
								if (Support.touch) {
									var passiveListener =
										touchEvents.start === "touchstart" &&
										Support.passiveListener &&
										params.passiveListeners
											? { passive: true, capture: false }
											: false;
									target.addEventListener(
										touchEvents.start,
										swiper.onTouchStart,
										passiveListener
									);
									target.addEventListener(
										touchEvents.move,
										swiper.onTouchMove,
										Support.passiveListener
											? { passive: false, capture: capture }
											: capture
									);
									target.addEventListener(
										touchEvents.end,
										swiper.onTouchEnd,
										passiveListener
									);
								}
								if (
									(params.simulateTouch && !Device.ios && !Device.android) ||
									(params.simulateTouch && !Support.touch && Device.ios)
								) {
									target.addEventListener(
										"mousedown",
										swiper.onTouchStart,
										false
									);
									doc.addEventListener(
										"mousemove",
										swiper.onTouchMove,
										capture
									);
									doc.addEventListener("mouseup", swiper.onTouchEnd, false);
								}
							}
							if (params.preventClicks || params.preventClicksPropagation) {
								target.addEventListener("click", swiper.onClick, true);
							}
						}
						swiper.on(
							Device.ios || Device.android
								? "resize orientationchange observerUpdate"
								: "resize observerUpdate",
							onResize,
							true
						);
					}
					function detachEvents() {
						var swiper = this;
						var params = swiper.params;
						var touchEvents = swiper.touchEvents;
						var el = swiper.el;
						var wrapperEl = swiper.wrapperEl;
						var target =
							params.touchEventsTarget === "container" ? el : wrapperEl;
						var capture = !!params.nested;
						{
							if (
								!Support.touch &&
								(Support.pointerEvents || Support.prefixedPointerEvents)
							) {
								target.removeEventListener(
									touchEvents.start,
									swiper.onTouchStart,
									false
								);
								doc.removeEventListener(
									touchEvents.move,
									swiper.onTouchMove,
									capture
								);
								doc.removeEventListener(
									touchEvents.end,
									swiper.onTouchEnd,
									false
								);
							} else {
								if (Support.touch) {
									var passiveListener =
										touchEvents.start === "onTouchStart" &&
										Support.passiveListener &&
										params.passiveListeners
											? { passive: true, capture: false }
											: false;
									target.removeEventListener(
										touchEvents.start,
										swiper.onTouchStart,
										passiveListener
									);
									target.removeEventListener(
										touchEvents.move,
										swiper.onTouchMove,
										capture
									);
									target.removeEventListener(
										touchEvents.end,
										swiper.onTouchEnd,
										passiveListener
									);
								}
								if (
									(params.simulateTouch && !Device.ios && !Device.android) ||
									(params.simulateTouch && !Support.touch && Device.ios)
								) {
									target.removeEventListener(
										"mousedown",
										swiper.onTouchStart,
										false
									);
									doc.removeEventListener(
										"mousemove",
										swiper.onTouchMove,
										capture
									);
									doc.removeEventListener("mouseup", swiper.onTouchEnd, false);
								}
							}
							if (params.preventClicks || params.preventClicksPropagation) {
								target.removeEventListener("click", swiper.onClick, true);
							}
						}
						swiper.off(
							Device.ios || Device.android
								? "resize orientationchange observerUpdate"
								: "resize observerUpdate",
							onResize
						);
					}
					var events = {
						attachEvents: attachEvents,
						detachEvents: detachEvents,
					};
					function setBreakpoint() {
						var swiper = this;
						var activeIndex = swiper.activeIndex;
						var initialized = swiper.initialized;
						var loopedSlides = swiper.loopedSlides;
						if (loopedSlides === void 0) loopedSlides = 0;
						var params = swiper.params;
						var breakpoints = params.breakpoints;
						if (
							!breakpoints ||
							(breakpoints && Object.keys(breakpoints).length === 0)
						) {
							return;
						}
						var breakpoint = swiper.getBreakpoint(breakpoints);
						if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
							var breakpointOnlyParams =
								breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
							if (breakpointOnlyParams) {
								["slidesPerView", "spaceBetween", "slidesPerGroup"].forEach(
									function (param) {
										var paramValue = breakpointOnlyParams[param];
										if (typeof paramValue === "undefined") {
											return;
										}
										if (
											param === "slidesPerView" &&
											(paramValue === "AUTO" || paramValue === "auto")
										) {
											breakpointOnlyParams[param] = "auto";
										} else if (param === "slidesPerView") {
											breakpointOnlyParams[param] = parseFloat(paramValue);
										} else {
											breakpointOnlyParams[param] = parseInt(paramValue, 10);
										}
									}
								);
							}
							var breakpointParams =
								breakpointOnlyParams || swiper.originalParams;
							var directionChanged =
								breakpointParams.direction &&
								breakpointParams.direction !== params.direction;
							var needsReLoop =
								params.loop &&
								(breakpointParams.slidesPerView !== params.slidesPerView ||
									directionChanged);
							if (directionChanged && initialized) {
								swiper.changeDirection();
							}
							Utils.extend(swiper.params, breakpointParams);
							Utils.extend(swiper, {
								allowTouchMove: swiper.params.allowTouchMove,
								allowSlideNext: swiper.params.allowSlideNext,
								allowSlidePrev: swiper.params.allowSlidePrev,
							});
							swiper.currentBreakpoint = breakpoint;
							if (needsReLoop && initialized) {
								swiper.loopDestroy();
								swiper.loopCreate();
								swiper.updateSlides();
								swiper.slideTo(
									activeIndex - loopedSlides + swiper.loopedSlides,
									0,
									false
								);
							}
							swiper.emit("breakpoint", breakpointParams);
						}
					}
					function getBreakpoint(breakpoints) {
						var swiper = this;
						if (!breakpoints) {
							return undefined;
						}
						var breakpoint = false;
						var points = [];
						Object.keys(breakpoints).forEach(function (point) {
							points.push(point);
						});
						points.sort(function (a, b) {
							return parseInt(a, 10) - parseInt(b, 10);
						});
						for (var i = 0; i < points.length; i += 1) {
							var point = points[i];
							if (swiper.params.breakpointsInverse) {
								if (point <= win.innerWidth) {
									breakpoint = point;
								}
							} else if (point >= win.innerWidth && !breakpoint) {
								breakpoint = point;
							}
						}
						return breakpoint || "max";
					}
					var breakpoints = {
						setBreakpoint: setBreakpoint,
						getBreakpoint: getBreakpoint,
					};
					function addClasses() {
						var swiper = this;
						var classNames = swiper.classNames;
						var params = swiper.params;
						var rtl = swiper.rtl;
						var $el = swiper.$el;
						var suffixes = [];
						suffixes.push("initialized");
						suffixes.push(params.direction);
						if (params.freeMode) {
							suffixes.push("free-mode");
						}
						if (!Support.flexbox) {
							suffixes.push("no-flexbox");
						}
						if (params.autoHeight) {
							suffixes.push("autoheight");
						}
						if (rtl) {
							suffixes.push("rtl");
						}
						if (params.slidesPerColumn > 1) {
							suffixes.push("multirow");
						}
						if (Device.android) {
							suffixes.push("android");
						}
						if (Device.ios) {
							suffixes.push("ios");
						}
						if (
							(Browser.isIE || Browser.isEdge) &&
							(Support.pointerEvents || Support.prefixedPointerEvents)
						) {
							suffixes.push("wp8-" + params.direction);
						}
						suffixes.forEach(function (suffix) {
							classNames.push(params.containerModifierClass + suffix);
						});
						$el.addClass(classNames.join(" "));
					}
					function removeClasses() {
						var swiper = this;
						var $el = swiper.$el;
						var classNames = swiper.classNames;
						$el.removeClass(classNames.join(" "));
					}
					var classes = {
						addClasses: addClasses,
						removeClasses: removeClasses,
					};
					function loadImage(
						imageEl,
						src,
						srcset,
						sizes,
						checkForComplete,
						callback
					) {
						var image;
						function onReady() {
							if (callback) {
								callback();
							}
						}
						if (!imageEl.complete || !checkForComplete) {
							if (src) {
								image = new win.Image();
								image.onload = onReady;
								image.onerror = onReady;
								if (sizes) {
									image.sizes = sizes;
								}
								if (srcset) {
									image.srcset = srcset;
								}
								if (src) {
									image.src = src;
								}
							} else {
								onReady();
							}
						} else {
							onReady();
						}
					}
					function preloadImages() {
						var swiper = this;
						swiper.imagesToLoad = swiper.$el.find("img");
						function onReady() {
							if (
								typeof swiper === "undefined" ||
								swiper === null ||
								!swiper ||
								swiper.destroyed
							) {
								return;
							}
							if (swiper.imagesLoaded !== undefined) {
								swiper.imagesLoaded += 1;
							}
							if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
								if (swiper.params.updateOnImagesReady) {
									swiper.update();
								}
								swiper.emit("imagesReady");
							}
						}
						for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
							var imageEl = swiper.imagesToLoad[i];
							swiper.loadImage(
								imageEl,
								imageEl.currentSrc || imageEl.getAttribute("src"),
								imageEl.srcset || imageEl.getAttribute("srcset"),
								imageEl.sizes || imageEl.getAttribute("sizes"),
								true,
								onReady
							);
						}
					}
					var images = { loadImage: loadImage, preloadImages: preloadImages };
					function checkOverflow() {
						var swiper = this;
						var wasLocked = swiper.isLocked;
						swiper.isLocked = swiper.snapGrid.length === 1;
						swiper.allowSlideNext = !swiper.isLocked;
						swiper.allowSlidePrev = !swiper.isLocked;
						if (wasLocked !== swiper.isLocked) {
							swiper.emit(swiper.isLocked ? "lock" : "unlock");
						}
						if (wasLocked && wasLocked !== swiper.isLocked) {
							swiper.isEnd = false;
							swiper.navigation.update();
						}
					}
					var checkOverflow$1 = { checkOverflow: checkOverflow };
					var defaults = {
						init: true,
						direction: "horizontal",
						touchEventsTarget: "container",
						initialSlide: 0,
						speed: 300,
						preventInteractionOnTransition: false,
						edgeSwipeDetection: false,
						edgeSwipeThreshold: 20,
						freeMode: false,
						freeModeMomentum: true,
						freeModeMomentumRatio: 1,
						freeModeMomentumBounce: true,
						freeModeMomentumBounceRatio: 1,
						freeModeMomentumVelocityRatio: 1,
						freeModeSticky: false,
						freeModeMinimumVelocity: 0.02,
						autoHeight: false,
						setWrapperSize: false,
						virtualTranslate: false,
						effect: "slide",
						breakpoints: undefined,
						breakpointsInverse: false,
						spaceBetween: 0,
						slidesPerView: 1,
						slidesPerColumn: 1,
						slidesPerColumnFill: "column",
						slidesPerGroup: 1,
						centeredSlides: false,
						slidesOffsetBefore: 0,
						slidesOffsetAfter: 0,
						normalizeSlideIndex: true,
						centerInsufficientSlides: false,
						watchOverflow: false,
						roundLengths: false,
						touchRatio: 1,
						touchAngle: 45,
						simulateTouch: true,
						shortSwipes: true,
						longSwipes: true,
						longSwipesRatio: 0.5,
						longSwipesMs: 300,
						followFinger: true,
						allowTouchMove: true,
						threshold: 0,
						touchMoveStopPropagation: true,
						touchStartPreventDefault: true,
						touchStartForcePreventDefault: false,
						touchReleaseOnEdges: false,
						uniqueNavElements: true,
						resistance: true,
						resistanceRatio: 0.85,
						watchSlidesProgress: false,
						watchSlidesVisibility: false,
						grabCursor: false,
						preventClicks: true,
						preventClicksPropagation: true,
						slideToClickedSlide: false,
						preloadImages: true,
						updateOnImagesReady: true,
						loop: false,
						loopAdditionalSlides: 0,
						loopedSlides: null,
						loopFillGroupWithBlank: false,
						allowSlidePrev: true,
						allowSlideNext: true,
						swipeHandler: null,
						noSwiping: true,
						noSwipingClass: "swiper-no-swiping",
						noSwipingSelector: null,
						passiveListeners: true,
						containerModifierClass: "swiper-container-",
						slideClass: "swiper-slide",
						slideBlankClass: "swiper-slide-invisible-blank",
						slideActiveClass: "swiper-slide-active",
						slideDuplicateActiveClass: "swiper-slide-duplicate-active",
						slideVisibleClass: "swiper-slide-visible",
						slideDuplicateClass: "swiper-slide-duplicate",
						slideNextClass: "swiper-slide-next",
						slideDuplicateNextClass: "swiper-slide-duplicate-next",
						slidePrevClass: "swiper-slide-prev",
						slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
						wrapperClass: "swiper-wrapper",
						runCallbacksOnInit: true,
					};
					var prototypes = {
						update: update,
						translate: translate,
						transition: transition$1,
						slide: slide,
						loop: loop,
						grabCursor: grabCursor,
						manipulation: manipulation,
						events: events,
						breakpoints: breakpoints,
						checkOverflow: checkOverflow$1,
						classes: classes,
						images: images,
					};
					var extendedDefaults = {};
					var Swiper = (function (SwiperClass) {
						function Swiper() {
							var assign;
							var args = [],
								len = arguments.length;
							while (len--) args[len] = arguments[len];
							var el;
							var params;
							if (
								args.length === 1 &&
								args[0].constructor &&
								args[0].constructor === Object
							) {
								params = args[0];
							} else {
								(assign = args), (el = assign[0]), (params = assign[1]);
							}
							if (!params) {
								params = {};
							}
							params = Utils.extend({}, params);
							if (el && !params.el) {
								params.el = el;
							}
							SwiperClass.call(this, params);
							Object.keys(prototypes).forEach(function (prototypeGroup) {
								Object.keys(prototypes[prototypeGroup]).forEach(function (
									protoMethod
								) {
									if (!Swiper.prototype[protoMethod]) {
										Swiper.prototype[protoMethod] =
											prototypes[prototypeGroup][protoMethod];
									}
								});
							});
							var swiper = this;
							if (typeof swiper.modules === "undefined") {
								swiper.modules = {};
							}
							Object.keys(swiper.modules).forEach(function (moduleName) {
								var module = swiper.modules[moduleName];
								if (module.params) {
									var moduleParamName = Object.keys(module.params)[0];
									var moduleParams = module.params[moduleParamName];
									if (
										typeof moduleParams !== "object" ||
										moduleParams === null
									) {
										return;
									}
									if (
										!(moduleParamName in params && "enabled" in moduleParams)
									) {
										return;
									}
									if (params[moduleParamName] === true) {
										params[moduleParamName] = { enabled: true };
									}
									if (
										typeof params[moduleParamName] === "object" &&
										!("enabled" in params[moduleParamName])
									) {
										params[moduleParamName].enabled = true;
									}
									if (!params[moduleParamName]) {
										params[moduleParamName] = { enabled: false };
									}
								}
							});
							var swiperParams = Utils.extend({}, defaults);
							swiper.useModulesParams(swiperParams);
							swiper.params = Utils.extend(
								{},
								swiperParams,
								extendedDefaults,
								params
							);
							swiper.originalParams = Utils.extend({}, swiper.params);
							swiper.passedParams = Utils.extend({}, params);
							swiper.$ = $;
							var $el = $(swiper.params.el);
							el = $el[0];
							if (!el) {
								return undefined;
							}
							if ($el.length > 1) {
								var swipers = [];
								$el.each(function (index, containerEl) {
									var newParams = Utils.extend({}, params, { el: containerEl });
									swipers.push(new Swiper(newParams));
								});
								return swipers;
							}
							el.swiper = swiper;
							$el.data("swiper", swiper);
							var $wrapperEl = $el.children("." + swiper.params.wrapperClass);
							Utils.extend(swiper, {
								$el: $el,
								el: el,
								$wrapperEl: $wrapperEl,
								wrapperEl: $wrapperEl[0],
								classNames: [],
								slides: $(),
								slidesGrid: [],
								snapGrid: [],
								slidesSizesGrid: [],
								isHorizontal: function isHorizontal() {
									return swiper.params.direction === "horizontal";
								},
								isVertical: function isVertical() {
									return swiper.params.direction === "vertical";
								},
								rtl:
									el.dir.toLowerCase() === "rtl" ||
									$el.css("direction") === "rtl",
								rtlTranslate:
									swiper.params.direction === "horizontal" &&
									(el.dir.toLowerCase() === "rtl" ||
										$el.css("direction") === "rtl"),
								wrongRTL: $wrapperEl.css("display") === "-webkit-box",
								activeIndex: 0,
								realIndex: 0,
								isBeginning: true,
								isEnd: false,
								translate: 0,
								previousTranslate: 0,
								progress: 0,
								velocity: 0,
								animating: false,
								allowSlideNext: swiper.params.allowSlideNext,
								allowSlidePrev: swiper.params.allowSlidePrev,
								touchEvents: (function touchEvents() {
									var touch = ["touchstart", "touchmove", "touchend"];
									var desktop = ["mousedown", "mousemove", "mouseup"];
									if (Support.pointerEvents) {
										desktop = ["pointerdown", "pointermove", "pointerup"];
									} else if (Support.prefixedPointerEvents) {
										desktop = ["MSPointerDown", "MSPointerMove", "MSPointerUp"];
									}
									swiper.touchEventsTouch = {
										start: touch[0],
										move: touch[1],
										end: touch[2],
									};
									swiper.touchEventsDesktop = {
										start: desktop[0],
										move: desktop[1],
										end: desktop[2],
									};
									return Support.touch || !swiper.params.simulateTouch
										? swiper.touchEventsTouch
										: swiper.touchEventsDesktop;
								})(),
								touchEventsData: {
									isTouched: undefined,
									isMoved: undefined,
									allowTouchCallbacks: undefined,
									touchStartTime: undefined,
									isScrolling: undefined,
									currentTranslate: undefined,
									startTranslate: undefined,
									allowThresholdMove: undefined,
									formElements:
										"input, select, option, textarea, button, video",
									lastClickTime: Utils.now(),
									clickTimeout: undefined,
									velocities: [],
									allowMomentumBounce: undefined,
									isTouchEvent: undefined,
									startMoving: undefined,
								},
								allowClick: true,
								allowTouchMove: swiper.params.allowTouchMove,
								touches: {
									startX: 0,
									startY: 0,
									currentX: 0,
									currentY: 0,
									diff: 0,
								},
								imagesToLoad: [],
								imagesLoaded: 0,
							});
							swiper.useModules();
							if (swiper.params.init) {
								swiper.init();
							}
							return swiper;
						}
						if (SwiperClass) Swiper.__proto__ = SwiperClass;
						Swiper.prototype = Object.create(
							SwiperClass && SwiperClass.prototype
						);
						Swiper.prototype.constructor = Swiper;
						var staticAccessors = {
							extendedDefaults: { configurable: true },
							defaults: { configurable: true },
							Class: { configurable: true },
							$: { configurable: true },
						};
						Swiper.prototype.slidesPerViewDynamic =
							function slidesPerViewDynamic() {
								var swiper = this;
								var params = swiper.params;
								var slides = swiper.slides;
								var slidesGrid = swiper.slidesGrid;
								var swiperSize = swiper.size;
								var activeIndex = swiper.activeIndex;
								var spv = 1;
								if (params.centeredSlides) {
									var slideSize = slides[activeIndex].swiperSlideSize;
									var breakLoop;
									for (var i = activeIndex + 1; i < slides.length; i += 1) {
										if (slides[i] && !breakLoop) {
											slideSize += slides[i].swiperSlideSize;
											spv += 1;
											if (slideSize > swiperSize) {
												breakLoop = true;
											}
										}
									}
									for (var i$1 = activeIndex - 1; i$1 >= 0; i$1 -= 1) {
										if (slides[i$1] && !breakLoop) {
											slideSize += slides[i$1].swiperSlideSize;
											spv += 1;
											if (slideSize > swiperSize) {
												breakLoop = true;
											}
										}
									}
								} else {
									for (
										var i$2 = activeIndex + 1;
										i$2 < slides.length;
										i$2 += 1
									) {
										if (
											slidesGrid[i$2] - slidesGrid[activeIndex] <
											swiperSize
										) {
											spv += 1;
										}
									}
								}
								return spv;
							};
						Swiper.prototype.update = function update() {
							var swiper = this;
							if (!swiper || swiper.destroyed) {
								return;
							}
							var snapGrid = swiper.snapGrid;
							var params = swiper.params;
							if (params.breakpoints) {
								swiper.setBreakpoint();
							}
							swiper.updateSize();
							swiper.updateSlides();
							swiper.updateProgress();
							swiper.updateSlidesClasses();
							function setTranslate() {
								var translateValue = swiper.rtlTranslate
									? swiper.translate * -1
									: swiper.translate;
								var newTranslate = Math.min(
									Math.max(translateValue, swiper.maxTranslate()),
									swiper.minTranslate()
								);
								swiper.setTranslate(newTranslate);
								swiper.updateActiveIndex();
								swiper.updateSlidesClasses();
							}
							var translated;
							if (swiper.params.freeMode) {
								setTranslate();
								if (swiper.params.autoHeight) {
									swiper.updateAutoHeight();
								}
							} else {
								if (
									(swiper.params.slidesPerView === "auto" ||
										swiper.params.slidesPerView > 1) &&
									swiper.isEnd &&
									!swiper.params.centeredSlides
								) {
									translated = swiper.slideTo(
										swiper.slides.length - 1,
										0,
										false,
										true
									);
								} else {
									translated = swiper.slideTo(
										swiper.activeIndex,
										0,
										false,
										true
									);
								}
								if (!translated) {
									setTranslate();
								}
							}
							if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
								swiper.checkOverflow();
							}
							swiper.emit("update");
						};
						Swiper.prototype.changeDirection = function changeDirection(
							newDirection,
							needUpdate
						) {
							if (needUpdate === void 0) needUpdate = true;
							var swiper = this;
							var currentDirection = swiper.params.direction;
							if (!newDirection) {
								newDirection =
									currentDirection === "horizontal" ? "vertical" : "horizontal";
							}
							if (
								newDirection === currentDirection ||
								(newDirection !== "horizontal" && newDirection !== "vertical")
							) {
								return swiper;
							}
							swiper.$el
								.removeClass(
									"" +
										swiper.params.containerModifierClass +
										currentDirection +
										" wp8-" +
										currentDirection
								)
								.addClass(
									"" + swiper.params.containerModifierClass + newDirection
								);
							if (
								(Browser.isIE || Browser.isEdge) &&
								(Support.pointerEvents || Support.prefixedPointerEvents)
							) {
								swiper.$el.addClass(
									swiper.params.containerModifierClass + "wp8-" + newDirection
								);
							}
							swiper.params.direction = newDirection;
							swiper.slides.each(function (slideIndex, slideEl) {
								if (newDirection === "vertical") {
									slideEl.style.width = "";
								} else {
									slideEl.style.height = "";
								}
							});
							swiper.emit("changeDirection");
							if (needUpdate) {
								swiper.update();
							}
							return swiper;
						};
						Swiper.prototype.init = function init() {
							var swiper = this;
							if (swiper.initialized) {
								return;
							}
							swiper.emit("beforeInit");
							if (swiper.params.breakpoints) {
								swiper.setBreakpoint();
							}
							swiper.addClasses();
							if (swiper.params.loop) {
								swiper.loopCreate();
							}
							swiper.updateSize();
							swiper.updateSlides();
							if (swiper.params.watchOverflow) {
								swiper.checkOverflow();
							}
							if (swiper.params.grabCursor) {
								swiper.setGrabCursor();
							}
							if (swiper.params.preloadImages) {
								swiper.preloadImages();
							}
							if (swiper.params.loop) {
								swiper.slideTo(
									swiper.params.initialSlide + swiper.loopedSlides,
									0,
									swiper.params.runCallbacksOnInit
								);
							} else {
								swiper.slideTo(
									swiper.params.initialSlide,
									0,
									swiper.params.runCallbacksOnInit
								);
							}
							swiper.attachEvents();
							swiper.initialized = true;
							swiper.emit("init");
						};
						Swiper.prototype.destroy = function destroy(
							deleteInstance,
							cleanStyles
						) {
							if (deleteInstance === void 0) deleteInstance = true;
							if (cleanStyles === void 0) cleanStyles = true;
							var swiper = this;
							var params = swiper.params;
							var $el = swiper.$el;
							var $wrapperEl = swiper.$wrapperEl;
							var slides = swiper.slides;
							if (typeof swiper.params === "undefined" || swiper.destroyed) {
								return null;
							}
							swiper.emit("beforeDestroy");
							swiper.initialized = false;
							swiper.detachEvents();
							if (params.loop) {
								swiper.loopDestroy();
							}
							if (cleanStyles) {
								swiper.removeClasses();
								$el.removeAttr("style");
								$wrapperEl.removeAttr("style");
								if (slides && slides.length) {
									slides
										.removeClass(
											[
												params.slideVisibleClass,
												params.slideActiveClass,
												params.slideNextClass,
												params.slidePrevClass,
											].join(" ")
										)
										.removeAttr("style")
										.removeAttr("data-swiper-slide-index")
										.removeAttr("data-swiper-column")
										.removeAttr("data-swiper-row");
								}
							}
							swiper.emit("destroy");
							Object.keys(swiper.eventsListeners).forEach(function (eventName) {
								swiper.off(eventName);
							});
							if (deleteInstance !== false) {
								swiper.$el[0].swiper = null;
								swiper.$el.data("swiper", null);
								Utils.deleteProps(swiper);
							}
							swiper.destroyed = true;
							return null;
						};
						Swiper.extendDefaults = function extendDefaults(newDefaults) {
							Utils.extend(extendedDefaults, newDefaults);
						};
						staticAccessors.extendedDefaults.get = function () {
							return extendedDefaults;
						};
						staticAccessors.defaults.get = function () {
							return defaults;
						};
						staticAccessors.Class.get = function () {
							return SwiperClass;
						};
						staticAccessors.$.get = function () {
							return $;
						};
						Object.defineProperties(Swiper, staticAccessors);
						return Swiper;
					})(SwiperClass);
					var Device$1 = {
						name: "device",
						proto: { device: Device },
						static: { device: Device },
					};
					var Support$1 = {
						name: "support",
						proto: { support: Support },
						static: { support: Support },
					};
					var Browser$1 = {
						name: "browser",
						proto: { browser: Browser },
						static: { browser: Browser },
					};
					var Resize = {
						name: "resize",
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								resize: {
									resizeHandler: function resizeHandler() {
										if (!swiper || swiper.destroyed || !swiper.initialized) {
											return;
										}
										swiper.emit("beforeResize");
										swiper.emit("resize");
									},
									orientationChangeHandler:
										function orientationChangeHandler() {
											if (!swiper || swiper.destroyed || !swiper.initialized) {
												return;
											}
											swiper.emit("orientationchange");
										},
								},
							});
						},
						on: {
							init: function init() {
								var swiper = this;
								win.addEventListener("resize", swiper.resize.resizeHandler);
								win.addEventListener(
									"orientationchange",
									swiper.resize.orientationChangeHandler
								);
							},
							destroy: function destroy() {
								var swiper = this;
								win.removeEventListener("resize", swiper.resize.resizeHandler);
								win.removeEventListener(
									"orientationchange",
									swiper.resize.orientationChangeHandler
								);
							},
						},
					};
					var Observer = {
						func: win.MutationObserver || win.WebkitMutationObserver,
						attach: function attach(target, options) {
							if (options === void 0) options = {};
							var swiper = this;
							var ObserverFunc = Observer.func;
							var observer = new ObserverFunc(function (mutations) {
								if (mutations.length === 1) {
									swiper.emit("observerUpdate", mutations[0]);
									return;
								}
								var observerUpdate = function observerUpdate() {
									swiper.emit("observerUpdate", mutations[0]);
								};
								if (win.requestAnimationFrame) {
									win.requestAnimationFrame(observerUpdate);
								} else {
									win.setTimeout(observerUpdate, 0);
								}
							});
							observer.observe(target, {
								attributes:
									typeof options.attributes === "undefined"
										? true
										: options.attributes,
								childList:
									typeof options.childList === "undefined"
										? true
										: options.childList,
								characterData:
									typeof options.characterData === "undefined"
										? true
										: options.characterData,
							});
							swiper.observer.observers.push(observer);
						},
						init: function init() {
							var swiper = this;
							if (!Support.observer || !swiper.params.observer) {
								return;
							}
							if (swiper.params.observeParents) {
								var containerParents = swiper.$el.parents();
								for (var i = 0; i < containerParents.length; i += 1) {
									swiper.observer.attach(containerParents[i]);
								}
							}
							swiper.observer.attach(swiper.$el[0], {
								childList: swiper.params.observeSlideChildren,
							});
							swiper.observer.attach(swiper.$wrapperEl[0], {
								attributes: false,
							});
						},
						destroy: function destroy() {
							var swiper = this;
							swiper.observer.observers.forEach(function (observer) {
								observer.disconnect();
							});
							swiper.observer.observers = [];
						},
					};
					var Observer$1 = {
						name: "observer",
						params: {
							observer: false,
							observeParents: false,
							observeSlideChildren: false,
						},
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								observer: {
									init: Observer.init.bind(swiper),
									attach: Observer.attach.bind(swiper),
									destroy: Observer.destroy.bind(swiper),
									observers: [],
								},
							});
						},
						on: {
							init: function init() {
								var swiper = this;
								swiper.observer.init();
							},
							destroy: function destroy() {
								var swiper = this;
								swiper.observer.destroy();
							},
						},
					};
					var Virtual = {
						update: function update(force) {
							var swiper = this;
							var ref = swiper.params;
							var slidesPerView = ref.slidesPerView;
							var slidesPerGroup = ref.slidesPerGroup;
							var centeredSlides = ref.centeredSlides;
							var ref$1 = swiper.params.virtual;
							var addSlidesBefore = ref$1.addSlidesBefore;
							var addSlidesAfter = ref$1.addSlidesAfter;
							var ref$2 = swiper.virtual;
							var previousFrom = ref$2.from;
							var previousTo = ref$2.to;
							var slides = ref$2.slides;
							var previousSlidesGrid = ref$2.slidesGrid;
							var renderSlide = ref$2.renderSlide;
							var previousOffset = ref$2.offset;
							swiper.updateActiveIndex();
							var activeIndex = swiper.activeIndex || 0;
							var offsetProp;
							if (swiper.rtlTranslate) {
								offsetProp = "right";
							} else {
								offsetProp = swiper.isHorizontal() ? "left" : "top";
							}
							var slidesAfter;
							var slidesBefore;
							if (centeredSlides) {
								slidesAfter =
									Math.floor(slidesPerView / 2) +
									slidesPerGroup +
									addSlidesBefore;
								slidesBefore =
									Math.floor(slidesPerView / 2) +
									slidesPerGroup +
									addSlidesAfter;
							} else {
								slidesAfter =
									slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
								slidesBefore = slidesPerGroup + addSlidesAfter;
							}
							var from = Math.max((activeIndex || 0) - slidesBefore, 0);
							var to = Math.min(
								(activeIndex || 0) + slidesAfter,
								slides.length - 1
							);
							var offset =
								(swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
							Utils.extend(swiper.virtual, {
								from: from,
								to: to,
								offset: offset,
								slidesGrid: swiper.slidesGrid,
							});
							function onRendered() {
								swiper.updateSlides();
								swiper.updateProgress();
								swiper.updateSlidesClasses();
								if (swiper.lazy && swiper.params.lazy.enabled) {
									swiper.lazy.load();
								}
							}
							if (previousFrom === from && previousTo === to && !force) {
								if (
									swiper.slidesGrid !== previousSlidesGrid &&
									offset !== previousOffset
								) {
									swiper.slides.css(offsetProp, offset + "px");
								}
								swiper.updateProgress();
								return;
							}
							if (swiper.params.virtual.renderExternal) {
								swiper.params.virtual.renderExternal.call(swiper, {
									offset: offset,
									from: from,
									to: to,
									slides: (function getSlides() {
										var slidesToRender = [];
										for (var i = from; i <= to; i += 1) {
											slidesToRender.push(slides[i]);
										}
										return slidesToRender;
									})(),
								});
								onRendered();
								return;
							}
							var prependIndexes = [];
							var appendIndexes = [];
							if (force) {
								swiper.$wrapperEl.find("." + swiper.params.slideClass).remove();
							} else {
								for (var i = previousFrom; i <= previousTo; i += 1) {
									if (i < from || i > to) {
										swiper.$wrapperEl
											.find(
												"." +
													swiper.params.slideClass +
													'[data-swiper-slide-index="' +
													i +
													'"]'
											)
											.remove();
									}
								}
							}
							for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
								if (i$1 >= from && i$1 <= to) {
									if (typeof previousTo === "undefined" || force) {
										appendIndexes.push(i$1);
									} else {
										if (i$1 > previousTo) {
											appendIndexes.push(i$1);
										}
										if (i$1 < previousFrom) {
											prependIndexes.push(i$1);
										}
									}
								}
							}
							appendIndexes.forEach(function (index) {
								swiper.$wrapperEl.append(renderSlide(slides[index], index));
							});
							prependIndexes
								.sort(function (a, b) {
									return b - a;
								})
								.forEach(function (index) {
									swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
								});
							swiper.$wrapperEl
								.children(".swiper-slide")
								.css(offsetProp, offset + "px");
							onRendered();
						},
						renderSlide: function renderSlide(slide, index) {
							var swiper = this;
							var params = swiper.params.virtual;
							if (params.cache && swiper.virtual.cache[index]) {
								return swiper.virtual.cache[index];
							}
							var $slideEl = params.renderSlide
								? $(params.renderSlide.call(swiper, slide, index))
								: $(
										'<div class="' +
											swiper.params.slideClass +
											'" data-swiper-slide-index="' +
											index +
											'">' +
											slide +
											"</div>"
								  );
							if (!$slideEl.attr("data-swiper-slide-index")) {
								$slideEl.attr("data-swiper-slide-index", index);
							}
							if (params.cache) {
								swiper.virtual.cache[index] = $slideEl;
							}
							return $slideEl;
						},
						appendSlide: function appendSlide(slides) {
							var swiper = this;
							if (typeof slides === "object" && "length" in slides) {
								for (var i = 0; i < slides.length; i += 1) {
									if (slides[i]) {
										swiper.virtual.slides.push(slides[i]);
									}
								}
							} else {
								swiper.virtual.slides.push(slides);
							}
							swiper.virtual.update(true);
						},
						prependSlide: function prependSlide(slides) {
							var swiper = this;
							var activeIndex = swiper.activeIndex;
							var newActiveIndex = activeIndex + 1;
							var numberOfNewSlides = 1;
							if (Array.isArray(slides)) {
								for (var i = 0; i < slides.length; i += 1) {
									if (slides[i]) {
										swiper.virtual.slides.unshift(slides[i]);
									}
								}
								newActiveIndex = activeIndex + slides.length;
								numberOfNewSlides = slides.length;
							} else {
								swiper.virtual.slides.unshift(slides);
							}
							if (swiper.params.virtual.cache) {
								var cache = swiper.virtual.cache;
								var newCache = {};
								Object.keys(cache).forEach(function (cachedIndex) {
									newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] =
										cache[cachedIndex];
								});
								swiper.virtual.cache = newCache;
							}
							swiper.virtual.update(true);
							swiper.slideTo(newActiveIndex, 0);
						},
						removeSlide: function removeSlide(slidesIndexes) {
							var swiper = this;
							if (
								typeof slidesIndexes === "undefined" ||
								slidesIndexes === null
							) {
								return;
							}
							var activeIndex = swiper.activeIndex;
							if (Array.isArray(slidesIndexes)) {
								for (var i = slidesIndexes.length - 1; i >= 0; i -= 1) {
									swiper.virtual.slides.splice(slidesIndexes[i], 1);
									if (swiper.params.virtual.cache) {
										delete swiper.virtual.cache[slidesIndexes[i]];
									}
									if (slidesIndexes[i] < activeIndex) {
										activeIndex -= 1;
									}
									activeIndex = Math.max(activeIndex, 0);
								}
							} else {
								swiper.virtual.slides.splice(slidesIndexes, 1);
								if (swiper.params.virtual.cache) {
									delete swiper.virtual.cache[slidesIndexes];
								}
								if (slidesIndexes < activeIndex) {
									activeIndex -= 1;
								}
								activeIndex = Math.max(activeIndex, 0);
							}
							swiper.virtual.update(true);
							swiper.slideTo(activeIndex, 0);
						},
						removeAllSlides: function removeAllSlides() {
							var swiper = this;
							swiper.virtual.slides = [];
							if (swiper.params.virtual.cache) {
								swiper.virtual.cache = {};
							}
							swiper.virtual.update(true);
							swiper.slideTo(0, 0);
						},
					};
					var Virtual$1 = {
						name: "virtual",
						params: {
							virtual: {
								enabled: false,
								slides: [],
								cache: true,
								renderSlide: null,
								renderExternal: null,
								addSlidesBefore: 0,
								addSlidesAfter: 0,
							},
						},
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								virtual: {
									update: Virtual.update.bind(swiper),
									appendSlide: Virtual.appendSlide.bind(swiper),
									prependSlide: Virtual.prependSlide.bind(swiper),
									removeSlide: Virtual.removeSlide.bind(swiper),
									removeAllSlides: Virtual.removeAllSlides.bind(swiper),
									renderSlide: Virtual.renderSlide.bind(swiper),
									slides: swiper.params.virtual.slides,
									cache: {},
								},
							});
						},
						on: {
							beforeInit: function beforeInit() {
								var swiper = this;
								if (!swiper.params.virtual.enabled) {
									return;
								}
								swiper.classNames.push(
									swiper.params.containerModifierClass + "virtual"
								);
								var overwriteParams = { watchSlidesProgress: true };
								Utils.extend(swiper.params, overwriteParams);
								Utils.extend(swiper.originalParams, overwriteParams);
								if (!swiper.params.initialSlide) {
									swiper.virtual.update();
								}
							},
							setTranslate: function setTranslate() {
								var swiper = this;
								if (!swiper.params.virtual.enabled) {
									return;
								}
								swiper.virtual.update();
							},
						},
					};
					var Keyboard = {
						handle: function handle(event) {
							var swiper = this;
							var rtl = swiper.rtlTranslate;
							var e = event;
							if (e.originalEvent) {
								e = e.originalEvent;
							}
							var kc = e.keyCode || e.charCode;
							if (
								!swiper.allowSlideNext &&
								((swiper.isHorizontal() && kc === 39) ||
									(swiper.isVertical() && kc === 40) ||
									kc === 34)
							) {
								return false;
							}
							if (
								!swiper.allowSlidePrev &&
								((swiper.isHorizontal() && kc === 37) ||
									(swiper.isVertical() && kc === 38) ||
									kc === 33)
							) {
								return false;
							}
							if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
								return undefined;
							}
							if (
								doc.activeElement &&
								doc.activeElement.nodeName &&
								(doc.activeElement.nodeName.toLowerCase() === "input" ||
									doc.activeElement.nodeName.toLowerCase() === "textarea")
							) {
								return undefined;
							}
							if (
								swiper.params.keyboard.onlyInViewport &&
								(kc === 33 ||
									kc === 34 ||
									kc === 37 ||
									kc === 39 ||
									kc === 38 ||
									kc === 40)
							) {
								var inView = false;
								if (
									swiper.$el.parents("." + swiper.params.slideClass).length >
										0 &&
									swiper.$el.parents("." + swiper.params.slideActiveClass)
										.length === 0
								) {
									return undefined;
								}
								var windowWidth = win.innerWidth;
								var windowHeight = win.innerHeight;
								var swiperOffset = swiper.$el.offset();
								if (rtl) {
									swiperOffset.left -= swiper.$el[0].scrollLeft;
								}
								var swiperCoord = [
									[swiperOffset.left, swiperOffset.top],
									[swiperOffset.left + swiper.width, swiperOffset.top],
									[swiperOffset.left, swiperOffset.top + swiper.height],
									[
										swiperOffset.left + swiper.width,
										swiperOffset.top + swiper.height,
									],
								];
								for (var i = 0; i < swiperCoord.length; i += 1) {
									var point = swiperCoord[i];
									if (
										point[0] >= 0 &&
										point[0] <= windowWidth &&
										point[1] >= 0 &&
										point[1] <= windowHeight
									) {
										inView = true;
									}
								}
								if (!inView) {
									return undefined;
								}
							}
							if (swiper.isHorizontal()) {
								if (kc === 33 || kc === 34 || kc === 37 || kc === 39) {
									if (e.preventDefault) {
										e.preventDefault();
									} else {
										e.returnValue = false;
									}
								}
								if (
									((kc === 34 || kc === 39) && !rtl) ||
									((kc === 33 || kc === 37) && rtl)
								) {
									swiper.slideNext();
								}
								if (
									((kc === 33 || kc === 37) && !rtl) ||
									((kc === 34 || kc === 39) && rtl)
								) {
									swiper.slidePrev();
								}
							} else {
								if (kc === 33 || kc === 34 || kc === 38 || kc === 40) {
									if (e.preventDefault) {
										e.preventDefault();
									} else {
										e.returnValue = false;
									}
								}
								if (kc === 34 || kc === 40) {
									swiper.slideNext();
								}
								if (kc === 33 || kc === 38) {
									swiper.slidePrev();
								}
							}
							swiper.emit("keyPress", kc);
							return undefined;
						},
						enable: function enable() {
							var swiper = this;
							if (swiper.keyboard.enabled) {
								return;
							}
							$(doc).on("keydown", swiper.keyboard.handle);
							swiper.keyboard.enabled = true;
						},
						disable: function disable() {
							var swiper = this;
							if (!swiper.keyboard.enabled) {
								return;
							}
							$(doc).off("keydown", swiper.keyboard.handle);
							swiper.keyboard.enabled = false;
						},
					};
					var Keyboard$1 = {
						name: "keyboard",
						params: { keyboard: { enabled: false, onlyInViewport: true } },
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								keyboard: {
									enabled: false,
									enable: Keyboard.enable.bind(swiper),
									disable: Keyboard.disable.bind(swiper),
									handle: Keyboard.handle.bind(swiper),
								},
							});
						},
						on: {
							init: function init() {
								var swiper = this;
								if (swiper.params.keyboard.enabled) {
									swiper.keyboard.enable();
								}
							},
							destroy: function destroy() {
								var swiper = this;
								if (swiper.keyboard.enabled) {
									swiper.keyboard.disable();
								}
							},
						},
					};
					function isEventSupported() {
						var eventName = "onwheel";
						var isSupported = eventName in doc;
						if (!isSupported) {
							var element = doc.createElement("div");
							element.setAttribute(eventName, "return;");
							isSupported = typeof element[eventName] === "function";
						}
						if (
							!isSupported &&
							doc.implementation &&
							doc.implementation.hasFeature &&
							doc.implementation.hasFeature("", "") !== true
						) {
							isSupported = doc.implementation.hasFeature(
								"Events.wheel",
								"3.0"
							);
						}
						return isSupported;
					}
					var Mousewheel = {
						lastScrollTime: Utils.now(),
						event: (function getEvent() {
							if (win.navigator.userAgent.indexOf("firefox") > -1) {
								return "DOMMouseScroll";
							}
							return isEventSupported() ? "wheel" : "mousewheel";
						})(),
						normalize: function normalize(e) {
							var PIXEL_STEP = 10;
							var LINE_HEIGHT = 40;
							var PAGE_HEIGHT = 800;
							var sX = 0;
							var sY = 0;
							var pX = 0;
							var pY = 0;
							if ("detail" in e) {
								sY = e.detail;
							}
							if ("wheelDelta" in e) {
								sY = -e.wheelDelta / 120;
							}
							if ("wheelDeltaY" in e) {
								sY = -e.wheelDeltaY / 120;
							}
							if ("wheelDeltaX" in e) {
								sX = -e.wheelDeltaX / 120;
							}
							if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
								sX = sY;
								sY = 0;
							}
							pX = sX * PIXEL_STEP;
							pY = sY * PIXEL_STEP;
							if ("deltaY" in e) {
								pY = e.deltaY;
							}
							if ("deltaX" in e) {
								pX = e.deltaX;
							}
							if ((pX || pY) && e.deltaMode) {
								if (e.deltaMode === 1) {
									pX *= LINE_HEIGHT;
									pY *= LINE_HEIGHT;
								} else {
									pX *= PAGE_HEIGHT;
									pY *= PAGE_HEIGHT;
								}
							}
							if (pX && !sX) {
								sX = pX < 1 ? -1 : 1;
							}
							if (pY && !sY) {
								sY = pY < 1 ? -1 : 1;
							}
							return { spinX: sX, spinY: sY, pixelX: pX, pixelY: pY };
						},
						handleMouseEnter: function handleMouseEnter() {
							var swiper = this;
							swiper.mouseEntered = true;
						},
						handleMouseLeave: function handleMouseLeave() {
							var swiper = this;
							swiper.mouseEntered = false;
						},
						handle: function handle(event) {
							var e = event;
							var swiper = this;
							var params = swiper.params.mousewheel;
							if (!swiper.mouseEntered && !params.releaseOnEdges) {
								return true;
							}
							if (e.originalEvent) {
								e = e.originalEvent;
							}
							var delta = 0;
							var rtlFactor = swiper.rtlTranslate ? -1 : 1;
							var data = Mousewheel.normalize(e);
							if (params.forceToAxis) {
								if (swiper.isHorizontal()) {
									if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) {
										delta = data.pixelX * rtlFactor;
									} else {
										return true;
									}
								} else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) {
									delta = data.pixelY;
								} else {
									return true;
								}
							} else {
								delta =
									Math.abs(data.pixelX) > Math.abs(data.pixelY)
										? -data.pixelX * rtlFactor
										: -data.pixelY;
							}
							if (delta === 0) {
								return true;
							}
							if (params.invert) {
								delta = -delta;
							}
							if (!swiper.params.freeMode) {
								if (Utils.now() - swiper.mousewheel.lastScrollTime > 60) {
									if (delta < 0) {
										if (
											(!swiper.isEnd || swiper.params.loop) &&
											!swiper.animating
										) {
											swiper.slideNext();
											swiper.emit("scroll", e);
										} else if (params.releaseOnEdges) {
											return true;
										}
									} else if (
										(!swiper.isBeginning || swiper.params.loop) &&
										!swiper.animating
									) {
										swiper.slidePrev();
										swiper.emit("scroll", e);
									} else if (params.releaseOnEdges) {
										return true;
									}
								}
								swiper.mousewheel.lastScrollTime = new win.Date().getTime();
							} else {
								if (swiper.params.loop) {
									swiper.loopFix();
								}
								var position =
									swiper.getTranslate() + delta * params.sensitivity;
								var wasBeginning = swiper.isBeginning;
								var wasEnd = swiper.isEnd;
								if (position >= swiper.minTranslate()) {
									position = swiper.minTranslate();
								}
								if (position <= swiper.maxTranslate()) {
									position = swiper.maxTranslate();
								}
								swiper.setTransition(0);
								swiper.setTranslate(position);
								swiper.updateProgress();
								swiper.updateActiveIndex();
								swiper.updateSlidesClasses();
								if (
									(!wasBeginning && swiper.isBeginning) ||
									(!wasEnd && swiper.isEnd)
								) {
									swiper.updateSlidesClasses();
								}
								if (swiper.params.freeModeSticky) {
									clearTimeout(swiper.mousewheel.timeout);
									swiper.mousewheel.timeout = Utils.nextTick(function () {
										swiper.slideToClosest();
									}, 300);
								}
								swiper.emit("scroll", e);
								if (
									swiper.params.autoplay &&
									swiper.params.autoplayDisableOnInteraction
								) {
									swiper.autoplay.stop();
								}
								if (
									position === swiper.minTranslate() ||
									position === swiper.maxTranslate()
								) {
									return true;
								}
							}
							if (e.preventDefault) {
								e.preventDefault();
							} else {
								e.returnValue = false;
							}
							return false;
						},
						enable: function enable() {
							var swiper = this;
							if (!Mousewheel.event) {
								return false;
							}
							if (swiper.mousewheel.enabled) {
								return false;
							}
							var target = swiper.$el;
							if (swiper.params.mousewheel.eventsTarged !== "container") {
								target = $(swiper.params.mousewheel.eventsTarged);
							}
							target.on("mouseenter", swiper.mousewheel.handleMouseEnter);
							target.on("mouseleave", swiper.mousewheel.handleMouseLeave);
							target.on(Mousewheel.event, swiper.mousewheel.handle);
							swiper.mousewheel.enabled = true;
							return true;
						},
						disable: function disable() {
							var swiper = this;
							if (!Mousewheel.event) {
								return false;
							}
							if (!swiper.mousewheel.enabled) {
								return false;
							}
							var target = swiper.$el;
							if (swiper.params.mousewheel.eventsTarged !== "container") {
								target = $(swiper.params.mousewheel.eventsTarged);
							}
							target.off(Mousewheel.event, swiper.mousewheel.handle);
							swiper.mousewheel.enabled = false;
							return true;
						},
					};
					var Mousewheel$1 = {
						name: "mousewheel",
						params: {
							mousewheel: {
								enabled: false,
								releaseOnEdges: false,
								invert: false,
								forceToAxis: false,
								sensitivity: 1,
								eventsTarged: "container",
							},
						},
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								mousewheel: {
									enabled: false,
									enable: Mousewheel.enable.bind(swiper),
									disable: Mousewheel.disable.bind(swiper),
									handle: Mousewheel.handle.bind(swiper),
									handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
									handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
									lastScrollTime: Utils.now(),
								},
							});
						},
						on: {
							init: function init() {
								var swiper = this;
								if (swiper.params.mousewheel.enabled) {
									swiper.mousewheel.enable();
								}
							},
							destroy: function destroy() {
								var swiper = this;
								if (swiper.mousewheel.enabled) {
									swiper.mousewheel.disable();
								}
							},
						},
					};
					var Navigation = {
						update: function update() {
							var swiper = this;
							var params = swiper.params.navigation;
							if (swiper.params.loop) {
								return;
							}
							var ref = swiper.navigation;
							var $nextEl = ref.$nextEl;
							var $prevEl = ref.$prevEl;
							if ($prevEl && $prevEl.length > 0) {
								if (swiper.isBeginning) {
									$prevEl.addClass(params.disabledClass);
								} else {
									$prevEl.removeClass(params.disabledClass);
								}
								$prevEl[
									swiper.params.watchOverflow && swiper.isLocked
										? "addClass"
										: "removeClass"
								](params.lockClass);
							}
							if ($nextEl && $nextEl.length > 0) {
								if (swiper.isEnd) {
									$nextEl.addClass(params.disabledClass);
								} else {
									$nextEl.removeClass(params.disabledClass);
								}
								$nextEl[
									swiper.params.watchOverflow && swiper.isLocked
										? "addClass"
										: "removeClass"
								](params.lockClass);
							}
						},
						onPrevClick: function onPrevClick(e) {
							var swiper = this;
							e.preventDefault();
							if (swiper.isBeginning && !swiper.params.loop) {
								return;
							}
							swiper.slidePrev();
						},
						onNextClick: function onNextClick(e) {
							var swiper = this;
							e.preventDefault();
							if (swiper.isEnd && !swiper.params.loop) {
								return;
							}
							swiper.slideNext();
						},
						init: function init() {
							var swiper = this;
							var params = swiper.params.navigation;
							if (!(params.nextEl || params.prevEl)) {
								return;
							}
							var $nextEl;
							var $prevEl;
							if (params.nextEl) {
								$nextEl = $(params.nextEl);
								if (
									swiper.params.uniqueNavElements &&
									typeof params.nextEl === "string" &&
									$nextEl.length > 1 &&
									swiper.$el.find(params.nextEl).length === 1
								) {
									$nextEl = swiper.$el.find(params.nextEl);
								}
							}
							if (params.prevEl) {
								$prevEl = $(params.prevEl);
								if (
									swiper.params.uniqueNavElements &&
									typeof params.prevEl === "string" &&
									$prevEl.length > 1 &&
									swiper.$el.find(params.prevEl).length === 1
								) {
									$prevEl = swiper.$el.find(params.prevEl);
								}
							}
							if ($nextEl && $nextEl.length > 0) {
								$nextEl.on("click", swiper.navigation.onNextClick);
							}
							if ($prevEl && $prevEl.length > 0) {
								$prevEl.on("click", swiper.navigation.onPrevClick);
							}
							Utils.extend(swiper.navigation, {
								$nextEl: $nextEl,
								nextEl: $nextEl && $nextEl[0],
								$prevEl: $prevEl,
								prevEl: $prevEl && $prevEl[0],
							});
						},
						destroy: function destroy() {
							var swiper = this;
							var ref = swiper.navigation;
							var $nextEl = ref.$nextEl;
							var $prevEl = ref.$prevEl;
							if ($nextEl && $nextEl.length) {
								$nextEl.off("click", swiper.navigation.onNextClick);
								$nextEl.removeClass(swiper.params.navigation.disabledClass);
							}
							if ($prevEl && $prevEl.length) {
								$prevEl.off("click", swiper.navigation.onPrevClick);
								$prevEl.removeClass(swiper.params.navigation.disabledClass);
							}
						},
					};
					var Navigation$1 = {
						name: "navigation",
						params: {
							navigation: {
								nextEl: null,
								prevEl: null,
								hideOnClick: false,
								disabledClass: "swiper-button-disabled",
								hiddenClass: "swiper-button-hidden",
								lockClass: "swiper-button-lock",
							},
						},
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								navigation: {
									init: Navigation.init.bind(swiper),
									update: Navigation.update.bind(swiper),
									destroy: Navigation.destroy.bind(swiper),
									onNextClick: Navigation.onNextClick.bind(swiper),
									onPrevClick: Navigation.onPrevClick.bind(swiper),
								},
							});
						},
						on: {
							init: function init() {
								var swiper = this;
								swiper.navigation.init();
								swiper.navigation.update();
							},
							toEdge: function toEdge() {
								var swiper = this;
								swiper.navigation.update();
							},
							fromEdge: function fromEdge() {
								var swiper = this;
								swiper.navigation.update();
							},
							destroy: function destroy() {
								var swiper = this;
								swiper.navigation.destroy();
							},
							click: function click(e) {
								var swiper = this;
								var ref = swiper.navigation;
								var $nextEl = ref.$nextEl;
								var $prevEl = ref.$prevEl;
								if (
									swiper.params.navigation.hideOnClick &&
									!$(e.target).is($prevEl) &&
									!$(e.target).is($nextEl)
								) {
									var isHidden;
									if ($nextEl) {
										isHidden = $nextEl.hasClass(
											swiper.params.navigation.hiddenClass
										);
									} else if ($prevEl) {
										isHidden = $prevEl.hasClass(
											swiper.params.navigation.hiddenClass
										);
									}
									if (isHidden === true) {
										swiper.emit("navigationShow", swiper);
									} else {
										swiper.emit("navigationHide", swiper);
									}
									if ($nextEl) {
										$nextEl.toggleClass(swiper.params.navigation.hiddenClass);
									}
									if ($prevEl) {
										$prevEl.toggleClass(swiper.params.navigation.hiddenClass);
									}
								}
							},
						},
					};
					var Pagination = {
						update: function update() {
							var swiper = this;
							var rtl = swiper.rtl;
							var params = swiper.params.pagination;
							if (
								!params.el ||
								!swiper.pagination.el ||
								!swiper.pagination.$el ||
								swiper.pagination.$el.length === 0
							) {
								return;
							}
							var slidesLength =
								swiper.virtual && swiper.params.virtual.enabled
									? swiper.virtual.slides.length
									: swiper.slides.length;
							var $el = swiper.pagination.$el;
							var current;
							var total = swiper.params.loop
								? Math.ceil(
										(slidesLength - swiper.loopedSlides * 2) /
											swiper.params.slidesPerGroup
								  )
								: swiper.snapGrid.length;
							if (swiper.params.loop) {
								current = Math.ceil(
									(swiper.activeIndex - swiper.loopedSlides) /
										swiper.params.slidesPerGroup
								);
								if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
									current -= slidesLength - swiper.loopedSlides * 2;
								}
								if (current > total - 1) {
									current -= total;
								}
								if (current < 0 && swiper.params.paginationType !== "bullets") {
									current = total + current;
								}
							} else if (typeof swiper.snapIndex !== "undefined") {
								current = swiper.snapIndex;
							} else {
								current = swiper.activeIndex || 0;
							}
							if (
								params.type === "bullets" &&
								swiper.pagination.bullets &&
								swiper.pagination.bullets.length > 0
							) {
								var bullets = swiper.pagination.bullets;
								var firstIndex;
								var lastIndex;
								var midIndex;
								if (params.dynamicBullets) {
									swiper.pagination.bulletSize = bullets
										.eq(0)
										[swiper.isHorizontal() ? "outerWidth" : "outerHeight"](
											true
										);
									$el.css(
										swiper.isHorizontal() ? "width" : "height",
										swiper.pagination.bulletSize *
											(params.dynamicMainBullets + 4) +
											"px"
									);
									if (
										params.dynamicMainBullets > 1 &&
										swiper.previousIndex !== undefined
									) {
										swiper.pagination.dynamicBulletIndex +=
											current - swiper.previousIndex;
										if (
											swiper.pagination.dynamicBulletIndex >
											params.dynamicMainBullets - 1
										) {
											swiper.pagination.dynamicBulletIndex =
												params.dynamicMainBullets - 1;
										} else if (swiper.pagination.dynamicBulletIndex < 0) {
											swiper.pagination.dynamicBulletIndex = 0;
										}
									}
									firstIndex = current - swiper.pagination.dynamicBulletIndex;
									lastIndex =
										firstIndex +
										(Math.min(bullets.length, params.dynamicMainBullets) - 1);
									midIndex = (lastIndex + firstIndex) / 2;
								}
								bullets.removeClass(
									params.bulletActiveClass +
										" " +
										params.bulletActiveClass +
										"-next " +
										params.bulletActiveClass +
										"-next-next " +
										params.bulletActiveClass +
										"-prev " +
										params.bulletActiveClass +
										"-prev-prev " +
										params.bulletActiveClass +
										"-main"
								);
								if ($el.length > 1) {
									bullets.each(function (index, bullet) {
										var $bullet = $(bullet);
										var bulletIndex = $bullet.index();
										if (bulletIndex === current) {
											$bullet.addClass(params.bulletActiveClass);
										}
										if (params.dynamicBullets) {
											if (
												bulletIndex >= firstIndex &&
												bulletIndex <= lastIndex
											) {
												$bullet.addClass(params.bulletActiveClass + "-main");
											}
											if (bulletIndex === firstIndex) {
												$bullet
													.prev()
													.addClass(params.bulletActiveClass + "-prev")
													.prev()
													.addClass(params.bulletActiveClass + "-prev-prev");
											}
											if (bulletIndex === lastIndex) {
												$bullet
													.next()
													.addClass(params.bulletActiveClass + "-next")
													.next()
													.addClass(params.bulletActiveClass + "-next-next");
											}
										}
									});
								} else {
									var $bullet = bullets.eq(current);
									$bullet.addClass(params.bulletActiveClass);
									if (params.dynamicBullets) {
										var $firstDisplayedBullet = bullets.eq(firstIndex);
										var $lastDisplayedBullet = bullets.eq(lastIndex);
										for (var i = firstIndex; i <= lastIndex; i += 1) {
											bullets
												.eq(i)
												.addClass(params.bulletActiveClass + "-main");
										}
										$firstDisplayedBullet
											.prev()
											.addClass(params.bulletActiveClass + "-prev")
											.prev()
											.addClass(params.bulletActiveClass + "-prev-prev");
										$lastDisplayedBullet
											.next()
											.addClass(params.bulletActiveClass + "-next")
											.next()
											.addClass(params.bulletActiveClass + "-next-next");
									}
								}
								if (params.dynamicBullets) {
									var dynamicBulletsLength = Math.min(
										bullets.length,
										params.dynamicMainBullets + 4
									);
									var bulletsOffset =
										(swiper.pagination.bulletSize * dynamicBulletsLength -
											swiper.pagination.bulletSize) /
											2 -
										midIndex * swiper.pagination.bulletSize;
									var offsetProp = rtl ? "right" : "left";
									bullets.css(
										swiper.isHorizontal() ? offsetProp : "top",
										bulletsOffset + "px"
									);
								}
							}
							if (params.type === "fraction") {
								$el
									.find("." + params.currentClass)
									.text(params.formatFractionCurrent(current + 1));
								$el
									.find("." + params.totalClass)
									.text(params.formatFractionTotal(total));
							}
							if (params.type === "progressbar") {
								var progressbarDirection;
								if (params.progressbarOpposite) {
									progressbarDirection = swiper.isHorizontal()
										? "vertical"
										: "horizontal";
								} else {
									progressbarDirection = swiper.isHorizontal()
										? "horizontal"
										: "vertical";
								}
								var scale = (current + 1) / total;
								var scaleX = 1;
								var scaleY = 1;
								if (progressbarDirection === "horizontal") {
									scaleX = scale;
								} else {
									scaleY = scale;
								}
								$el
									.find("." + params.progressbarFillClass)
									.transform(
										"translate3d(0,0,0) scaleX(" +
											scaleX +
											") scaleY(" +
											scaleY +
											")"
									)
									.transition(swiper.params.speed);
							}
							if (params.type === "custom" && params.renderCustom) {
								$el.html(params.renderCustom(swiper, current + 1, total));
								swiper.emit("paginationRender", swiper, $el[0]);
							} else {
								swiper.emit("paginationUpdate", swiper, $el[0]);
							}
							$el[
								swiper.params.watchOverflow && swiper.isLocked
									? "addClass"
									: "removeClass"
							](params.lockClass);
						},
						render: function render() {
							var swiper = this;
							var params = swiper.params.pagination;
							if (
								!params.el ||
								!swiper.pagination.el ||
								!swiper.pagination.$el ||
								swiper.pagination.$el.length === 0
							) {
								return;
							}
							var slidesLength =
								swiper.virtual && swiper.params.virtual.enabled
									? swiper.virtual.slides.length
									: swiper.slides.length;
							var $el = swiper.pagination.$el;
							var paginationHTML = "";
							if (params.type === "bullets") {
								var numberOfBullets = swiper.params.loop
									? Math.ceil(
											(slidesLength - swiper.loopedSlides * 2) /
												swiper.params.slidesPerGroup
									  )
									: swiper.snapGrid.length;
								for (var i = 0; i < numberOfBullets; i += 1) {
									if (params.renderBullet) {
										paginationHTML += params.renderBullet.call(
											swiper,
											i,
											params.bulletClass
										);
									} else {
										paginationHTML +=
											"<" +
											params.bulletElement +
											' class="' +
											params.bulletClass +
											'"></' +
											params.bulletElement +
											">";
									}
								}
								$el.html(paginationHTML);
								swiper.pagination.bullets = $el.find("." + params.bulletClass);
							}
							if (params.type === "fraction") {
								if (params.renderFraction) {
									paginationHTML = params.renderFraction.call(
										swiper,
										params.currentClass,
										params.totalClass
									);
								} else {
									paginationHTML =
										'<span class="' +
										params.currentClass +
										'"></span>' +
										" / " +
										'<span class="' +
										params.totalClass +
										'"></span>';
								}
								$el.html(paginationHTML);
							}
							if (params.type === "progressbar") {
								if (params.renderProgressbar) {
									paginationHTML = params.renderProgressbar.call(
										swiper,
										params.progressbarFillClass
									);
								} else {
									paginationHTML =
										'<span class="' + params.progressbarFillClass + '"></span>';
								}
								$el.html(paginationHTML);
							}
							if (params.type !== "custom") {
								swiper.emit("paginationRender", swiper.pagination.$el[0]);
							}
						},
						init: function init() {
							var swiper = this;
							var params = swiper.params.pagination;
							if (!params.el) {
								return;
							}
							var $el = $(params.el);
							if ($el.length === 0) {
								return;
							}
							if (
								swiper.params.uniqueNavElements &&
								typeof params.el === "string" &&
								$el.length > 1 &&
								swiper.$el.find(params.el).length === 1
							) {
								$el = swiper.$el.find(params.el);
							}
							if (params.type === "bullets" && params.clickable) {
								$el.addClass(params.clickableClass);
							}
							$el.addClass(params.modifierClass + params.type);
							if (params.type === "bullets" && params.dynamicBullets) {
								$el.addClass(
									"" + params.modifierClass + params.type + "-dynamic"
								);
								swiper.pagination.dynamicBulletIndex = 0;
								if (params.dynamicMainBullets < 1) {
									params.dynamicMainBullets = 1;
								}
							}
							if (params.type === "progressbar" && params.progressbarOpposite) {
								$el.addClass(params.progressbarOppositeClass);
							}
							if (params.clickable) {
								$el.on("click", "." + params.bulletClass, function onClick(e) {
									e.preventDefault();
									var index = $(this).index() * swiper.params.slidesPerGroup;
									if (swiper.params.loop) {
										index += swiper.loopedSlides;
									}
									swiper.slideTo(index);
								});
							}
							Utils.extend(swiper.pagination, { $el: $el, el: $el[0] });
						},
						destroy: function destroy() {
							var swiper = this;
							var params = swiper.params.pagination;
							if (
								!params.el ||
								!swiper.pagination.el ||
								!swiper.pagination.$el ||
								swiper.pagination.$el.length === 0
							) {
								return;
							}
							var $el = swiper.pagination.$el;
							$el.removeClass(params.hiddenClass);
							$el.removeClass(params.modifierClass + params.type);
							if (swiper.pagination.bullets) {
								swiper.pagination.bullets.removeClass(params.bulletActiveClass);
							}
							if (params.clickable) {
								$el.off("click", "." + params.bulletClass);
							}
						},
					};
					var Pagination$1 = {
						name: "pagination",
						params: {
							pagination: {
								el: null,
								bulletElement: "span",
								clickable: false,
								hideOnClick: false,
								renderBullet: null,
								renderProgressbar: null,
								renderFraction: null,
								renderCustom: null,
								progressbarOpposite: false,
								type: "bullets",
								dynamicBullets: false,
								dynamicMainBullets: 1,
								formatFractionCurrent: function (number) {
									return number;
								},
								formatFractionTotal: function (number) {
									return number;
								},
								bulletClass: "swiper-pagination-bullet",
								bulletActiveClass: "swiper-pagination-bullet-active",
								modifierClass: "swiper-pagination-",
								currentClass: "swiper-pagination-current",
								totalClass: "swiper-pagination-total",
								hiddenClass: "swiper-pagination-hidden",
								progressbarFillClass: "swiper-pagination-progressbar-fill",
								progressbarOppositeClass:
									"swiper-pagination-progressbar-opposite",
								clickableClass: "swiper-pagination-clickable",
								lockClass: "swiper-pagination-lock",
							},
						},
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								pagination: {
									init: Pagination.init.bind(swiper),
									render: Pagination.render.bind(swiper),
									update: Pagination.update.bind(swiper),
									destroy: Pagination.destroy.bind(swiper),
									dynamicBulletIndex: 0,
								},
							});
						},
						on: {
							init: function init() {
								var swiper = this;
								swiper.pagination.init();
								swiper.pagination.render();
								swiper.pagination.update();
							},
							activeIndexChange: function activeIndexChange() {
								var swiper = this;
								if (swiper.params.loop) {
									swiper.pagination.update();
								} else if (typeof swiper.snapIndex === "undefined") {
									swiper.pagination.update();
								}
							},
							snapIndexChange: function snapIndexChange() {
								var swiper = this;
								if (!swiper.params.loop) {
									swiper.pagination.update();
								}
							},
							slidesLengthChange: function slidesLengthChange() {
								var swiper = this;
								if (swiper.params.loop) {
									swiper.pagination.render();
									swiper.pagination.update();
								}
							},
							snapGridLengthChange: function snapGridLengthChange() {
								var swiper = this;
								if (!swiper.params.loop) {
									swiper.pagination.render();
									swiper.pagination.update();
								}
							},
							destroy: function destroy() {
								var swiper = this;
								swiper.pagination.destroy();
							},
							click: function click(e) {
								var swiper = this;
								if (
									swiper.params.pagination.el &&
									swiper.params.pagination.hideOnClick &&
									swiper.pagination.$el.length > 0 &&
									!$(e.target).hasClass(swiper.params.pagination.bulletClass)
								) {
									var isHidden = swiper.pagination.$el.hasClass(
										swiper.params.pagination.hiddenClass
									);
									if (isHidden === true) {
										swiper.emit("paginationShow", swiper);
									} else {
										swiper.emit("paginationHide", swiper);
									}
									swiper.pagination.$el.toggleClass(
										swiper.params.pagination.hiddenClass
									);
								}
							},
						},
					};
					var Scrollbar = {
						setTranslate: function setTranslate() {
							var swiper = this;
							if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
								return;
							}
							var scrollbar = swiper.scrollbar;
							var rtl = swiper.rtlTranslate;
							var progress = swiper.progress;
							var dragSize = scrollbar.dragSize;
							var trackSize = scrollbar.trackSize;
							var $dragEl = scrollbar.$dragEl;
							var $el = scrollbar.$el;
							var params = swiper.params.scrollbar;
							var newSize = dragSize;
							var newPos = (trackSize - dragSize) * progress;
							if (rtl) {
								newPos = -newPos;
								if (newPos > 0) {
									newSize = dragSize - newPos;
									newPos = 0;
								} else if (-newPos + dragSize > trackSize) {
									newSize = trackSize + newPos;
								}
							} else if (newPos < 0) {
								newSize = dragSize + newPos;
								newPos = 0;
							} else if (newPos + dragSize > trackSize) {
								newSize = trackSize - newPos;
							}
							if (swiper.isHorizontal()) {
								if (Support.transforms3d) {
									$dragEl.transform("translate3d(" + newPos + "px, 0, 0)");
								} else {
									$dragEl.transform("translateX(" + newPos + "px)");
								}
								$dragEl[0].style.width = newSize + "px";
							} else {
								if (Support.transforms3d) {
									$dragEl.transform("translate3d(0px, " + newPos + "px, 0)");
								} else {
									$dragEl.transform("translateY(" + newPos + "px)");
								}
								$dragEl[0].style.height = newSize + "px";
							}
							if (params.hide) {
								clearTimeout(swiper.scrollbar.timeout);
								$el[0].style.opacity = 1;
								swiper.scrollbar.timeout = setTimeout(function () {
									$el[0].style.opacity = 0;
									$el.transition(400);
								}, 1e3);
							}
						},
						setTransition: function setTransition(duration) {
							var swiper = this;
							if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
								return;
							}
							swiper.scrollbar.$dragEl.transition(duration);
						},
						updateSize: function updateSize() {
							var swiper = this;
							if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
								return;
							}
							var scrollbar = swiper.scrollbar;
							var $dragEl = scrollbar.$dragEl;
							var $el = scrollbar.$el;
							$dragEl[0].style.width = "";
							$dragEl[0].style.height = "";
							var trackSize = swiper.isHorizontal()
								? $el[0].offsetWidth
								: $el[0].offsetHeight;
							var divider = swiper.size / swiper.virtualSize;
							var moveDivider = divider * (trackSize / swiper.size);
							var dragSize;
							if (swiper.params.scrollbar.dragSize === "auto") {
								dragSize = trackSize * divider;
							} else {
								dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
							}
							if (swiper.isHorizontal()) {
								$dragEl[0].style.width = dragSize + "px";
							} else {
								$dragEl[0].style.height = dragSize + "px";
							}
							if (divider >= 1) {
								$el[0].style.display = "none";
							} else {
								$el[0].style.display = "";
							}
							if (swiper.params.scrollbar.hide) {
								$el[0].style.opacity = 0;
							}
							Utils.extend(scrollbar, {
								trackSize: trackSize,
								divider: divider,
								moveDivider: moveDivider,
								dragSize: dragSize,
							});
							scrollbar.$el[
								swiper.params.watchOverflow && swiper.isLocked
									? "addClass"
									: "removeClass"
							](swiper.params.scrollbar.lockClass);
						},
						getPointerPosition: function getPointerPosition(e) {
							var swiper = this;
							if (swiper.isHorizontal()) {
								return e.type === "touchstart" || e.type === "touchmove"
									? e.targetTouches[0].pageX
									: e.pageX || e.clientX;
							}
							return e.type === "touchstart" || e.type === "touchmove"
								? e.targetTouches[0].pageY
								: e.pageY || e.clientY;
						},
						setDragPosition: function setDragPosition(e) {
							var swiper = this;
							var scrollbar = swiper.scrollbar;
							var rtl = swiper.rtlTranslate;
							var $el = scrollbar.$el;
							var dragSize = scrollbar.dragSize;
							var trackSize = scrollbar.trackSize;
							var dragStartPos = scrollbar.dragStartPos;
							var positionRatio;
							positionRatio =
								(scrollbar.getPointerPosition(e) -
									$el.offset()[swiper.isHorizontal() ? "left" : "top"] -
									(dragStartPos !== null ? dragStartPos : dragSize / 2)) /
								(trackSize - dragSize);
							positionRatio = Math.max(Math.min(positionRatio, 1), 0);
							if (rtl) {
								positionRatio = 1 - positionRatio;
							}
							var position =
								swiper.minTranslate() +
								(swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
							swiper.updateProgress(position);
							swiper.setTranslate(position);
							swiper.updateActiveIndex();
							swiper.updateSlidesClasses();
						},
						onDragStart: function onDragStart(e) {
							var swiper = this;
							var params = swiper.params.scrollbar;
							var scrollbar = swiper.scrollbar;
							var $wrapperEl = swiper.$wrapperEl;
							var $el = scrollbar.$el;
							var $dragEl = scrollbar.$dragEl;
							swiper.scrollbar.isTouched = true;
							swiper.scrollbar.dragStartPos =
								e.target === $dragEl[0] || e.target === $dragEl
									? scrollbar.getPointerPosition(e) -
									  e.target.getBoundingClientRect()[
											swiper.isHorizontal() ? "left" : "top"
									  ]
									: null;
							e.preventDefault();
							e.stopPropagation();
							$wrapperEl.transition(100);
							$dragEl.transition(100);
							scrollbar.setDragPosition(e);
							clearTimeout(swiper.scrollbar.dragTimeout);
							$el.transition(0);
							if (params.hide) {
								$el.css("opacity", 1);
							}
							swiper.emit("scrollbarDragStart", e);
						},
						onDragMove: function onDragMove(e) {
							var swiper = this;
							var scrollbar = swiper.scrollbar;
							var $wrapperEl = swiper.$wrapperEl;
							var $el = scrollbar.$el;
							var $dragEl = scrollbar.$dragEl;
							if (!swiper.scrollbar.isTouched) {
								return;
							}
							if (e.preventDefault) {
								e.preventDefault();
							} else {
								e.returnValue = false;
							}
							scrollbar.setDragPosition(e);
							$wrapperEl.transition(0);
							$el.transition(0);
							$dragEl.transition(0);
							swiper.emit("scrollbarDragMove", e);
						},
						onDragEnd: function onDragEnd(e) {
							var swiper = this;
							var params = swiper.params.scrollbar;
							var scrollbar = swiper.scrollbar;
							var $el = scrollbar.$el;
							if (!swiper.scrollbar.isTouched) {
								return;
							}
							swiper.scrollbar.isTouched = false;
							if (params.hide) {
								clearTimeout(swiper.scrollbar.dragTimeout);
								swiper.scrollbar.dragTimeout = Utils.nextTick(function () {
									$el.css("opacity", 0);
									$el.transition(400);
								}, 1e3);
							}
							swiper.emit("scrollbarDragEnd", e);
							if (params.snapOnRelease) {
								swiper.slideToClosest();
							}
						},
						enableDraggable: function enableDraggable() {
							var swiper = this;
							if (!swiper.params.scrollbar.el) {
								return;
							}
							var scrollbar = swiper.scrollbar;
							var touchEventsTouch = swiper.touchEventsTouch;
							var touchEventsDesktop = swiper.touchEventsDesktop;
							var params = swiper.params;
							var $el = scrollbar.$el;
							var target = $el[0];
							var activeListener =
								Support.passiveListener && params.passiveListeners
									? { passive: false, capture: false }
									: false;
							var passiveListener =
								Support.passiveListener && params.passiveListeners
									? { passive: true, capture: false }
									: false;
							if (!Support.touch) {
								target.addEventListener(
									touchEventsDesktop.start,
									swiper.scrollbar.onDragStart,
									activeListener
								);
								doc.addEventListener(
									touchEventsDesktop.move,
									swiper.scrollbar.onDragMove,
									activeListener
								);
								doc.addEventListener(
									touchEventsDesktop.end,
									swiper.scrollbar.onDragEnd,
									passiveListener
								);
							} else {
								target.addEventListener(
									touchEventsTouch.start,
									swiper.scrollbar.onDragStart,
									activeListener
								);
								target.addEventListener(
									touchEventsTouch.move,
									swiper.scrollbar.onDragMove,
									activeListener
								);
								target.addEventListener(
									touchEventsTouch.end,
									swiper.scrollbar.onDragEnd,
									passiveListener
								);
							}
						},
						disableDraggable: function disableDraggable() {
							var swiper = this;
							if (!swiper.params.scrollbar.el) {
								return;
							}
							var scrollbar = swiper.scrollbar;
							var touchEventsTouch = swiper.touchEventsTouch;
							var touchEventsDesktop = swiper.touchEventsDesktop;
							var params = swiper.params;
							var $el = scrollbar.$el;
							var target = $el[0];
							var activeListener =
								Support.passiveListener && params.passiveListeners
									? { passive: false, capture: false }
									: false;
							var passiveListener =
								Support.passiveListener && params.passiveListeners
									? { passive: true, capture: false }
									: false;
							if (!Support.touch) {
								target.removeEventListener(
									touchEventsDesktop.start,
									swiper.scrollbar.onDragStart,
									activeListener
								);
								doc.removeEventListener(
									touchEventsDesktop.move,
									swiper.scrollbar.onDragMove,
									activeListener
								);
								doc.removeEventListener(
									touchEventsDesktop.end,
									swiper.scrollbar.onDragEnd,
									passiveListener
								);
							} else {
								target.removeEventListener(
									touchEventsTouch.start,
									swiper.scrollbar.onDragStart,
									activeListener
								);
								target.removeEventListener(
									touchEventsTouch.move,
									swiper.scrollbar.onDragMove,
									activeListener
								);
								target.removeEventListener(
									touchEventsTouch.end,
									swiper.scrollbar.onDragEnd,
									passiveListener
								);
							}
						},
						init: function init() {
							var swiper = this;
							if (!swiper.params.scrollbar.el) {
								return;
							}
							var scrollbar = swiper.scrollbar;
							var $swiperEl = swiper.$el;
							var params = swiper.params.scrollbar;
							var $el = $(params.el);
							if (
								swiper.params.uniqueNavElements &&
								typeof params.el === "string" &&
								$el.length > 1 &&
								$swiperEl.find(params.el).length === 1
							) {
								$el = $swiperEl.find(params.el);
							}
							var $dragEl = $el.find("." + swiper.params.scrollbar.dragClass);
							if ($dragEl.length === 0) {
								$dragEl = $(
									'<div class="' +
										swiper.params.scrollbar.dragClass +
										'"></div>'
								);
								$el.append($dragEl);
							}
							Utils.extend(scrollbar, {
								$el: $el,
								el: $el[0],
								$dragEl: $dragEl,
								dragEl: $dragEl[0],
							});
							if (params.draggable) {
								scrollbar.enableDraggable();
							}
						},
						destroy: function destroy() {
							var swiper = this;
							swiper.scrollbar.disableDraggable();
						},
					};
					var Scrollbar$1 = {
						name: "scrollbar",
						params: {
							scrollbar: {
								el: null,
								dragSize: "auto",
								hide: false,
								draggable: false,
								snapOnRelease: true,
								lockClass: "swiper-scrollbar-lock",
								dragClass: "swiper-scrollbar-drag",
							},
						},
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								scrollbar: {
									init: Scrollbar.init.bind(swiper),
									destroy: Scrollbar.destroy.bind(swiper),
									updateSize: Scrollbar.updateSize.bind(swiper),
									setTranslate: Scrollbar.setTranslate.bind(swiper),
									setTransition: Scrollbar.setTransition.bind(swiper),
									enableDraggable: Scrollbar.enableDraggable.bind(swiper),
									disableDraggable: Scrollbar.disableDraggable.bind(swiper),
									setDragPosition: Scrollbar.setDragPosition.bind(swiper),
									getPointerPosition: Scrollbar.getPointerPosition.bind(swiper),
									onDragStart: Scrollbar.onDragStart.bind(swiper),
									onDragMove: Scrollbar.onDragMove.bind(swiper),
									onDragEnd: Scrollbar.onDragEnd.bind(swiper),
									isTouched: false,
									timeout: null,
									dragTimeout: null,
								},
							});
						},
						on: {
							init: function init() {
								var swiper = this;
								swiper.scrollbar.init();
								swiper.scrollbar.updateSize();
								swiper.scrollbar.setTranslate();
							},
							update: function update() {
								var swiper = this;
								swiper.scrollbar.updateSize();
							},
							resize: function resize() {
								var swiper = this;
								swiper.scrollbar.updateSize();
							},
							observerUpdate: function observerUpdate() {
								var swiper = this;
								swiper.scrollbar.updateSize();
							},
							setTranslate: function setTranslate() {
								var swiper = this;
								swiper.scrollbar.setTranslate();
							},
							setTransition: function setTransition(duration) {
								var swiper = this;
								swiper.scrollbar.setTransition(duration);
							},
							destroy: function destroy() {
								var swiper = this;
								swiper.scrollbar.destroy();
							},
						},
					};
					var Parallax = {
						setTransform: function setTransform(el, progress) {
							var swiper = this;
							var rtl = swiper.rtl;
							var $el = $(el);
							var rtlFactor = rtl ? -1 : 1;
							var p = $el.attr("data-swiper-parallax") || "0";
							var x = $el.attr("data-swiper-parallax-x");
							var y = $el.attr("data-swiper-parallax-y");
							var scale = $el.attr("data-swiper-parallax-scale");
							var opacity = $el.attr("data-swiper-parallax-opacity");
							if (x || y) {
								x = x || "0";
								y = y || "0";
							} else if (swiper.isHorizontal()) {
								x = p;
								y = "0";
							} else {
								y = p;
								x = "0";
							}
							if (x.indexOf("%") >= 0) {
								x = parseInt(x, 10) * progress * rtlFactor + "%";
							} else {
								x = x * progress * rtlFactor + "px";
							}
							if (y.indexOf("%") >= 0) {
								y = parseInt(y, 10) * progress + "%";
							} else {
								y = y * progress + "px";
							}
							if (typeof opacity !== "undefined" && opacity !== null) {
								var currentOpacity =
									opacity - (opacity - 1) * (1 - Math.abs(progress));
								$el[0].style.opacity = currentOpacity;
							}
							if (typeof scale === "undefined" || scale === null) {
								$el.transform("translate3d(" + x + ", " + y + ", 0px)");
							} else {
								var currentScale =
									scale - (scale - 1) * (1 - Math.abs(progress));
								$el.transform(
									"translate3d(" +
										x +
										", " +
										y +
										", 0px) scale(" +
										currentScale +
										")"
								);
							}
						},
						setTranslate: function setTranslate() {
							var swiper = this;
							var $el = swiper.$el;
							var slides = swiper.slides;
							var progress = swiper.progress;
							var snapGrid = swiper.snapGrid;
							$el
								.children(
									"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]"
								)
								.each(function (index, el) {
									swiper.parallax.setTransform(el, progress);
								});
							slides.each(function (slideIndex, slideEl) {
								var slideProgress = slideEl.progress;
								if (
									swiper.params.slidesPerGroup > 1 &&
									swiper.params.slidesPerView !== "auto"
								) {
									slideProgress +=
										Math.ceil(slideIndex / 2) -
										progress * (snapGrid.length - 1);
								}
								slideProgress = Math.min(Math.max(slideProgress, -1), 1);
								$(slideEl)
									.find(
										"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]"
									)
									.each(function (index, el) {
										swiper.parallax.setTransform(el, slideProgress);
									});
							});
						},
						setTransition: function setTransition(duration) {
							if (duration === void 0) duration = this.params.speed;
							var swiper = this;
							var $el = swiper.$el;
							$el
								.find(
									"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]"
								)
								.each(function (index, parallaxEl) {
									var $parallaxEl = $(parallaxEl);
									var parallaxDuration =
										parseInt(
											$parallaxEl.attr("data-swiper-parallax-duration"),
											10
										) || duration;
									if (duration === 0) {
										parallaxDuration = 0;
									}
									$parallaxEl.transition(parallaxDuration);
								});
						},
					};
					var Parallax$1 = {
						name: "parallax",
						params: { parallax: { enabled: false } },
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								parallax: {
									setTransform: Parallax.setTransform.bind(swiper),
									setTranslate: Parallax.setTranslate.bind(swiper),
									setTransition: Parallax.setTransition.bind(swiper),
								},
							});
						},
						on: {
							beforeInit: function beforeInit() {
								var swiper = this;
								if (!swiper.params.parallax.enabled) {
									return;
								}
								swiper.params.watchSlidesProgress = true;
								swiper.originalParams.watchSlidesProgress = true;
							},
							init: function init() {
								var swiper = this;
								if (!swiper.params.parallax.enabled) {
									return;
								}
								swiper.parallax.setTranslate();
							},
							setTranslate: function setTranslate() {
								var swiper = this;
								if (!swiper.params.parallax.enabled) {
									return;
								}
								swiper.parallax.setTranslate();
							},
							setTransition: function setTransition(duration) {
								var swiper = this;
								if (!swiper.params.parallax.enabled) {
									return;
								}
								swiper.parallax.setTransition(duration);
							},
						},
					};
					var Zoom = {
						getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
							if (e.targetTouches.length < 2) {
								return 1;
							}
							var x1 = e.targetTouches[0].pageX;
							var y1 = e.targetTouches[0].pageY;
							var x2 = e.targetTouches[1].pageX;
							var y2 = e.targetTouches[1].pageY;
							var distance = Math.sqrt(
								Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)
							);
							return distance;
						},
						onGestureStart: function onGestureStart(e) {
							var swiper = this;
							var params = swiper.params.zoom;
							var zoom = swiper.zoom;
							var gesture = zoom.gesture;
							zoom.fakeGestureTouched = false;
							zoom.fakeGestureMoved = false;
							if (!Support.gestures) {
								if (
									e.type !== "touchstart" ||
									(e.type === "touchstart" && e.targetTouches.length < 2)
								) {
									return;
								}
								zoom.fakeGestureTouched = true;
								gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
							}
							if (!gesture.$slideEl || !gesture.$slideEl.length) {
								gesture.$slideEl = $(e.target).closest(".swiper-slide");
								if (gesture.$slideEl.length === 0) {
									gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
								}
								gesture.$imageEl = gesture.$slideEl.find("img, svg, canvas");
								gesture.$imageWrapEl = gesture.$imageEl.parent(
									"." + params.containerClass
								);
								gesture.maxRatio =
									gesture.$imageWrapEl.attr("data-swiper-zoom") ||
									params.maxRatio;
								if (gesture.$imageWrapEl.length === 0) {
									gesture.$imageEl = undefined;
									return;
								}
							}
							gesture.$imageEl.transition(0);
							swiper.zoom.isScaling = true;
						},
						onGestureChange: function onGestureChange(e) {
							var swiper = this;
							var params = swiper.params.zoom;
							var zoom = swiper.zoom;
							var gesture = zoom.gesture;
							if (!Support.gestures) {
								if (
									e.type !== "touchmove" ||
									(e.type === "touchmove" && e.targetTouches.length < 2)
								) {
									return;
								}
								zoom.fakeGestureMoved = true;
								gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
							}
							if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
								return;
							}
							if (Support.gestures) {
								zoom.scale = e.scale * zoom.currentScale;
							} else {
								zoom.scale =
									(gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
							}
							if (zoom.scale > gesture.maxRatio) {
								zoom.scale =
									gesture.maxRatio -
									1 +
									Math.pow(zoom.scale - gesture.maxRatio + 1, 0.5);
							}
							if (zoom.scale < params.minRatio) {
								zoom.scale =
									params.minRatio +
									1 -
									Math.pow(params.minRatio - zoom.scale + 1, 0.5);
							}
							gesture.$imageEl.transform(
								"translate3d(0,0,0) scale(" + zoom.scale + ")"
							);
						},
						onGestureEnd: function onGestureEnd(e) {
							var swiper = this;
							var params = swiper.params.zoom;
							var zoom = swiper.zoom;
							var gesture = zoom.gesture;
							if (!Support.gestures) {
								if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
									return;
								}
								if (
									e.type !== "touchend" ||
									(e.type === "touchend" &&
										e.changedTouches.length < 2 &&
										!Device.android)
								) {
									return;
								}
								zoom.fakeGestureTouched = false;
								zoom.fakeGestureMoved = false;
							}
							if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
								return;
							}
							zoom.scale = Math.max(
								Math.min(zoom.scale, gesture.maxRatio),
								params.minRatio
							);
							gesture.$imageEl
								.transition(swiper.params.speed)
								.transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
							zoom.currentScale = zoom.scale;
							zoom.isScaling = false;
							if (zoom.scale === 1) {
								gesture.$slideEl = undefined;
							}
						},
						onTouchStart: function onTouchStart(e) {
							var swiper = this;
							var zoom = swiper.zoom;
							var gesture = zoom.gesture;
							var image = zoom.image;
							if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
								return;
							}
							if (image.isTouched) {
								return;
							}
							if (Device.android) {
								e.preventDefault();
							}
							image.isTouched = true;
							image.touchesStart.x =
								e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
							image.touchesStart.y =
								e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
						},
						onTouchMove: function onTouchMove(e) {
							var swiper = this;
							var zoom = swiper.zoom;
							var gesture = zoom.gesture;
							var image = zoom.image;
							var velocity = zoom.velocity;
							if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
								return;
							}
							swiper.allowClick = false;
							if (!image.isTouched || !gesture.$slideEl) {
								return;
							}
							if (!image.isMoved) {
								image.width = gesture.$imageEl[0].offsetWidth;
								image.height = gesture.$imageEl[0].offsetHeight;
								image.startX =
									Utils.getTranslate(gesture.$imageWrapEl[0], "x") || 0;
								image.startY =
									Utils.getTranslate(gesture.$imageWrapEl[0], "y") || 0;
								gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
								gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
								gesture.$imageWrapEl.transition(0);
								if (swiper.rtl) {
									image.startX = -image.startX;
									image.startY = -image.startY;
								}
							}
							var scaledWidth = image.width * zoom.scale;
							var scaledHeight = image.height * zoom.scale;
							if (
								scaledWidth < gesture.slideWidth &&
								scaledHeight < gesture.slideHeight
							) {
								return;
							}
							image.minX = Math.min(
								gesture.slideWidth / 2 - scaledWidth / 2,
								0
							);
							image.maxX = -image.minX;
							image.minY = Math.min(
								gesture.slideHeight / 2 - scaledHeight / 2,
								0
							);
							image.maxY = -image.minY;
							image.touchesCurrent.x =
								e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
							image.touchesCurrent.y =
								e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
							if (!image.isMoved && !zoom.isScaling) {
								if (
									swiper.isHorizontal() &&
									((Math.floor(image.minX) === Math.floor(image.startX) &&
										image.touchesCurrent.x < image.touchesStart.x) ||
										(Math.floor(image.maxX) === Math.floor(image.startX) &&
											image.touchesCurrent.x > image.touchesStart.x))
								) {
									image.isTouched = false;
									return;
								}
								if (
									!swiper.isHorizontal() &&
									((Math.floor(image.minY) === Math.floor(image.startY) &&
										image.touchesCurrent.y < image.touchesStart.y) ||
										(Math.floor(image.maxY) === Math.floor(image.startY) &&
											image.touchesCurrent.y > image.touchesStart.y))
								) {
									image.isTouched = false;
									return;
								}
							}
							e.preventDefault();
							e.stopPropagation();
							image.isMoved = true;
							image.currentX =
								image.touchesCurrent.x - image.touchesStart.x + image.startX;
							image.currentY =
								image.touchesCurrent.y - image.touchesStart.y + image.startY;
							if (image.currentX < image.minX) {
								image.currentX =
									image.minX +
									1 -
									Math.pow(image.minX - image.currentX + 1, 0.8);
							}
							if (image.currentX > image.maxX) {
								image.currentX =
									image.maxX -
									1 +
									Math.pow(image.currentX - image.maxX + 1, 0.8);
							}
							if (image.currentY < image.minY) {
								image.currentY =
									image.minY +
									1 -
									Math.pow(image.minY - image.currentY + 1, 0.8);
							}
							if (image.currentY > image.maxY) {
								image.currentY =
									image.maxY -
									1 +
									Math.pow(image.currentY - image.maxY + 1, 0.8);
							}
							if (!velocity.prevPositionX) {
								velocity.prevPositionX = image.touchesCurrent.x;
							}
							if (!velocity.prevPositionY) {
								velocity.prevPositionY = image.touchesCurrent.y;
							}
							if (!velocity.prevTime) {
								velocity.prevTime = Date.now();
							}
							velocity.x =
								(image.touchesCurrent.x - velocity.prevPositionX) /
								(Date.now() - velocity.prevTime) /
								2;
							velocity.y =
								(image.touchesCurrent.y - velocity.prevPositionY) /
								(Date.now() - velocity.prevTime) /
								2;
							if (
								Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2
							) {
								velocity.x = 0;
							}
							if (
								Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2
							) {
								velocity.y = 0;
							}
							velocity.prevPositionX = image.touchesCurrent.x;
							velocity.prevPositionY = image.touchesCurrent.y;
							velocity.prevTime = Date.now();
							gesture.$imageWrapEl.transform(
								"translate3d(" +
									image.currentX +
									"px, " +
									image.currentY +
									"px,0)"
							);
						},
						onTouchEnd: function onTouchEnd() {
							var swiper = this;
							var zoom = swiper.zoom;
							var gesture = zoom.gesture;
							var image = zoom.image;
							var velocity = zoom.velocity;
							if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
								return;
							}
							if (!image.isTouched || !image.isMoved) {
								image.isTouched = false;
								image.isMoved = false;
								return;
							}
							image.isTouched = false;
							image.isMoved = false;
							var momentumDurationX = 300;
							var momentumDurationY = 300;
							var momentumDistanceX = velocity.x * momentumDurationX;
							var newPositionX = image.currentX + momentumDistanceX;
							var momentumDistanceY = velocity.y * momentumDurationY;
							var newPositionY = image.currentY + momentumDistanceY;
							if (velocity.x !== 0) {
								momentumDurationX = Math.abs(
									(newPositionX - image.currentX) / velocity.x
								);
							}
							if (velocity.y !== 0) {
								momentumDurationY = Math.abs(
									(newPositionY - image.currentY) / velocity.y
								);
							}
							var momentumDuration = Math.max(
								momentumDurationX,
								momentumDurationY
							);
							image.currentX = newPositionX;
							image.currentY = newPositionY;
							var scaledWidth = image.width * zoom.scale;
							var scaledHeight = image.height * zoom.scale;
							image.minX = Math.min(
								gesture.slideWidth / 2 - scaledWidth / 2,
								0
							);
							image.maxX = -image.minX;
							image.minY = Math.min(
								gesture.slideHeight / 2 - scaledHeight / 2,
								0
							);
							image.maxY = -image.minY;
							image.currentX = Math.max(
								Math.min(image.currentX, image.maxX),
								image.minX
							);
							image.currentY = Math.max(
								Math.min(image.currentY, image.maxY),
								image.minY
							);
							gesture.$imageWrapEl
								.transition(momentumDuration)
								.transform(
									"translate3d(" +
										image.currentX +
										"px, " +
										image.currentY +
										"px,0)"
								);
						},
						onTransitionEnd: function onTransitionEnd() {
							var swiper = this;
							var zoom = swiper.zoom;
							var gesture = zoom.gesture;
							if (
								gesture.$slideEl &&
								swiper.previousIndex !== swiper.activeIndex
							) {
								gesture.$imageEl.transform("translate3d(0,0,0) scale(1)");
								gesture.$imageWrapEl.transform("translate3d(0,0,0)");
								zoom.scale = 1;
								zoom.currentScale = 1;
								gesture.$slideEl = undefined;
								gesture.$imageEl = undefined;
								gesture.$imageWrapEl = undefined;
							}
						},
						toggle: function toggle(e) {
							var swiper = this;
							var zoom = swiper.zoom;
							if (zoom.scale && zoom.scale !== 1) {
								zoom.out();
							} else {
								zoom.in(e);
							}
						},
						in: function in$1(e) {
							var swiper = this;
							var zoom = swiper.zoom;
							var params = swiper.params.zoom;
							var gesture = zoom.gesture;
							var image = zoom.image;
							if (!gesture.$slideEl) {
								gesture.$slideEl = swiper.clickedSlide
									? $(swiper.clickedSlide)
									: swiper.slides.eq(swiper.activeIndex);
								gesture.$imageEl = gesture.$slideEl.find("img, svg, canvas");
								gesture.$imageWrapEl = gesture.$imageEl.parent(
									"." + params.containerClass
								);
							}
							if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
								return;
							}
							gesture.$slideEl.addClass("" + params.zoomedSlideClass);
							var touchX;
							var touchY;
							var offsetX;
							var offsetY;
							var diffX;
							var diffY;
							var translateX;
							var translateY;
							var imageWidth;
							var imageHeight;
							var scaledWidth;
							var scaledHeight;
							var translateMinX;
							var translateMinY;
							var translateMaxX;
							var translateMaxY;
							var slideWidth;
							var slideHeight;
							if (typeof image.touchesStart.x === "undefined" && e) {
								touchX =
									e.type === "touchend" ? e.changedTouches[0].pageX : e.pageX;
								touchY =
									e.type === "touchend" ? e.changedTouches[0].pageY : e.pageY;
							} else {
								touchX = image.touchesStart.x;
								touchY = image.touchesStart.y;
							}
							zoom.scale =
								gesture.$imageWrapEl.attr("data-swiper-zoom") ||
								params.maxRatio;
							zoom.currentScale =
								gesture.$imageWrapEl.attr("data-swiper-zoom") ||
								params.maxRatio;
							if (e) {
								slideWidth = gesture.$slideEl[0].offsetWidth;
								slideHeight = gesture.$slideEl[0].offsetHeight;
								offsetX = gesture.$slideEl.offset().left;
								offsetY = gesture.$slideEl.offset().top;
								diffX = offsetX + slideWidth / 2 - touchX;
								diffY = offsetY + slideHeight / 2 - touchY;
								imageWidth = gesture.$imageEl[0].offsetWidth;
								imageHeight = gesture.$imageEl[0].offsetHeight;
								scaledWidth = imageWidth * zoom.scale;
								scaledHeight = imageHeight * zoom.scale;
								translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
								translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
								translateMaxX = -translateMinX;
								translateMaxY = -translateMinY;
								translateX = diffX * zoom.scale;
								translateY = diffY * zoom.scale;
								if (translateX < translateMinX) {
									translateX = translateMinX;
								}
								if (translateX > translateMaxX) {
									translateX = translateMaxX;
								}
								if (translateY < translateMinY) {
									translateY = translateMinY;
								}
								if (translateY > translateMaxY) {
									translateY = translateMaxY;
								}
							} else {
								translateX = 0;
								translateY = 0;
							}
							gesture.$imageWrapEl
								.transition(300)
								.transform(
									"translate3d(" + translateX + "px, " + translateY + "px,0)"
								);
							gesture.$imageEl
								.transition(300)
								.transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
						},
						out: function out() {
							var swiper = this;
							var zoom = swiper.zoom;
							var params = swiper.params.zoom;
							var gesture = zoom.gesture;
							if (!gesture.$slideEl) {
								gesture.$slideEl = swiper.clickedSlide
									? $(swiper.clickedSlide)
									: swiper.slides.eq(swiper.activeIndex);
								gesture.$imageEl = gesture.$slideEl.find("img, svg, canvas");
								gesture.$imageWrapEl = gesture.$imageEl.parent(
									"." + params.containerClass
								);
							}
							if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
								return;
							}
							zoom.scale = 1;
							zoom.currentScale = 1;
							gesture.$imageWrapEl
								.transition(300)
								.transform("translate3d(0,0,0)");
							gesture.$imageEl
								.transition(300)
								.transform("translate3d(0,0,0) scale(1)");
							gesture.$slideEl.removeClass("" + params.zoomedSlideClass);
							gesture.$slideEl = undefined;
						},
						enable: function enable() {
							var swiper = this;
							var zoom = swiper.zoom;
							if (zoom.enabled) {
								return;
							}
							zoom.enabled = true;
							var passiveListener =
								swiper.touchEvents.start === "touchstart" &&
								Support.passiveListener &&
								swiper.params.passiveListeners
									? { passive: true, capture: false }
									: false;
							if (Support.gestures) {
								swiper.$wrapperEl.on(
									"gesturestart",
									".swiper-slide",
									zoom.onGestureStart,
									passiveListener
								);
								swiper.$wrapperEl.on(
									"gesturechange",
									".swiper-slide",
									zoom.onGestureChange,
									passiveListener
								);
								swiper.$wrapperEl.on(
									"gestureend",
									".swiper-slide",
									zoom.onGestureEnd,
									passiveListener
								);
							} else if (swiper.touchEvents.start === "touchstart") {
								swiper.$wrapperEl.on(
									swiper.touchEvents.start,
									".swiper-slide",
									zoom.onGestureStart,
									passiveListener
								);
								swiper.$wrapperEl.on(
									swiper.touchEvents.move,
									".swiper-slide",
									zoom.onGestureChange,
									passiveListener
								);
								swiper.$wrapperEl.on(
									swiper.touchEvents.end,
									".swiper-slide",
									zoom.onGestureEnd,
									passiveListener
								);
							}
							swiper.$wrapperEl.on(
								swiper.touchEvents.move,
								"." + swiper.params.zoom.containerClass,
								zoom.onTouchMove
							);
						},
						disable: function disable() {
							var swiper = this;
							var zoom = swiper.zoom;
							if (!zoom.enabled) {
								return;
							}
							swiper.zoom.enabled = false;
							var passiveListener =
								swiper.touchEvents.start === "touchstart" &&
								Support.passiveListener &&
								swiper.params.passiveListeners
									? { passive: true, capture: false }
									: false;
							if (Support.gestures) {
								swiper.$wrapperEl.off(
									"gesturestart",
									".swiper-slide",
									zoom.onGestureStart,
									passiveListener
								);
								swiper.$wrapperEl.off(
									"gesturechange",
									".swiper-slide",
									zoom.onGestureChange,
									passiveListener
								);
								swiper.$wrapperEl.off(
									"gestureend",
									".swiper-slide",
									zoom.onGestureEnd,
									passiveListener
								);
							} else if (swiper.touchEvents.start === "touchstart") {
								swiper.$wrapperEl.off(
									swiper.touchEvents.start,
									".swiper-slide",
									zoom.onGestureStart,
									passiveListener
								);
								swiper.$wrapperEl.off(
									swiper.touchEvents.move,
									".swiper-slide",
									zoom.onGestureChange,
									passiveListener
								);
								swiper.$wrapperEl.off(
									swiper.touchEvents.end,
									".swiper-slide",
									zoom.onGestureEnd,
									passiveListener
								);
							}
							swiper.$wrapperEl.off(
								swiper.touchEvents.move,
								"." + swiper.params.zoom.containerClass,
								zoom.onTouchMove
							);
						},
					};
					var Zoom$1 = {
						name: "zoom",
						params: {
							zoom: {
								enabled: false,
								maxRatio: 3,
								minRatio: 1,
								toggle: true,
								containerClass: "swiper-zoom-container",
								zoomedSlideClass: "swiper-slide-zoomed",
							},
						},
						create: function create() {
							var swiper = this;
							var zoom = {
								enabled: false,
								scale: 1,
								currentScale: 1,
								isScaling: false,
								gesture: {
									$slideEl: undefined,
									slideWidth: undefined,
									slideHeight: undefined,
									$imageEl: undefined,
									$imageWrapEl: undefined,
									maxRatio: 3,
								},
								image: {
									isTouched: undefined,
									isMoved: undefined,
									currentX: undefined,
									currentY: undefined,
									minX: undefined,
									minY: undefined,
									maxX: undefined,
									maxY: undefined,
									width: undefined,
									height: undefined,
									startX: undefined,
									startY: undefined,
									touchesStart: {},
									touchesCurrent: {},
								},
								velocity: {
									x: undefined,
									y: undefined,
									prevPositionX: undefined,
									prevPositionY: undefined,
									prevTime: undefined,
								},
							};
							"onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out"
								.split(" ")
								.forEach(function (methodName) {
									zoom[methodName] = Zoom[methodName].bind(swiper);
								});
							Utils.extend(swiper, { zoom: zoom });
							var scale = 1;
							Object.defineProperty(swiper.zoom, "scale", {
								get: function get() {
									return scale;
								},
								set: function set(value) {
									if (scale !== value) {
										var imageEl = swiper.zoom.gesture.$imageEl
											? swiper.zoom.gesture.$imageEl[0]
											: undefined;
										var slideEl = swiper.zoom.gesture.$slideEl
											? swiper.zoom.gesture.$slideEl[0]
											: undefined;
										swiper.emit("zoomChange", value, imageEl, slideEl);
									}
									scale = value;
								},
							});
						},
						on: {
							init: function init() {
								var swiper = this;
								if (swiper.params.zoom.enabled) {
									swiper.zoom.enable();
								}
							},
							destroy: function destroy() {
								var swiper = this;
								swiper.zoom.disable();
							},
							touchStart: function touchStart(e) {
								var swiper = this;
								if (!swiper.zoom.enabled) {
									return;
								}
								swiper.zoom.onTouchStart(e);
							},
							touchEnd: function touchEnd(e) {
								var swiper = this;
								if (!swiper.zoom.enabled) {
									return;
								}
								swiper.zoom.onTouchEnd(e);
							},
							doubleTap: function doubleTap(e) {
								var swiper = this;
								if (
									swiper.params.zoom.enabled &&
									swiper.zoom.enabled &&
									swiper.params.zoom.toggle
								) {
									swiper.zoom.toggle(e);
								}
							},
							transitionEnd: function transitionEnd() {
								var swiper = this;
								if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
									swiper.zoom.onTransitionEnd();
								}
							},
						},
					};
					var Lazy = {
						loadInSlide: function loadInSlide(index, loadInDuplicate) {
							if (loadInDuplicate === void 0) loadInDuplicate = true;
							var swiper = this;
							var params = swiper.params.lazy;
							if (typeof index === "undefined") {
								return;
							}
							if (swiper.slides.length === 0) {
								return;
							}
							var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
							var $slideEl = isVirtual
								? swiper.$wrapperEl.children(
										"." +
											swiper.params.slideClass +
											'[data-swiper-slide-index="' +
											index +
											'"]'
								  )
								: swiper.slides.eq(index);
							var $images = $slideEl.find(
								"." +
									params.elementClass +
									":not(." +
									params.loadedClass +
									"):not(." +
									params.loadingClass +
									")"
							);
							if (
								$slideEl.hasClass(params.elementClass) &&
								!$slideEl.hasClass(params.loadedClass) &&
								!$slideEl.hasClass(params.loadingClass)
							) {
								$images = $images.add($slideEl[0]);
							}
							if ($images.length === 0) {
								return;
							}
							$images.each(function (imageIndex, imageEl) {
								var $imageEl = $(imageEl);
								$imageEl.addClass(params.loadingClass);
								var background = $imageEl.attr("data-background");
								var src = $imageEl.attr("data-src");
								var srcset = $imageEl.attr("data-srcset");
								var sizes = $imageEl.attr("data-sizes");
								swiper.loadImage(
									$imageEl[0],
									src || background,
									srcset,
									sizes,
									false,
									function () {
										if (
											typeof swiper === "undefined" ||
											swiper === null ||
											!swiper ||
											(swiper && !swiper.params) ||
											swiper.destroyed
										) {
											return;
										}
										if (background) {
											$imageEl.css(
												"background-image",
												'url("' + background + '")'
											);
											$imageEl.removeAttr("data-background");
										} else {
											if (srcset) {
												$imageEl.attr("srcset", srcset);
												$imageEl.removeAttr("data-srcset");
											}
											if (sizes) {
												$imageEl.attr("sizes", sizes);
												$imageEl.removeAttr("data-sizes");
											}
											if (src) {
												$imageEl.attr("src", src);
												$imageEl.removeAttr("data-src");
											}
										}
										$imageEl
											.addClass(params.loadedClass)
											.removeClass(params.loadingClass);
										$slideEl.find("." + params.preloaderClass).remove();
										if (swiper.params.loop && loadInDuplicate) {
											var slideOriginalIndex = $slideEl.attr(
												"data-swiper-slide-index"
											);
											if (
												$slideEl.hasClass(swiper.params.slideDuplicateClass)
											) {
												var originalSlide = swiper.$wrapperEl.children(
													'[data-swiper-slide-index="' +
														slideOriginalIndex +
														'"]:not(.' +
														swiper.params.slideDuplicateClass +
														")"
												);
												swiper.lazy.loadInSlide(originalSlide.index(), false);
											} else {
												var duplicatedSlide = swiper.$wrapperEl.children(
													"." +
														swiper.params.slideDuplicateClass +
														'[data-swiper-slide-index="' +
														slideOriginalIndex +
														'"]'
												);
												swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
											}
										}
										swiper.emit("lazyImageReady", $slideEl[0], $imageEl[0]);
									}
								);
								swiper.emit("lazyImageLoad", $slideEl[0], $imageEl[0]);
							});
						},
						load: function load() {
							var swiper = this;
							var $wrapperEl = swiper.$wrapperEl;
							var swiperParams = swiper.params;
							var slides = swiper.slides;
							var activeIndex = swiper.activeIndex;
							var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
							var params = swiperParams.lazy;
							var slidesPerView = swiperParams.slidesPerView;
							if (slidesPerView === "auto") {
								slidesPerView = 0;
							}
							function slideExist(index) {
								if (isVirtual) {
									if (
										$wrapperEl.children(
											"." +
												swiperParams.slideClass +
												'[data-swiper-slide-index="' +
												index +
												'"]'
										).length
									) {
										return true;
									}
								} else if (slides[index]) {
									return true;
								}
								return false;
							}
							function slideIndex(slideEl) {
								if (isVirtual) {
									return $(slideEl).attr("data-swiper-slide-index");
								}
								return $(slideEl).index();
							}
							if (!swiper.lazy.initialImageLoaded) {
								swiper.lazy.initialImageLoaded = true;
							}
							if (swiper.params.watchSlidesVisibility) {
								$wrapperEl
									.children("." + swiperParams.slideVisibleClass)
									.each(function (elIndex, slideEl) {
										var index = isVirtual
											? $(slideEl).attr("data-swiper-slide-index")
											: $(slideEl).index();
										swiper.lazy.loadInSlide(index);
									});
							} else if (slidesPerView > 1) {
								for (
									var i = activeIndex;
									i < activeIndex + slidesPerView;
									i += 1
								) {
									if (slideExist(i)) {
										swiper.lazy.loadInSlide(i);
									}
								}
							} else {
								swiper.lazy.loadInSlide(activeIndex);
							}
							if (params.loadPrevNext) {
								if (
									slidesPerView > 1 ||
									(params.loadPrevNextAmount && params.loadPrevNextAmount > 1)
								) {
									var amount = params.loadPrevNextAmount;
									var spv = slidesPerView;
									var maxIndex = Math.min(
										activeIndex + spv + Math.max(amount, spv),
										slides.length
									);
									var minIndex = Math.max(
										activeIndex - Math.max(spv, amount),
										0
									);
									for (
										var i$1 = activeIndex + slidesPerView;
										i$1 < maxIndex;
										i$1 += 1
									) {
										if (slideExist(i$1)) {
											swiper.lazy.loadInSlide(i$1);
										}
									}
									for (var i$2 = minIndex; i$2 < activeIndex; i$2 += 1) {
										if (slideExist(i$2)) {
											swiper.lazy.loadInSlide(i$2);
										}
									}
								} else {
									var nextSlide = $wrapperEl.children(
										"." + swiperParams.slideNextClass
									);
									if (nextSlide.length > 0) {
										swiper.lazy.loadInSlide(slideIndex(nextSlide));
									}
									var prevSlide = $wrapperEl.children(
										"." + swiperParams.slidePrevClass
									);
									if (prevSlide.length > 0) {
										swiper.lazy.loadInSlide(slideIndex(prevSlide));
									}
								}
							}
						},
					};
					var Lazy$1 = {
						name: "lazy",
						params: {
							lazy: {
								enabled: false,
								loadPrevNext: false,
								loadPrevNextAmount: 1,
								loadOnTransitionStart: false,
								elementClass: "swiper-lazy",
								loadingClass: "swiper-lazy-loading",
								loadedClass: "swiper-lazy-loaded",
								preloaderClass: "swiper-lazy-preloader",
							},
						},
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								lazy: {
									initialImageLoaded: false,
									load: Lazy.load.bind(swiper),
									loadInSlide: Lazy.loadInSlide.bind(swiper),
								},
							});
						},
						on: {
							beforeInit: function beforeInit() {
								var swiper = this;
								if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
									swiper.params.preloadImages = false;
								}
							},
							init: function init() {
								var swiper = this;
								if (
									swiper.params.lazy.enabled &&
									!swiper.params.loop &&
									swiper.params.initialSlide === 0
								) {
									swiper.lazy.load();
								}
							},
							scroll: function scroll() {
								var swiper = this;
								if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
									swiper.lazy.load();
								}
							},
							resize: function resize() {
								var swiper = this;
								if (swiper.params.lazy.enabled) {
									swiper.lazy.load();
								}
							},
							scrollbarDragMove: function scrollbarDragMove() {
								var swiper = this;
								if (swiper.params.lazy.enabled) {
									swiper.lazy.load();
								}
							},
							transitionStart: function transitionStart() {
								var swiper = this;
								if (swiper.params.lazy.enabled) {
									if (
										swiper.params.lazy.loadOnTransitionStart ||
										(!swiper.params.lazy.loadOnTransitionStart &&
											!swiper.lazy.initialImageLoaded)
									) {
										swiper.lazy.load();
									}
								}
							},
							transitionEnd: function transitionEnd() {
								var swiper = this;
								if (
									swiper.params.lazy.enabled &&
									!swiper.params.lazy.loadOnTransitionStart
								) {
									swiper.lazy.load();
								}
							},
						},
					};
					var Controller = {
						LinearSpline: function LinearSpline(x, y) {
							var binarySearch = (function search() {
								var maxIndex;
								var minIndex;
								var guess;
								return function (array, val) {
									minIndex = -1;
									maxIndex = array.length;
									while (maxIndex - minIndex > 1) {
										guess = (maxIndex + minIndex) >> 1;
										if (array[guess] <= val) {
											minIndex = guess;
										} else {
											maxIndex = guess;
										}
									}
									return maxIndex;
								};
							})();
							this.x = x;
							this.y = y;
							this.lastIndex = x.length - 1;
							var i1;
							var i3;
							this.interpolate = function interpolate(x2) {
								if (!x2) {
									return 0;
								}
								i3 = binarySearch(this.x, x2);
								i1 = i3 - 1;
								return (
									((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) /
										(this.x[i3] - this.x[i1]) +
									this.y[i1]
								);
							};
							return this;
						},
						getInterpolateFunction: function getInterpolateFunction(c) {
							var swiper = this;
							if (!swiper.controller.spline) {
								swiper.controller.spline = swiper.params.loop
									? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)
									: new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
							}
						},
						setTranslate: function setTranslate(setTranslate$1, byController) {
							var swiper = this;
							var controlled = swiper.controller.control;
							var multiplier;
							var controlledTranslate;
							function setControlledTranslate(c) {
								var translate = swiper.rtlTranslate
									? -swiper.translate
									: swiper.translate;
								if (swiper.params.controller.by === "slide") {
									swiper.controller.getInterpolateFunction(c);
									controlledTranslate = -swiper.controller.spline.interpolate(
										-translate
									);
								}
								if (
									!controlledTranslate ||
									swiper.params.controller.by === "container"
								) {
									multiplier =
										(c.maxTranslate() - c.minTranslate()) /
										(swiper.maxTranslate() - swiper.minTranslate());
									controlledTranslate =
										(translate - swiper.minTranslate()) * multiplier +
										c.minTranslate();
								}
								if (swiper.params.controller.inverse) {
									controlledTranslate = c.maxTranslate() - controlledTranslate;
								}
								c.updateProgress(controlledTranslate);
								c.setTranslate(controlledTranslate, swiper);
								c.updateActiveIndex();
								c.updateSlidesClasses();
							}
							if (Array.isArray(controlled)) {
								for (var i = 0; i < controlled.length; i += 1) {
									if (
										controlled[i] !== byController &&
										controlled[i] instanceof Swiper
									) {
										setControlledTranslate(controlled[i]);
									}
								}
							} else if (
								controlled instanceof Swiper &&
								byController !== controlled
							) {
								setControlledTranslate(controlled);
							}
						},
						setTransition: function setTransition(duration, byController) {
							var swiper = this;
							var controlled = swiper.controller.control;
							var i;
							function setControlledTransition(c) {
								c.setTransition(duration, swiper);
								if (duration !== 0) {
									c.transitionStart();
									if (c.params.autoHeight) {
										Utils.nextTick(function () {
											c.updateAutoHeight();
										});
									}
									c.$wrapperEl.transitionEnd(function () {
										if (!controlled) {
											return;
										}
										if (
											c.params.loop &&
											swiper.params.controller.by === "slide"
										) {
											c.loopFix();
										}
										c.transitionEnd();
									});
								}
							}
							if (Array.isArray(controlled)) {
								for (i = 0; i < controlled.length; i += 1) {
									if (
										controlled[i] !== byController &&
										controlled[i] instanceof Swiper
									) {
										setControlledTransition(controlled[i]);
									}
								}
							} else if (
								controlled instanceof Swiper &&
								byController !== controlled
							) {
								setControlledTransition(controlled);
							}
						},
					};
					var Controller$1 = {
						name: "controller",
						params: {
							controller: { control: undefined, inverse: false, by: "slide" },
						},
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								controller: {
									control: swiper.params.controller.control,
									getInterpolateFunction:
										Controller.getInterpolateFunction.bind(swiper),
									setTranslate: Controller.setTranslate.bind(swiper),
									setTransition: Controller.setTransition.bind(swiper),
								},
							});
						},
						on: {
							update: function update() {
								var swiper = this;
								if (!swiper.controller.control) {
									return;
								}
								if (swiper.controller.spline) {
									swiper.controller.spline = undefined;
									delete swiper.controller.spline;
								}
							},
							resize: function resize() {
								var swiper = this;
								if (!swiper.controller.control) {
									return;
								}
								if (swiper.controller.spline) {
									swiper.controller.spline = undefined;
									delete swiper.controller.spline;
								}
							},
							observerUpdate: function observerUpdate() {
								var swiper = this;
								if (!swiper.controller.control) {
									return;
								}
								if (swiper.controller.spline) {
									swiper.controller.spline = undefined;
									delete swiper.controller.spline;
								}
							},
							setTranslate: function setTranslate(translate, byController) {
								var swiper = this;
								if (!swiper.controller.control) {
									return;
								}
								swiper.controller.setTranslate(translate, byController);
							},
							setTransition: function setTransition(duration, byController) {
								var swiper = this;
								if (!swiper.controller.control) {
									return;
								}
								swiper.controller.setTransition(duration, byController);
							},
						},
					};
					var a11y = {
						makeElFocusable: function makeElFocusable($el) {
							$el.attr("tabIndex", "0");
							return $el;
						},
						addElRole: function addElRole($el, role) {
							$el.attr("role", role);
							return $el;
						},
						addElLabel: function addElLabel($el, label) {
							$el.attr("aria-label", label);
							return $el;
						},
						disableEl: function disableEl($el) {
							$el.attr("aria-disabled", true);
							return $el;
						},
						enableEl: function enableEl($el) {
							$el.attr("aria-disabled", false);
							return $el;
						},
						onEnterKey: function onEnterKey(e) {
							var swiper = this;
							var params = swiper.params.a11y;
							if (e.keyCode !== 13) {
								return;
							}
							var $targetEl = $(e.target);
							if (
								swiper.navigation &&
								swiper.navigation.$nextEl &&
								$targetEl.is(swiper.navigation.$nextEl)
							) {
								if (!(swiper.isEnd && !swiper.params.loop)) {
									swiper.slideNext();
								}
								if (swiper.isEnd) {
									swiper.a11y.notify(params.lastSlideMessage);
								} else {
									swiper.a11y.notify(params.nextSlideMessage);
								}
							}
							if (
								swiper.navigation &&
								swiper.navigation.$prevEl &&
								$targetEl.is(swiper.navigation.$prevEl)
							) {
								if (!(swiper.isBeginning && !swiper.params.loop)) {
									swiper.slidePrev();
								}
								if (swiper.isBeginning) {
									swiper.a11y.notify(params.firstSlideMessage);
								} else {
									swiper.a11y.notify(params.prevSlideMessage);
								}
							}
							if (
								swiper.pagination &&
								$targetEl.is("." + swiper.params.pagination.bulletClass)
							) {
								$targetEl[0].click();
							}
						},
						notify: function notify(message) {
							var swiper = this;
							var notification = swiper.a11y.liveRegion;
							if (notification.length === 0) {
								return;
							}
							notification.html("");
							notification.html(message);
						},
						updateNavigation: function updateNavigation() {
							var swiper = this;
							if (swiper.params.loop) {
								return;
							}
							var ref = swiper.navigation;
							var $nextEl = ref.$nextEl;
							var $prevEl = ref.$prevEl;
							if ($prevEl && $prevEl.length > 0) {
								if (swiper.isBeginning) {
									swiper.a11y.disableEl($prevEl);
								} else {
									swiper.a11y.enableEl($prevEl);
								}
							}
							if ($nextEl && $nextEl.length > 0) {
								if (swiper.isEnd) {
									swiper.a11y.disableEl($nextEl);
								} else {
									swiper.a11y.enableEl($nextEl);
								}
							}
						},
						updatePagination: function updatePagination() {
							var swiper = this;
							var params = swiper.params.a11y;
							if (
								swiper.pagination &&
								swiper.params.pagination.clickable &&
								swiper.pagination.bullets &&
								swiper.pagination.bullets.length
							) {
								swiper.pagination.bullets.each(function (
									bulletIndex,
									bulletEl
								) {
									var $bulletEl = $(bulletEl);
									swiper.a11y.makeElFocusable($bulletEl);
									swiper.a11y.addElRole($bulletEl, "button");
									swiper.a11y.addElLabel(
										$bulletEl,
										params.paginationBulletMessage.replace(
											/{{index}}/,
											$bulletEl.index() + 1
										)
									);
								});
							}
						},
						init: function init() {
							var swiper = this;
							swiper.$el.append(swiper.a11y.liveRegion);
							var params = swiper.params.a11y;
							var $nextEl;
							var $prevEl;
							if (swiper.navigation && swiper.navigation.$nextEl) {
								$nextEl = swiper.navigation.$nextEl;
							}
							if (swiper.navigation && swiper.navigation.$prevEl) {
								$prevEl = swiper.navigation.$prevEl;
							}
							if ($nextEl) {
								swiper.a11y.makeElFocusable($nextEl);
								swiper.a11y.addElRole($nextEl, "button");
								swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
								$nextEl.on("keydown", swiper.a11y.onEnterKey);
							}
							if ($prevEl) {
								swiper.a11y.makeElFocusable($prevEl);
								swiper.a11y.addElRole($prevEl, "button");
								swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
								$prevEl.on("keydown", swiper.a11y.onEnterKey);
							}
							if (
								swiper.pagination &&
								swiper.params.pagination.clickable &&
								swiper.pagination.bullets &&
								swiper.pagination.bullets.length
							) {
								swiper.pagination.$el.on(
									"keydown",
									"." + swiper.params.pagination.bulletClass,
									swiper.a11y.onEnterKey
								);
							}
						},
						destroy: function destroy() {
							var swiper = this;
							if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) {
								swiper.a11y.liveRegion.remove();
							}
							var $nextEl;
							var $prevEl;
							if (swiper.navigation && swiper.navigation.$nextEl) {
								$nextEl = swiper.navigation.$nextEl;
							}
							if (swiper.navigation && swiper.navigation.$prevEl) {
								$prevEl = swiper.navigation.$prevEl;
							}
							if ($nextEl) {
								$nextEl.off("keydown", swiper.a11y.onEnterKey);
							}
							if ($prevEl) {
								$prevEl.off("keydown", swiper.a11y.onEnterKey);
							}
							if (
								swiper.pagination &&
								swiper.params.pagination.clickable &&
								swiper.pagination.bullets &&
								swiper.pagination.bullets.length
							) {
								swiper.pagination.$el.off(
									"keydown",
									"." + swiper.params.pagination.bulletClass,
									swiper.a11y.onEnterKey
								);
							}
						},
					};
					var A11y = {
						name: "a11y",
						params: {
							a11y: {
								enabled: true,
								notificationClass: "swiper-notification",
								prevSlideMessage: "Previous slide",
								nextSlideMessage: "Next slide",
								firstSlideMessage: "This is the first slide",
								lastSlideMessage: "This is the last slide",
								paginationBulletMessage: "Go to slide {{index}}",
							},
						},
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								a11y: {
									liveRegion: $(
										'<span class="' +
											swiper.params.a11y.notificationClass +
											'" aria-live="assertive" aria-atomic="true"></span>'
									),
								},
							});
							Object.keys(a11y).forEach(function (methodName) {
								swiper.a11y[methodName] = a11y[methodName].bind(swiper);
							});
						},
						on: {
							init: function init() {
								var swiper = this;
								if (!swiper.params.a11y.enabled) {
									return;
								}
								swiper.a11y.init();
								swiper.a11y.updateNavigation();
							},
							toEdge: function toEdge() {
								var swiper = this;
								if (!swiper.params.a11y.enabled) {
									return;
								}
								swiper.a11y.updateNavigation();
							},
							fromEdge: function fromEdge() {
								var swiper = this;
								if (!swiper.params.a11y.enabled) {
									return;
								}
								swiper.a11y.updateNavigation();
							},
							paginationUpdate: function paginationUpdate() {
								var swiper = this;
								if (!swiper.params.a11y.enabled) {
									return;
								}
								swiper.a11y.updatePagination();
							},
							destroy: function destroy() {
								var swiper = this;
								if (!swiper.params.a11y.enabled) {
									return;
								}
								swiper.a11y.destroy();
							},
						},
					};
					var History = {
						init: function init() {
							var swiper = this;
							if (!swiper.params.history) {
								return;
							}
							if (!win.history || !win.history.pushState) {
								swiper.params.history.enabled = false;
								swiper.params.hashNavigation.enabled = true;
								return;
							}
							var history = swiper.history;
							history.initialized = true;
							history.paths = History.getPathValues();
							if (!history.paths.key && !history.paths.value) {
								return;
							}
							history.scrollToSlide(
								0,
								history.paths.value,
								swiper.params.runCallbacksOnInit
							);
							if (!swiper.params.history.replaceState) {
								win.addEventListener(
									"popstate",
									swiper.history.setHistoryPopState
								);
							}
						},
						destroy: function destroy() {
							var swiper = this;
							if (!swiper.params.history.replaceState) {
								win.removeEventListener(
									"popstate",
									swiper.history.setHistoryPopState
								);
							}
						},
						setHistoryPopState: function setHistoryPopState() {
							var swiper = this;
							swiper.history.paths = History.getPathValues();
							swiper.history.scrollToSlide(
								swiper.params.speed,
								swiper.history.paths.value,
								false
							);
						},
						getPathValues: function getPathValues() {
							var pathArray = win.location.pathname
								.slice(1)
								.split("/")
								.filter(function (part) {
									return part !== "";
								});
							var total = pathArray.length;
							var key = pathArray[total - 2];
							var value = pathArray[total - 1];
							return { key: key, value: value };
						},
						setHistory: function setHistory(key, index) {
							var swiper = this;
							if (
								!swiper.history.initialized ||
								!swiper.params.history.enabled
							) {
								return;
							}
							var slide = swiper.slides.eq(index);
							var value = History.slugify(slide.attr("data-history"));
							if (!win.location.pathname.includes(key)) {
								value = key + "/" + value;
							}
							var currentState = win.history.state;
							if (currentState && currentState.value === value) {
								return;
							}
							if (swiper.params.history.replaceState) {
								win.history.replaceState({ value: value }, null, value);
							} else {
								win.history.pushState({ value: value }, null, value);
							}
						},
						slugify: function slugify(text) {
							return text
								.toString()
								.replace(/\s+/g, "-")
								.replace(/[^\w-]+/g, "")
								.replace(/--+/g, "-")
								.replace(/^-+/, "")
								.replace(/-+$/, "");
						},
						scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {
							var swiper = this;
							if (value) {
								for (
									var i = 0, length = swiper.slides.length;
									i < length;
									i += 1
								) {
									var slide = swiper.slides.eq(i);
									var slideHistory = History.slugify(
										slide.attr("data-history")
									);
									if (
										slideHistory === value &&
										!slide.hasClass(swiper.params.slideDuplicateClass)
									) {
										var index = slide.index();
										swiper.slideTo(index, speed, runCallbacks);
									}
								}
							} else {
								swiper.slideTo(0, speed, runCallbacks);
							}
						},
					};
					var History$1 = {
						name: "history",
						params: {
							history: { enabled: false, replaceState: false, key: "slides" },
						},
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								history: {
									init: History.init.bind(swiper),
									setHistory: History.setHistory.bind(swiper),
									setHistoryPopState: History.setHistoryPopState.bind(swiper),
									scrollToSlide: History.scrollToSlide.bind(swiper),
									destroy: History.destroy.bind(swiper),
								},
							});
						},
						on: {
							init: function init() {
								var swiper = this;
								if (swiper.params.history.enabled) {
									swiper.history.init();
								}
							},
							destroy: function destroy() {
								var swiper = this;
								if (swiper.params.history.enabled) {
									swiper.history.destroy();
								}
							},
							transitionEnd: function transitionEnd() {
								var swiper = this;
								if (swiper.history.initialized) {
									swiper.history.setHistory(
										swiper.params.history.key,
										swiper.activeIndex
									);
								}
							},
						},
					};
					var HashNavigation = {
						onHashCange: function onHashCange() {
							var swiper = this;
							var newHash = doc.location.hash.replace("#", "");
							var activeSlideHash = swiper.slides
								.eq(swiper.activeIndex)
								.attr("data-hash");
							if (newHash !== activeSlideHash) {
								var newIndex = swiper.$wrapperEl
									.children(
										"." +
											swiper.params.slideClass +
											'[data-hash="' +
											newHash +
											'"]'
									)
									.index();
								if (typeof newIndex === "undefined") {
									return;
								}
								swiper.slideTo(newIndex);
							}
						},
						setHash: function setHash() {
							var swiper = this;
							if (
								!swiper.hashNavigation.initialized ||
								!swiper.params.hashNavigation.enabled
							) {
								return;
							}
							if (
								swiper.params.hashNavigation.replaceState &&
								win.history &&
								win.history.replaceState
							) {
								win.history.replaceState(
									null,
									null,
									"#" +
										swiper.slides.eq(swiper.activeIndex).attr("data-hash") || ""
								);
							} else {
								var slide = swiper.slides.eq(swiper.activeIndex);
								var hash =
									slide.attr("data-hash") || slide.attr("data-history");
								doc.location.hash = hash || "";
							}
						},
						init: function init() {
							var swiper = this;
							if (
								!swiper.params.hashNavigation.enabled ||
								(swiper.params.history && swiper.params.history.enabled)
							) {
								return;
							}
							swiper.hashNavigation.initialized = true;
							var hash = doc.location.hash.replace("#", "");
							if (hash) {
								var speed = 0;
								for (
									var i = 0, length = swiper.slides.length;
									i < length;
									i += 1
								) {
									var slide = swiper.slides.eq(i);
									var slideHash =
										slide.attr("data-hash") || slide.attr("data-history");
									if (
										slideHash === hash &&
										!slide.hasClass(swiper.params.slideDuplicateClass)
									) {
										var index = slide.index();
										swiper.slideTo(
											index,
											speed,
											swiper.params.runCallbacksOnInit,
											true
										);
									}
								}
							}
							if (swiper.params.hashNavigation.watchState) {
								$(win).on("hashchange", swiper.hashNavigation.onHashCange);
							}
						},
						destroy: function destroy() {
							var swiper = this;
							if (swiper.params.hashNavigation.watchState) {
								$(win).off("hashchange", swiper.hashNavigation.onHashCange);
							}
						},
					};
					var HashNavigation$1 = {
						name: "hash-navigation",
						params: {
							hashNavigation: {
								enabled: false,
								replaceState: false,
								watchState: false,
							},
						},
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								hashNavigation: {
									initialized: false,
									init: HashNavigation.init.bind(swiper),
									destroy: HashNavigation.destroy.bind(swiper),
									setHash: HashNavigation.setHash.bind(swiper),
									onHashCange: HashNavigation.onHashCange.bind(swiper),
								},
							});
						},
						on: {
							init: function init() {
								var swiper = this;
								if (swiper.params.hashNavigation.enabled) {
									swiper.hashNavigation.init();
								}
							},
							destroy: function destroy() {
								var swiper = this;
								if (swiper.params.hashNavigation.enabled) {
									swiper.hashNavigation.destroy();
								}
							},
							transitionEnd: function transitionEnd() {
								var swiper = this;
								if (swiper.hashNavigation.initialized) {
									swiper.hashNavigation.setHash();
								}
							},
						},
					};
					var Autoplay = {
						run: function run() {
							var swiper = this;
							var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
							var delay = swiper.params.autoplay.delay;
							if ($activeSlideEl.attr("data-swiper-autoplay")) {
								delay =
									$activeSlideEl.attr("data-swiper-autoplay") ||
									swiper.params.autoplay.delay;
							}
							clearTimeout(swiper.autoplay.timeout);
							swiper.autoplay.timeout = Utils.nextTick(function () {
								if (swiper.params.autoplay.reverseDirection) {
									if (swiper.params.loop) {
										swiper.loopFix();
										swiper.slidePrev(swiper.params.speed, true, true);
										swiper.emit("autoplay");
									} else if (!swiper.isBeginning) {
										swiper.slidePrev(swiper.params.speed, true, true);
										swiper.emit("autoplay");
									} else if (!swiper.params.autoplay.stopOnLastSlide) {
										swiper.slideTo(
											swiper.slides.length - 1,
											swiper.params.speed,
											true,
											true
										);
										swiper.emit("autoplay");
									} else {
										swiper.autoplay.stop();
									}
								} else if (swiper.params.loop) {
									swiper.loopFix();
									swiper.slideNext(swiper.params.speed, true, true);
									swiper.emit("autoplay");
								} else if (!swiper.isEnd) {
									swiper.slideNext(swiper.params.speed, true, true);
									swiper.emit("autoplay");
								} else if (!swiper.params.autoplay.stopOnLastSlide) {
									swiper.slideTo(0, swiper.params.speed, true, true);
									swiper.emit("autoplay");
								} else {
									swiper.autoplay.stop();
								}
							}, delay);
						},
						start: function start() {
							var swiper = this;
							if (typeof swiper.autoplay.timeout !== "undefined") {
								return false;
							}
							if (swiper.autoplay.running) {
								return false;
							}
							swiper.autoplay.running = true;
							swiper.emit("autoplayStart");
							swiper.autoplay.run();
							return true;
						},
						stop: function stop() {
							var swiper = this;
							if (!swiper.autoplay.running) {
								return false;
							}
							if (typeof swiper.autoplay.timeout === "undefined") {
								return false;
							}
							if (swiper.autoplay.timeout) {
								clearTimeout(swiper.autoplay.timeout);
								swiper.autoplay.timeout = undefined;
							}
							swiper.autoplay.running = false;
							swiper.emit("autoplayStop");
							return true;
						},
						pause: function pause(speed) {
							var swiper = this;
							if (!swiper.autoplay.running) {
								return;
							}
							if (swiper.autoplay.paused) {
								return;
							}
							if (swiper.autoplay.timeout) {
								clearTimeout(swiper.autoplay.timeout);
							}
							swiper.autoplay.paused = true;
							if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
								swiper.autoplay.paused = false;
								swiper.autoplay.run();
							} else {
								swiper.$wrapperEl[0].addEventListener(
									"transitionend",
									swiper.autoplay.onTransitionEnd
								);
								swiper.$wrapperEl[0].addEventListener(
									"webkitTransitionEnd",
									swiper.autoplay.onTransitionEnd
								);
							}
						},
					};
					var Autoplay$1 = {
						name: "autoplay",
						params: {
							autoplay: {
								enabled: false,
								delay: 3e3,
								waitForTransition: true,
								disableOnInteraction: true,
								stopOnLastSlide: false,
								reverseDirection: false,
							},
						},
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								autoplay: {
									running: false,
									paused: false,
									run: Autoplay.run.bind(swiper),
									start: Autoplay.start.bind(swiper),
									stop: Autoplay.stop.bind(swiper),
									pause: Autoplay.pause.bind(swiper),
									onTransitionEnd: function onTransitionEnd(e) {
										if (!swiper || swiper.destroyed || !swiper.$wrapperEl) {
											return;
										}
										if (e.target !== this) {
											return;
										}
										swiper.$wrapperEl[0].removeEventListener(
											"transitionend",
											swiper.autoplay.onTransitionEnd
										);
										swiper.$wrapperEl[0].removeEventListener(
											"webkitTransitionEnd",
											swiper.autoplay.onTransitionEnd
										);
										swiper.autoplay.paused = false;
										if (!swiper.autoplay.running) {
											swiper.autoplay.stop();
										} else {
											swiper.autoplay.run();
										}
									},
								},
							});
						},
						on: {
							init: function init() {
								var swiper = this;
								if (swiper.params.autoplay.enabled) {
									swiper.autoplay.start();
								}
							},
							beforeTransitionStart: function beforeTransitionStart(
								speed,
								internal
							) {
								var swiper = this;
								if (swiper.autoplay.running) {
									if (
										internal ||
										!swiper.params.autoplay.disableOnInteraction
									) {
										swiper.autoplay.pause(speed);
									} else {
										swiper.autoplay.stop();
									}
								}
							},
							sliderFirstMove: function sliderFirstMove() {
								var swiper = this;
								if (swiper.autoplay.running) {
									if (swiper.params.autoplay.disableOnInteraction) {
										swiper.autoplay.stop();
									} else {
										swiper.autoplay.pause();
									}
								}
							},
							destroy: function destroy() {
								var swiper = this;
								if (swiper.autoplay.running) {
									swiper.autoplay.stop();
								}
							},
						},
					};
					var Fade = {
						setTranslate: function setTranslate() {
							var swiper = this;
							var slides = swiper.slides;
							for (var i = 0; i < slides.length; i += 1) {
								var $slideEl = swiper.slides.eq(i);
								var offset = $slideEl[0].swiperSlideOffset;
								var tx = -offset;
								if (!swiper.params.virtualTranslate) {
									tx -= swiper.translate;
								}
								var ty = 0;
								if (!swiper.isHorizontal()) {
									ty = tx;
									tx = 0;
								}
								var slideOpacity = swiper.params.fadeEffect.crossFade
									? Math.max(1 - Math.abs($slideEl[0].progress), 0)
									: 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
								$slideEl
									.css({ opacity: slideOpacity })
									.transform("translate3d(" + tx + "px, " + ty + "px, 0px)");
							}
						},
						setTransition: function setTransition(duration) {
							var swiper = this;
							var slides = swiper.slides;
							var $wrapperEl = swiper.$wrapperEl;
							slides.transition(duration);
							if (swiper.params.virtualTranslate && duration !== 0) {
								var eventTriggered = false;
								slides.transitionEnd(function () {
									if (eventTriggered) {
										return;
									}
									if (!swiper || swiper.destroyed) {
										return;
									}
									eventTriggered = true;
									swiper.animating = false;
									var triggerEvents = ["webkitTransitionEnd", "transitionend"];
									for (var i = 0; i < triggerEvents.length; i += 1) {
										$wrapperEl.trigger(triggerEvents[i]);
									}
								});
							}
						},
					};
					var EffectFade = {
						name: "effect-fade",
						params: { fadeEffect: { crossFade: false } },
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								fadeEffect: {
									setTranslate: Fade.setTranslate.bind(swiper),
									setTransition: Fade.setTransition.bind(swiper),
								},
							});
						},
						on: {
							beforeInit: function beforeInit() {
								var swiper = this;
								if (swiper.params.effect !== "fade") {
									return;
								}
								swiper.classNames.push(
									swiper.params.containerModifierClass + "fade"
								);
								var overwriteParams = {
									slidesPerView: 1,
									slidesPerColumn: 1,
									slidesPerGroup: 1,
									watchSlidesProgress: true,
									spaceBetween: 0,
									virtualTranslate: true,
								};
								Utils.extend(swiper.params, overwriteParams);
								Utils.extend(swiper.originalParams, overwriteParams);
							},
							setTranslate: function setTranslate() {
								var swiper = this;
								if (swiper.params.effect !== "fade") {
									return;
								}
								swiper.fadeEffect.setTranslate();
							},
							setTransition: function setTransition(duration) {
								var swiper = this;
								if (swiper.params.effect !== "fade") {
									return;
								}
								swiper.fadeEffect.setTransition(duration);
							},
						},
					};
					var Cube = {
						setTranslate: function setTranslate() {
							var swiper = this;
							var $el = swiper.$el;
							var $wrapperEl = swiper.$wrapperEl;
							var slides = swiper.slides;
							var swiperWidth = swiper.width;
							var swiperHeight = swiper.height;
							var rtl = swiper.rtlTranslate;
							var swiperSize = swiper.size;
							var params = swiper.params.cubeEffect;
							var isHorizontal = swiper.isHorizontal();
							var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
							var wrapperRotate = 0;
							var $cubeShadowEl;
							if (params.shadow) {
								if (isHorizontal) {
									$cubeShadowEl = $wrapperEl.find(".swiper-cube-shadow");
									if ($cubeShadowEl.length === 0) {
										$cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
										$wrapperEl.append($cubeShadowEl);
									}
									$cubeShadowEl.css({ height: swiperWidth + "px" });
								} else {
									$cubeShadowEl = $el.find(".swiper-cube-shadow");
									if ($cubeShadowEl.length === 0) {
										$cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
										$el.append($cubeShadowEl);
									}
								}
							}
							for (var i = 0; i < slides.length; i += 1) {
								var $slideEl = slides.eq(i);
								var slideIndex = i;
								if (isVirtual) {
									slideIndex = parseInt(
										$slideEl.attr("data-swiper-slide-index"),
										10
									);
								}
								var slideAngle = slideIndex * 90;
								var round = Math.floor(slideAngle / 360);
								if (rtl) {
									slideAngle = -slideAngle;
									round = Math.floor(-slideAngle / 360);
								}
								var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
								var tx = 0;
								var ty = 0;
								var tz = 0;
								if (slideIndex % 4 === 0) {
									tx = -round * 4 * swiperSize;
									tz = 0;
								} else if ((slideIndex - 1) % 4 === 0) {
									tx = 0;
									tz = -round * 4 * swiperSize;
								} else if ((slideIndex - 2) % 4 === 0) {
									tx = swiperSize + round * 4 * swiperSize;
									tz = swiperSize;
								} else if ((slideIndex - 3) % 4 === 0) {
									tx = -swiperSize;
									tz = 3 * swiperSize + swiperSize * 4 * round;
								}
								if (rtl) {
									tx = -tx;
								}
								if (!isHorizontal) {
									ty = tx;
									tx = 0;
								}
								var transform =
									"rotateX(" +
									(isHorizontal ? 0 : -slideAngle) +
									"deg) rotateY(" +
									(isHorizontal ? slideAngle : 0) +
									"deg) translate3d(" +
									tx +
									"px, " +
									ty +
									"px, " +
									tz +
									"px)";
								if (progress <= 1 && progress > -1) {
									wrapperRotate = slideIndex * 90 + progress * 90;
									if (rtl) {
										wrapperRotate = -slideIndex * 90 - progress * 90;
									}
								}
								$slideEl.transform(transform);
								if (params.slideShadows) {
									var shadowBefore = isHorizontal
										? $slideEl.find(".swiper-slide-shadow-left")
										: $slideEl.find(".swiper-slide-shadow-top");
									var shadowAfter = isHorizontal
										? $slideEl.find(".swiper-slide-shadow-right")
										: $slideEl.find(".swiper-slide-shadow-bottom");
									if (shadowBefore.length === 0) {
										shadowBefore = $(
											'<div class="swiper-slide-shadow-' +
												(isHorizontal ? "left" : "top") +
												'"></div>'
										);
										$slideEl.append(shadowBefore);
									}
									if (shadowAfter.length === 0) {
										shadowAfter = $(
											'<div class="swiper-slide-shadow-' +
												(isHorizontal ? "right" : "bottom") +
												'"></div>'
										);
										$slideEl.append(shadowAfter);
									}
									if (shadowBefore.length) {
										shadowBefore[0].style.opacity = Math.max(-progress, 0);
									}
									if (shadowAfter.length) {
										shadowAfter[0].style.opacity = Math.max(progress, 0);
									}
								}
							}
							$wrapperEl.css({
								"-webkit-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
								"-moz-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
								"-ms-transform-origin": "50% 50% -" + swiperSize / 2 + "px",
								"transform-origin": "50% 50% -" + swiperSize / 2 + "px",
							});
							if (params.shadow) {
								if (isHorizontal) {
									$cubeShadowEl.transform(
										"translate3d(0px, " +
											(swiperWidth / 2 + params.shadowOffset) +
											"px, " +
											-swiperWidth / 2 +
											"px) rotateX(90deg) rotateZ(0deg) scale(" +
											params.shadowScale +
											")"
									);
								} else {
									var shadowAngle =
										Math.abs(wrapperRotate) -
										Math.floor(Math.abs(wrapperRotate) / 90) * 90;
									var multiplier =
										1.5 -
										(Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2 +
											Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2);
									var scale1 = params.shadowScale;
									var scale2 = params.shadowScale / multiplier;
									var offset = params.shadowOffset;
									$cubeShadowEl.transform(
										"scale3d(" +
											scale1 +
											", 1, " +
											scale2 +
											") translate3d(0px, " +
											(swiperHeight / 2 + offset) +
											"px, " +
											-swiperHeight / 2 / scale2 +
											"px) rotateX(-90deg)"
									);
								}
							}
							var zFactor =
								Browser.isSafari || Browser.isUiWebView ? -swiperSize / 2 : 0;
							$wrapperEl.transform(
								"translate3d(0px,0," +
									zFactor +
									"px) rotateX(" +
									(swiper.isHorizontal() ? 0 : wrapperRotate) +
									"deg) rotateY(" +
									(swiper.isHorizontal() ? -wrapperRotate : 0) +
									"deg)"
							);
						},
						setTransition: function setTransition(duration) {
							var swiper = this;
							var $el = swiper.$el;
							var slides = swiper.slides;
							slides
								.transition(duration)
								.find(
									".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
								)
								.transition(duration);
							if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
								$el.find(".swiper-cube-shadow").transition(duration);
							}
						},
					};
					var EffectCube = {
						name: "effect-cube",
						params: {
							cubeEffect: {
								slideShadows: true,
								shadow: true,
								shadowOffset: 20,
								shadowScale: 0.94,
							},
						},
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								cubeEffect: {
									setTranslate: Cube.setTranslate.bind(swiper),
									setTransition: Cube.setTransition.bind(swiper),
								},
							});
						},
						on: {
							beforeInit: function beforeInit() {
								var swiper = this;
								if (swiper.params.effect !== "cube") {
									return;
								}
								swiper.classNames.push(
									swiper.params.containerModifierClass + "cube"
								);
								swiper.classNames.push(
									swiper.params.containerModifierClass + "3d"
								);
								var overwriteParams = {
									slidesPerView: 1,
									slidesPerColumn: 1,
									slidesPerGroup: 1,
									watchSlidesProgress: true,
									resistanceRatio: 0,
									spaceBetween: 0,
									centeredSlides: false,
									virtualTranslate: true,
								};
								Utils.extend(swiper.params, overwriteParams);
								Utils.extend(swiper.originalParams, overwriteParams);
							},
							setTranslate: function setTranslate() {
								var swiper = this;
								if (swiper.params.effect !== "cube") {
									return;
								}
								swiper.cubeEffect.setTranslate();
							},
							setTransition: function setTransition(duration) {
								var swiper = this;
								if (swiper.params.effect !== "cube") {
									return;
								}
								swiper.cubeEffect.setTransition(duration);
							},
						},
					};
					var Flip = {
						setTranslate: function setTranslate() {
							var swiper = this;
							var slides = swiper.slides;
							var rtl = swiper.rtlTranslate;
							for (var i = 0; i < slides.length; i += 1) {
								var $slideEl = slides.eq(i);
								var progress = $slideEl[0].progress;
								if (swiper.params.flipEffect.limitRotation) {
									progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
								}
								var offset = $slideEl[0].swiperSlideOffset;
								var rotate = -180 * progress;
								var rotateY = rotate;
								var rotateX = 0;
								var tx = -offset;
								var ty = 0;
								if (!swiper.isHorizontal()) {
									ty = tx;
									tx = 0;
									rotateX = -rotateY;
									rotateY = 0;
								} else if (rtl) {
									rotateY = -rotateY;
								}
								$slideEl[0].style.zIndex =
									-Math.abs(Math.round(progress)) + slides.length;
								if (swiper.params.flipEffect.slideShadows) {
									var shadowBefore = swiper.isHorizontal()
										? $slideEl.find(".swiper-slide-shadow-left")
										: $slideEl.find(".swiper-slide-shadow-top");
									var shadowAfter = swiper.isHorizontal()
										? $slideEl.find(".swiper-slide-shadow-right")
										: $slideEl.find(".swiper-slide-shadow-bottom");
									if (shadowBefore.length === 0) {
										shadowBefore = $(
											'<div class="swiper-slide-shadow-' +
												(swiper.isHorizontal() ? "left" : "top") +
												'"></div>'
										);
										$slideEl.append(shadowBefore);
									}
									if (shadowAfter.length === 0) {
										shadowAfter = $(
											'<div class="swiper-slide-shadow-' +
												(swiper.isHorizontal() ? "right" : "bottom") +
												'"></div>'
										);
										$slideEl.append(shadowAfter);
									}
									if (shadowBefore.length) {
										shadowBefore[0].style.opacity = Math.max(-progress, 0);
									}
									if (shadowAfter.length) {
										shadowAfter[0].style.opacity = Math.max(progress, 0);
									}
								}
								$slideEl.transform(
									"translate3d(" +
										tx +
										"px, " +
										ty +
										"px, 0px) rotateX(" +
										rotateX +
										"deg) rotateY(" +
										rotateY +
										"deg)"
								);
							}
						},
						setTransition: function setTransition(duration) {
							var swiper = this;
							var slides = swiper.slides;
							var activeIndex = swiper.activeIndex;
							var $wrapperEl = swiper.$wrapperEl;
							slides
								.transition(duration)
								.find(
									".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
								)
								.transition(duration);
							if (swiper.params.virtualTranslate && duration !== 0) {
								var eventTriggered = false;
								slides
									.eq(activeIndex)
									.transitionEnd(function onTransitionEnd() {
										if (eventTriggered) {
											return;
										}
										if (!swiper || swiper.destroyed) {
											return;
										}
										eventTriggered = true;
										swiper.animating = false;
										var triggerEvents = [
											"webkitTransitionEnd",
											"transitionend",
										];
										for (var i = 0; i < triggerEvents.length; i += 1) {
											$wrapperEl.trigger(triggerEvents[i]);
										}
									});
							}
						},
					};
					var EffectFlip = {
						name: "effect-flip",
						params: { flipEffect: { slideShadows: true, limitRotation: true } },
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								flipEffect: {
									setTranslate: Flip.setTranslate.bind(swiper),
									setTransition: Flip.setTransition.bind(swiper),
								},
							});
						},
						on: {
							beforeInit: function beforeInit() {
								var swiper = this;
								if (swiper.params.effect !== "flip") {
									return;
								}
								swiper.classNames.push(
									swiper.params.containerModifierClass + "flip"
								);
								swiper.classNames.push(
									swiper.params.containerModifierClass + "3d"
								);
								var overwriteParams = {
									slidesPerView: 1,
									slidesPerColumn: 1,
									slidesPerGroup: 1,
									watchSlidesProgress: true,
									spaceBetween: 0,
									virtualTranslate: true,
								};
								Utils.extend(swiper.params, overwriteParams);
								Utils.extend(swiper.originalParams, overwriteParams);
							},
							setTranslate: function setTranslate() {
								var swiper = this;
								if (swiper.params.effect !== "flip") {
									return;
								}
								swiper.flipEffect.setTranslate();
							},
							setTransition: function setTransition(duration) {
								var swiper = this;
								if (swiper.params.effect !== "flip") {
									return;
								}
								swiper.flipEffect.setTransition(duration);
							},
						},
					};
					var Coverflow = {
						setTranslate: function setTranslate() {
							var swiper = this;
							var swiperWidth = swiper.width;
							var swiperHeight = swiper.height;
							var slides = swiper.slides;
							var $wrapperEl = swiper.$wrapperEl;
							var slidesSizesGrid = swiper.slidesSizesGrid;
							var params = swiper.params.coverflowEffect;
							var isHorizontal = swiper.isHorizontal();
							var transform = swiper.translate;
							var center = isHorizontal
								? -transform + swiperWidth / 2
								: -transform + swiperHeight / 2;
							var rotate = isHorizontal ? params.rotate : -params.rotate;
							var translate = params.depth;
							for (var i = 0, length = slides.length; i < length; i += 1) {
								var $slideEl = slides.eq(i);
								var slideSize = slidesSizesGrid[i];
								var slideOffset = $slideEl[0].swiperSlideOffset;
								var offsetMultiplier =
									((center - slideOffset - slideSize / 2) / slideSize) *
									params.modifier;
								var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
								var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
								var translateZ = -translate * Math.abs(offsetMultiplier);
								var translateY = isHorizontal
									? 0
									: params.stretch * offsetMultiplier;
								var translateX = isHorizontal
									? params.stretch * offsetMultiplier
									: 0;
								if (Math.abs(translateX) < 0.001) {
									translateX = 0;
								}
								if (Math.abs(translateY) < 0.001) {
									translateY = 0;
								}
								if (Math.abs(translateZ) < 0.001) {
									translateZ = 0;
								}
								if (Math.abs(rotateY) < 0.001) {
									rotateY = 0;
								}
								if (Math.abs(rotateX) < 0.001) {
									rotateX = 0;
								}
								var slideTransform =
									"translate3d(" +
									translateX +
									"px," +
									translateY +
									"px," +
									translateZ +
									"px)  rotateX(" +
									rotateX +
									"deg) rotateY(" +
									rotateY +
									"deg)";
								$slideEl.transform(slideTransform);
								$slideEl[0].style.zIndex =
									-Math.abs(Math.round(offsetMultiplier)) + 1;
								if (params.slideShadows) {
									var $shadowBeforeEl = isHorizontal
										? $slideEl.find(".swiper-slide-shadow-left")
										: $slideEl.find(".swiper-slide-shadow-top");
									var $shadowAfterEl = isHorizontal
										? $slideEl.find(".swiper-slide-shadow-right")
										: $slideEl.find(".swiper-slide-shadow-bottom");
									if ($shadowBeforeEl.length === 0) {
										$shadowBeforeEl = $(
											'<div class="swiper-slide-shadow-' +
												(isHorizontal ? "left" : "top") +
												'"></div>'
										);
										$slideEl.append($shadowBeforeEl);
									}
									if ($shadowAfterEl.length === 0) {
										$shadowAfterEl = $(
											'<div class="swiper-slide-shadow-' +
												(isHorizontal ? "right" : "bottom") +
												'"></div>'
										);
										$slideEl.append($shadowAfterEl);
									}
									if ($shadowBeforeEl.length) {
										$shadowBeforeEl[0].style.opacity =
											offsetMultiplier > 0 ? offsetMultiplier : 0;
									}
									if ($shadowAfterEl.length) {
										$shadowAfterEl[0].style.opacity =
											-offsetMultiplier > 0 ? -offsetMultiplier : 0;
									}
								}
							}
							if (Support.pointerEvents || Support.prefixedPointerEvents) {
								var ws = $wrapperEl[0].style;
								ws.perspectiveOrigin = center + "px 50%";
							}
						},
						setTransition: function setTransition(duration) {
							var swiper = this;
							swiper.slides
								.transition(duration)
								.find(
									".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
								)
								.transition(duration);
						},
					};
					var EffectCoverflow = {
						name: "effect-coverflow",
						params: {
							coverflowEffect: {
								rotate: 50,
								stretch: 0,
								depth: 100,
								modifier: 1,
								slideShadows: true,
							},
						},
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								coverflowEffect: {
									setTranslate: Coverflow.setTranslate.bind(swiper),
									setTransition: Coverflow.setTransition.bind(swiper),
								},
							});
						},
						on: {
							beforeInit: function beforeInit() {
								var swiper = this;
								if (swiper.params.effect !== "coverflow") {
									return;
								}
								swiper.classNames.push(
									swiper.params.containerModifierClass + "coverflow"
								);
								swiper.classNames.push(
									swiper.params.containerModifierClass + "3d"
								);
								swiper.params.watchSlidesProgress = true;
								swiper.originalParams.watchSlidesProgress = true;
							},
							setTranslate: function setTranslate() {
								var swiper = this;
								if (swiper.params.effect !== "coverflow") {
									return;
								}
								swiper.coverflowEffect.setTranslate();
							},
							setTransition: function setTransition(duration) {
								var swiper = this;
								if (swiper.params.effect !== "coverflow") {
									return;
								}
								swiper.coverflowEffect.setTransition(duration);
							},
						},
					};
					var Thumbs = {
						init: function init() {
							var swiper = this;
							var ref = swiper.params;
							var thumbsParams = ref.thumbs;
							var SwiperClass = swiper.constructor;
							if (thumbsParams.swiper instanceof SwiperClass) {
								swiper.thumbs.swiper = thumbsParams.swiper;
								Utils.extend(swiper.thumbs.swiper.originalParams, {
									watchSlidesProgress: true,
									slideToClickedSlide: false,
								});
								Utils.extend(swiper.thumbs.swiper.params, {
									watchSlidesProgress: true,
									slideToClickedSlide: false,
								});
							} else if (Utils.isObject(thumbsParams.swiper)) {
								swiper.thumbs.swiper = new SwiperClass(
									Utils.extend({}, thumbsParams.swiper, {
										watchSlidesVisibility: true,
										watchSlidesProgress: true,
										slideToClickedSlide: false,
									})
								);
								swiper.thumbs.swiperCreated = true;
							}
							swiper.thumbs.swiper.$el.addClass(
								swiper.params.thumbs.thumbsContainerClass
							);
							swiper.thumbs.swiper.on("tap", swiper.thumbs.onThumbClick);
						},
						onThumbClick: function onThumbClick() {
							var swiper = this;
							var thumbsSwiper = swiper.thumbs.swiper;
							if (!thumbsSwiper) {
								return;
							}
							var clickedIndex = thumbsSwiper.clickedIndex;
							var clickedSlide = thumbsSwiper.clickedSlide;
							if (
								clickedSlide &&
								$(clickedSlide).hasClass(
									swiper.params.thumbs.slideThumbActiveClass
								)
							) {
								return;
							}
							if (
								typeof clickedIndex === "undefined" ||
								clickedIndex === null
							) {
								return;
							}
							var slideToIndex;
							if (thumbsSwiper.params.loop) {
								slideToIndex = parseInt(
									$(thumbsSwiper.clickedSlide).attr("data-swiper-slide-index"),
									10
								);
							} else {
								slideToIndex = clickedIndex;
							}
							if (swiper.params.loop) {
								var currentIndex = swiper.activeIndex;
								if (
									swiper.slides
										.eq(currentIndex)
										.hasClass(swiper.params.slideDuplicateClass)
								) {
									swiper.loopFix();
									swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
									currentIndex = swiper.activeIndex;
								}
								var prevIndex = swiper.slides
									.eq(currentIndex)
									.prevAll('[data-swiper-slide-index="' + slideToIndex + '"]')
									.eq(0)
									.index();
								var nextIndex = swiper.slides
									.eq(currentIndex)
									.nextAll('[data-swiper-slide-index="' + slideToIndex + '"]')
									.eq(0)
									.index();
								if (typeof prevIndex === "undefined") {
									slideToIndex = nextIndex;
								} else if (typeof nextIndex === "undefined") {
									slideToIndex = prevIndex;
								} else if (
									nextIndex - currentIndex <
									currentIndex - prevIndex
								) {
									slideToIndex = nextIndex;
								} else {
									slideToIndex = prevIndex;
								}
							}
							swiper.slideTo(slideToIndex);
						},
						update: function update(initial) {
							var swiper = this;
							var thumbsSwiper = swiper.thumbs.swiper;
							if (!thumbsSwiper) {
								return;
							}
							var slidesPerView =
								thumbsSwiper.params.slidesPerView === "auto"
									? thumbsSwiper.slidesPerViewDynamic()
									: thumbsSwiper.params.slidesPerView;
							if (swiper.realIndex !== thumbsSwiper.realIndex) {
								var currentThumbsIndex = thumbsSwiper.activeIndex;
								var newThumbsIndex;
								if (thumbsSwiper.params.loop) {
									if (
										thumbsSwiper.slides
											.eq(currentThumbsIndex)
											.hasClass(thumbsSwiper.params.slideDuplicateClass)
									) {
										thumbsSwiper.loopFix();
										thumbsSwiper._clientLeft =
											thumbsSwiper.$wrapperEl[0].clientLeft;
										currentThumbsIndex = thumbsSwiper.activeIndex;
									}
									var prevThumbsIndex = thumbsSwiper.slides
										.eq(currentThumbsIndex)
										.prevAll(
											'[data-swiper-slide-index="' + swiper.realIndex + '"]'
										)
										.eq(0)
										.index();
									var nextThumbsIndex = thumbsSwiper.slides
										.eq(currentThumbsIndex)
										.nextAll(
											'[data-swiper-slide-index="' + swiper.realIndex + '"]'
										)
										.eq(0)
										.index();
									if (typeof prevThumbsIndex === "undefined") {
										newThumbsIndex = nextThumbsIndex;
									} else if (typeof nextThumbsIndex === "undefined") {
										newThumbsIndex = prevThumbsIndex;
									} else if (
										nextThumbsIndex - currentThumbsIndex ===
										currentThumbsIndex - prevThumbsIndex
									) {
										newThumbsIndex = currentThumbsIndex;
									} else if (
										nextThumbsIndex - currentThumbsIndex <
										currentThumbsIndex - prevThumbsIndex
									) {
										newThumbsIndex = nextThumbsIndex;
									} else {
										newThumbsIndex = prevThumbsIndex;
									}
								} else {
									newThumbsIndex = swiper.realIndex;
								}
								if (
									thumbsSwiper.visibleSlidesIndexes &&
									thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0
								) {
									if (thumbsSwiper.params.centeredSlides) {
										if (newThumbsIndex > currentThumbsIndex) {
											newThumbsIndex =
												newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
										} else {
											newThumbsIndex =
												newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
										}
									} else if (newThumbsIndex > currentThumbsIndex) {
										newThumbsIndex = newThumbsIndex - slidesPerView + 1;
									}
									thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
								}
							}
							var thumbsToActivate = 1;
							var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
							if (
								swiper.params.slidesPerView > 1 &&
								!swiper.params.centeredSlides
							) {
								thumbsToActivate = swiper.params.slidesPerView;
							}
							thumbsSwiper.slides.removeClass(thumbActiveClass);
							if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual) {
								for (var i = 0; i < thumbsToActivate; i += 1) {
									thumbsSwiper.$wrapperEl
										.children(
											'[data-swiper-slide-index="' +
												(swiper.realIndex + i) +
												'"]'
										)
										.addClass(thumbActiveClass);
								}
							} else {
								for (var i$1 = 0; i$1 < thumbsToActivate; i$1 += 1) {
									thumbsSwiper.slides
										.eq(swiper.realIndex + i$1)
										.addClass(thumbActiveClass);
								}
							}
						},
					};
					var Thumbs$1 = {
						name: "thumbs",
						params: {
							thumbs: {
								swiper: null,
								slideThumbActiveClass: "swiper-slide-thumb-active",
								thumbsContainerClass: "swiper-container-thumbs",
							},
						},
						create: function create() {
							var swiper = this;
							Utils.extend(swiper, {
								thumbs: {
									swiper: null,
									init: Thumbs.init.bind(swiper),
									update: Thumbs.update.bind(swiper),
									onThumbClick: Thumbs.onThumbClick.bind(swiper),
								},
							});
						},
						on: {
							beforeInit: function beforeInit() {
								var swiper = this;
								var ref = swiper.params;
								var thumbs = ref.thumbs;
								if (!thumbs || !thumbs.swiper) {
									return;
								}
								swiper.thumbs.init();
								swiper.thumbs.update(true);
							},
							slideChange: function slideChange() {
								var swiper = this;
								if (!swiper.thumbs.swiper) {
									return;
								}
								swiper.thumbs.update();
							},
							update: function update() {
								var swiper = this;
								if (!swiper.thumbs.swiper) {
									return;
								}
								swiper.thumbs.update();
							},
							resize: function resize() {
								var swiper = this;
								if (!swiper.thumbs.swiper) {
									return;
								}
								swiper.thumbs.update();
							},
							observerUpdate: function observerUpdate() {
								var swiper = this;
								if (!swiper.thumbs.swiper) {
									return;
								}
								swiper.thumbs.update();
							},
							setTransition: function setTransition(duration) {
								var swiper = this;
								var thumbsSwiper = swiper.thumbs.swiper;
								if (!thumbsSwiper) {
									return;
								}
								thumbsSwiper.setTransition(duration);
							},
							beforeDestroy: function beforeDestroy() {
								var swiper = this;
								var thumbsSwiper = swiper.thumbs.swiper;
								if (!thumbsSwiper) {
									return;
								}
								if (swiper.thumbs.swiperCreated && thumbsSwiper) {
									thumbsSwiper.destroy();
								}
							},
						},
					};
					var components = [
						Device$1,
						Support$1,
						Browser$1,
						Resize,
						Observer$1,
						Virtual$1,
						Keyboard$1,
						Mousewheel$1,
						Navigation$1,
						Pagination$1,
						Scrollbar$1,
						Parallax$1,
						Zoom$1,
						Lazy$1,
						Controller$1,
						A11y,
						History$1,
						HashNavigation$1,
						Autoplay$1,
						EffectFade,
						EffectCube,
						EffectFlip,
						EffectCoverflow,
						Thumbs$1,
					];
					if (typeof Swiper.use === "undefined") {
						Swiper.use = Swiper.Class.use;
						Swiper.installModule = Swiper.Class.installModule;
					}
					Swiper.use(components);
					return Swiper;
				});
			},
			{},
		],
		57: [
			function (require, module, exports) {
				module.exports = toArray;
				function toArray(list, index) {
					var array = [];
					index = index || 0;
					for (var i = index || 0; i < list.length; i++) {
						array[i - index] = list[i];
					}
					return array;
				}
			},
			{},
		],
		58: [
			function (require, module, exports) {
				(function (global, factory) {
					typeof exports === "object" && typeof module !== "undefined"
						? (module.exports = factory())
						: typeof define === "function" && define.amd
						? define(factory)
						: (global.vhCheck = factory());
				})(this, function () {
					"use strict";
					var __assign = function () {
						__assign =
							Object.assign ||
							function __assign(t) {
								for (var s, i = 1, n = arguments.length; i < n; i++) {
									s = arguments[i];
									for (var p in s)
										if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
								}
								return t;
							};
						return __assign.apply(this, arguments);
					};
					function createTestElement() {
						var testElement = document.createElement("div");
						testElement.style.cssText =
							"position: fixed; top: 0; height: 100vh; pointer-events: none;";
						document.documentElement.insertBefore(
							testElement,
							document.documentElement.firstChild
						);
						return testElement;
					}
					function removeTestElement(element) {
						document.documentElement.removeChild(element);
					}
					function checkSizes() {
						var vhTest = createTestElement();
						var windowHeight = window.innerHeight;
						var vh = vhTest.offsetHeight;
						var offset = vh - windowHeight;
						removeTestElement(vhTest);
						return {
							vh: vh,
							windowHeight: windowHeight,
							offset: offset,
							isNeeded: offset !== 0,
							value: 0,
						};
					}
					function noop() {}
					function computeDifference() {
						var sizes = checkSizes();
						sizes.value = sizes.offset;
						return sizes;
					}
					function redefineVhUnit() {
						var sizes = checkSizes();
						sizes.value = sizes.windowHeight * 0.01;
						return sizes;
					}
					var methods = Object.freeze({
						noop: noop,
						computeDifference: computeDifference,
						redefineVhUnit: redefineVhUnit,
					});
					function isString(text) {
						return typeof text === "string" && text.length > 0;
					}
					function isFunction(f) {
						return typeof f === "function";
					}
					var defaultOptions = Object.freeze({
						cssVarName: "vh-offset",
						redefineVh: false,
						method: computeDifference,
						force: false,
						bind: true,
						updateOnTouch: false,
						onUpdate: noop,
					});
					function getOptions(options) {
						if (isString(options)) {
							return __assign({}, defaultOptions, { cssVarName: options });
						}
						if (typeof options !== "object") return defaultOptions;
						var finalOptions = {
							force: options.force === true,
							bind: options.bind !== false,
							updateOnTouch: options.updateOnTouch === true,
							onUpdate: isFunction(options.onUpdate) ? options.onUpdate : noop,
						};
						var redefineVh = options.redefineVh === true;
						finalOptions.method =
							methods[redefineVh ? "redefineVhUnit" : "computeDifference"];
						finalOptions.cssVarName = isString(options.cssVarName)
							? options.cssVarName
							: redefineVh
							? "vh"
							: defaultOptions.cssVarName;
						return finalOptions;
					}
					var passiveSupported = false;
					var eventListeners = [];
					try {
						var options = Object.defineProperty({}, "passive", {
							get: function () {
								passiveSupported = true;
							},
						});
						window.addEventListener("test", options, options);
						window.removeEventListener("test", options, options);
					} catch (err) {
						passiveSupported = false;
					}
					function addListener(eventName, callback) {
						eventListeners.push({ eventName: eventName, callback: callback });
						window.addEventListener(
							eventName,
							callback,
							passiveSupported ? { passive: true } : false
						);
					}
					function removeAll() {
						eventListeners.forEach(function (config) {
							window.removeEventListener(config.eventName, config.callback);
						});
						eventListeners = [];
					}
					function updateCssVar(cssVarName, result) {
						document.documentElement.style.setProperty(
							"--" + cssVarName,
							result.value + "px"
						);
					}
					function formatResult(sizes, options) {
						return __assign({}, sizes, {
							unbind: removeAll,
							recompute: options.method,
						});
					}
					function vhCheck(options) {
						var config = Object.freeze(getOptions(options));
						var result = formatResult(config.method(), config);
						if (!result.isNeeded && !config.force) {
							return result;
						}
						updateCssVar(config.cssVarName, result);
						config.onUpdate(result);
						if (!config.bind) return result;
						function onWindowChange() {
							window.requestAnimationFrame(function () {
								var sizes = config.method();
								updateCssVar(config.cssVarName, sizes);
								config.onUpdate(formatResult(sizes, config));
							});
						}
						result.unbind();
						addListener("orientationchange", onWindowChange);
						if (config.updateOnTouch) {
							addListener("touchmove", onWindowChange);
						}
						return result;
					}
					return vhCheck;
				});
			},
			{},
		],
		59: [
			function (require, module, exports) {
				"use strict";
				var gsap = require("gsap/dist/gsap").gsap;
				var TextPlugin = require("gsap/dist/TextPlugin").TextPlugin;
				function CursorAnimation() {
					this.customCursor = document.querySelector(".custom-cursor");
					if (!this.customCursor) return;
					this.customCursorBounds = this.customCursor.getBoundingClientRect();
					this.cursorTimeline = null;
					this._init();
				}
				CursorAnimation.prototype._init = function () {
					var self = this;
					gsap.registerPlugin(TextPlugin);
					gsap.set(this.customCursor, { visibility: "visible" });
					window.addEventListener("mousemove", this._onMouseMove.bind(this));
					document
						.querySelectorAll(".custom-cursor-anim")
						.forEach(function (el) {
							const isBubble = el.dataset.cursorBubble === "true";
							const isMouseOver = el.dataset.cursorOver === "true";
							const circle = el.dataset.cursorCircle
								? JSON.parse(el.dataset.cursorCircle)
								: undefined;
							const arrow = el.dataset.cursorArrow
								? JSON.parse(el.dataset.cursorArrow)
								: undefined;
							const text = el.dataset.cursorText
								? JSON.parse(el.dataset.cursorText)
								: undefined;
							const panel = el.dataset.cursorPanel
								? JSON.parse(el.dataset.cursorPanel)
								: undefined;
							self._handleCursorAnimation(
								el,
								function () {
									var tl = gsap.timeline();
									tl.add("begin");
									if (circle) {
										var circleColor = circle[0];
										if (el.classList.contains("menu-button")) {
											if (el.classList.contains("menu-button--light"))
												circleColor = "white";
											else circleColor = "black";
										}
										tl.add(self._animCircleColor(circleColor), "begin");
										tl.add(
											self._animCircleRadius(circle[1], circle[2]),
											"begin"
										);
									}
									if (arrow) {
										if (arrow[0] === "0") {
											tl.add(self._animArrowAlpha(arrow[0]), "begin");
										} else if (arrow[0] === "1") {
											tl.add(self._animArrowAlpha(arrow[0]), "begin+=0.2");
											tl.add(self._animArrowColor(arrow[1]), "begin");
											tl.add(self._animArrowRotate(arrow[2]), "begin");
										}
									}
									if (text) {
										if (text[0] === "0") {
											tl.add(self._animTextAlpha(text[0]), "begin");
										} else if (text[0] === "1") {
											tl.add(self._animTextAlpha(text[0]), "begin+=0.2");
											tl.add(self._animTextColor(text[1]), "begin");
											tl.set(
												".custom-cursor .text",
												{ text: text[2] },
												"begin"
											);
										}
									}
									if (panel) {
										if (panel[0] === "1") {
											document.querySelector(
												".custom-cursor .hover-panel"
											).src = panel[1] ? panel[1] : el.querySelector("img").src;
										}
										tl.add(self._animPanelAlpha(panel[0]), "begin");
									}
									return tl;
								},
								isBubble,
								isMouseOver
							);
						});
				};
				CursorAnimation.prototype._onMouseMove = function (e) {
					var self = this;
					var x = e.clientX - this.customCursorBounds.width / 2;
					var y = e.clientY - this.customCursorBounds.height / 2;
					requestAnimationFrame(function () {
						self._updateMouse(x, y);
					});
				};
				CursorAnimation.prototype._updateMouse = function (x, y) {
					this.customCursor.style.transform =
						"translate(" + x + "px, " + y + "px)";
				};
				CursorAnimation.prototype._handleCursorAnimation = function (
					section,
					timeline,
					isStopBubble,
					isMouseOver
				) {
					if (!(section instanceof Element))
						section = document.querySelector(section);
					section.addEventListener(
						isMouseOver ? "mouseover" : "mouseenter",
						function (e) {
							if (isStopBubble) e.stopPropagation();
							this.cursorTimeline = gsap.timeline();
							this.cursorTimeline.add(timeline());
						}.bind(this)
					);
					section.addEventListener(
						isMouseOver ? "mouseout" : "mouseleave",
						function () {
							if (this.cursorTimeline) this.cursorTimeline.progress(1).kill();
						}.bind(this)
					);
				};
				CursorAnimation.prototype._animCircleRadius = function (r, ease) {
					var tl = gsap.timeline();
					tl.to(".custom-cursor circle", { r: r, duration: 0.3, ease: ease });
					return tl;
				};
				CursorAnimation.prototype._animCircleColor = function (color) {
					var tl = gsap.timeline();
					tl.to(".custom-cursor circle", {
						fill: color,
						duration: 0.2,
						ease: "none",
					});
					return tl;
				};
				CursorAnimation.prototype._animArrowAlpha = function (alpha) {
					var tl = gsap.timeline();
					tl.to(".custom-cursor .arrow", { opacity: alpha, duration: 0.1 });
					return tl;
				};
				CursorAnimation.prototype._animArrowColor = function (color) {
					var tl = gsap.timeline();
					tl.to(".custom-cursor .arrow", { stroke: color, duration: 0.1 });
					return tl;
				};
				CursorAnimation.prototype._animArrowRotate = function (deg) {
					var tl = gsap.timeline();
					tl.to(".custom-cursor .arrow", {
						rotation: deg,
						transformOrigin: "50% 50%",
						duration: 0.1,
					});
					return tl;
				};
				CursorAnimation.prototype._animTextAlpha = function (alpha) {
					var tl = gsap.timeline();
					tl.to(".custom-cursor .text", { opacity: alpha, duration: 0.1 });
					return tl;
				};
				CursorAnimation.prototype._animTextColor = function (color) {
					var tl = gsap.timeline();
					tl.to(".custom-cursor .text", { color: color, duration: 0.1 });
					return tl;
				};
				CursorAnimation.prototype._animPanelAlpha = function (alpha) {
					var tl = gsap.timeline();
					tl.to(".custom-cursor .hover-panel", {
						opacity: alpha,
						duration: 0.1,
					});
					return tl;
				};
				CursorAnimation.prototype.destroy = function () {
					if (this.customCursor) {
						window.removeEventListener("mousemove", this._onMouseMove);
					}
				};
				module.exports = CursorAnimation;
			},
			{ "gsap/dist/TextPlugin": 6, "gsap/dist/gsap": 7 },
		],
		60: [
			function (require, module, exports) {
				const DetectDevice = require("./utils/detect-device");
				const detectDevice = new DetectDevice();
				const Favicon = require("./home/favicon");
				const MenuNav = require("./home/menuNav");
				const CustomCursor = require("./animations/cursor-animation");
				const SectionAnimations = require("./home/sectionAnimations");
				const SectionSnap = require("./home/sectionSnap");
				const HeroReel = require("./home/heroReel");
				const SlackReactions = require("./home/slackReactions");
				const VHCheck = require("vh-check");
				const heroReel = new HeroReel();
				const vhCheck = new VHCheck();
				const customCursor = new CustomCursor();
			},
			{
				"./animations/cursor-animation": 59,
				"./home/favicon": 62,
				"./home/heroReel": 63,
				"./home/menuNav": 64,
				"./home/sectionAnimations": 65,
				"./home/sectionSnap": 66,
				"./home/slackReactions": 67,
				"./utils/detect-device": 69,
				"vh-check": 58,
			},
		],
		61: [
			function (require, module, exports) {
				"use strict";
				var shuffle = require("lodash/shuffle");
				const WFH_CITIES = shuffle([
					"Aliso Viejo, CA",
					"Astoria, NY",
					"Austin, TX",
					"Berkeley, CA",
					"Brooklyn, NY",
					"Burbank, CA",
					"Cedar Grove, NJ",
					"Chappaqua, NY",
					"Chicago, IL",
					"Concord, CA",
					"East Palo Alto, CA",
					"Evanston, IL",
					"Fern Park, FL",
					"Fort Worth, TX",
					"Hewlett, NY",
					"Hoboken, NJ",
					"Holmes, NY",
					"Irvine, CA",
					"Jersey City, NJ",
					"Los Angeles, CA",
					"Mamaroneck, NY",
					"Marina del Rey, CA",
					"Merrick, NY",
					"Milwaukie, OR",
					"Missouri City, TX",
					"Morgan Hill, CA",
					"Mountain View, CA",
					"New York, NY",
					"Newcastle, CA",
					"Novi, MI",
					"Oakland, CA",
					"Petaluma, CA",
					"Philadelphia, PA",
					"Pittsburgh, PA",
					"Portland, OR",
					"Rego Park, NY",
					"Ridgewood, NY",
					"San Francisco, CA",
					"San Jose, CA",
					"San Ramon, CA",
					"Santa Monica, CA",
					"Schaumburg, IL",
					"Seattle, WA",
					"Solon, OH",
					"Solvang, CA",
					"South Jordan, UT",
					"Templeton, CA",
					"Tulsa, OK",
					"Waterbury, VT",
					"West Orange, NJ",
				]);
				function WFHTicker() {
					this.wrapper = document.querySelector("footer .wfh .ticker-wrapper");
					if (!this.wrapper) return;
					this.ul = this.wrapper.querySelector("ul");
					this.wfhInterval = null;
					this.duration = 400;
					this.delay = 1200;
					this.step = 0;
					this.y = 0;
					this.init();
				}
				WFHTicker.prototype.init = function () {
					const that = this;
					this.render();
					WFH_CITIES.forEach(function (item, i) {
						that.ul.insertAdjacentHTML("beforeend", "<li>" + item + "</li>");
						that.ul.children[i].insertAdjacentHTML(
							"beforebegin",
							"<li>" + item + "</li>"
						);
					});
					this.ul.children[1].classList.add("active");
				};
				WFHTicker.prototype.updateStep = function () {
					this.step = (this.step % WFH_CITIES.length) + 1;
					if (this.step === 1) {
						this.y = 0;
						this.duration = 0;
						this.ul.children[WFH_CITIES.length + 1].classList.remove("active");
						this.render();
					}
					this.ul.children[this.step].classList.remove("active");
					this.ul.children[this.step + 1].classList.add("active");
					this.y -= this.ul.children[this.step - 1].offsetHeight;
					this.duration = 400;
					this.render();
				};
				WFHTicker.prototype.render = function () {
					this.wrapper.style.setProperty("--duration", this.duration + "ms");
					this.wrapper.style.setProperty("--y", this.y + "px");
					this.wrapper.style.setProperty(
						"--h",
						this.ul.offsetHeight / 2 + "px"
					);
				};
				WFHTicker.prototype.start = function () {
					this.wfhInterval = setInterval(
						this.updateStep.bind(this),
						this.delay
					);
				};
				module.exports = WFHTicker;
				WFHTicker.prototype.destroy = function () {
					clearInterval(this.wfhInterval);
					this.wfhInterval = null;
				};
			},
			{ "lodash/shuffle": 51 },
		],
		62: [
			function (require, module, exports) {
				function collectLinks() {
					return Array.prototype.slice.apply(
						document.head.querySelectorAll('link[rel*="icon"]')
					);
				}
				function applyLink(source, target) {
					target.setAttribute("type", source.getAttribute("type"));
					target.setAttribute("href", source.getAttribute("href"));
				}
				function initSwitcher(delay) {
					if (typeof window.matchMedia !== "function") {
						return function noop() {};
					}
					var links = collectLinks();
					var current = document.createElement("link");
					var prevMatch;
					current.setAttribute("rel", "shortcut icon");
					document.head.appendChild(current);
					function faviconApplyLoop() {
						var matched;
						links.forEach(function (link) {
							if (window.matchMedia(link.media).matches) {
								matched = link;
							}
						});
						if (!matched) {
							return;
						}
						if (matched.media !== prevMatch) {
							prevMatch = matched.media;
							applyLink(matched, current);
						}
					}
					var intervalId = setInterval(faviconApplyLoop, delay || 300);
					function unsubscribe() {
						clearInterval(intervalId);
						links.forEach(function (link) {
							document.head.appendChild(link);
						});
					}
					faviconApplyLoop();
					links.forEach(function (link) {
						document.head.removeChild(link);
					});
					return unsubscribe;
				}
				initSwitcher();
			},
			{},
		],
		63: [
			function (require, module, exports) {
				var HLSVideos = require("../shared/hlsVideos");
				var gsap = require("gsap/dist/gsap").gsap;
				require("timeline-lite");
				require("draw-svg-plugin");
				function HeroReel() {
					this.loaderLineTimeline = null;
					this.loaderWaveTimeline = null;
					this._loaderAnimation();
					const el = document.querySelectorAll("#hero video");
					const videoExists = Array.from(el).length > 0;
					if (!videoExists) return;
					const reel = new HLSVideos(el);
					reel.size();
					window.setTimeout(
						function () {
							reel.start(
								function () {
									this.loaderLineTimeline.clear();
									this.loaderWaveTimeline.clear();
								}.bind(this)
							);
						}.bind(this),
						2e3
					);
				}
				HeroReel.prototype._loaderAnimation = function () {
					gsap.set(".video-loader svg .letter", { scale: 0.95, opacity: 0.8 });
					gsap.set(".video-loader svg", { visibility: "visible" });
					this.loaderLineTimeline = new TimelineLite({ repeat: -1 });
					this.loaderLineTimeline
						.fromTo(
							".video-loader svg .Top-X",
							1,
							{ drawSVG: 0 },
							{ drawSVG: true, duration: 0.4, ease: "sine.out" }
						)
						.fromTo(
							".video-loader svg .Bottom-X",
							1,
							{ drawSVG: 0 },
							{ drawSVG: true, duration: 0.4, ease: "sine.out" }
						);
					this.loaderWaveTimeline = gsap.timeline({ repeat: -1 });
					this.loaderWaveTimeline
						.staggerTo(
							".video-loader svg .letter",
							0.35,
							{ scale: 1.15, opacity: 1, ease: "sine.out" },
							0.16
						)
						.staggerTo(
							".video-loader svg .letter",
							0.35,
							{ scale: 0.95, opacity: 0.8, ease: "sine.out" },
							0.16,
							0.24
						);
				};
				module.exports = HeroReel;
			},
			{
				"../shared/hlsVideos": 68,
				"draw-svg-plugin": 72,
				"gsap/dist/gsap": 7,
				"timeline-lite": 70,
			},
		],
		64: [
			function (require, module, exports) {
				var gsap = require("gsap/dist/gsap").gsap;
				var navTrigger = document.querySelector(".nav-trigger .menu-icon");
				var navElement = document.querySelector(".case-study-navigation");
				var closeNavLink = document.querySelector(".close-navigation");
				navTrigger.addEventListener("click", function (e) {
					e.preventDefault();
					navElement.classList.add("in");
					document.documentElement.classList.add("nav-open");
					gsap.set(navElement, { zIndex: 1e3, marginLeft: 0 });
					gsap.to(navElement, { duration: 1, opacity: 1 });
					gsap.to(closeNavLink, {
						duration: 0.3,
						scale: 1,
						opacity: 1,
						delay: 0.5,
						ease: "back.out",
					});
				});
				closeNavLink.addEventListener("click", function (e) {
					e.preventDefault();
					navElement.classList.remove("in");
					document.documentElement.classList.remove("nav-open");
					gsap.to(closeNavLink, { duration: 0.3, scale: 0, ease: "back.out" });
					gsap.to(navElement, {
						duration: 0.3,
						opacity: 0,
						onComplete: function () {
							navElement.removeAttribute("style");
							closeNavLink.removeAttribute("style");
						},
					});
				});
			},
			{ "gsap/dist/gsap": 7 },
		],
		65: [
			function (require, module, exports) {
				var Swiper = require("swiper");
				var sample = require("lodash/sample");
				var gsap = require("gsap/dist/gsap").gsap;
				var ScrollTrigger = require("gsap/dist/ScrollTrigger").ScrollTrigger;
				var ScrollToPlugin = require("gsap/dist/ScrollToPlugin").ScrollToPlugin;
				var WFHTicker = require("./WFHTicker");
				var wfhTicker = new WFHTicker();
				const doc = document.documentElement;
				const TOUCH_DEVICE =
					doc.classList.contains("device-touch") ||
					doc.classList.contains("device-hybrid");
				gsap.registerPlugin(ScrollTrigger, ScrollToPlugin);
				function lazyLoadImage(trigger) {
					ScrollTrigger.create({
						trigger: trigger,
						onEnter: function () {
							document
								.querySelectorAll(trigger + " img.lazy")
								.forEach(function (image) {
									image.src = image.dataset.src;
								});
						},
					});
				}
				const bannerEl = document.querySelector(".alert-banner");
				const bannerOffset = bannerEl ? bannerEl.offsetHeight + 35 : 0;
				var sections = gsap.utils.toArray(".home main > section");
				sections.forEach(function (section) {
					ScrollTrigger.create({
						trigger: section,
						start: "top top+=" + bannerOffset + "px",
						end: "bottom top+=" + bannerOffset + "px",
						onToggle: function (self) {
							const menuButton = document.querySelector(".menu-button");
							if (self.isActive && section.classList.contains("theme--light")) {
								menuButton.classList.add("menu-button--light");
							} else if (
								self.isActive &&
								!section.classList.contains("theme--light")
							) {
								menuButton.classList.remove("menu-button--light");
							}
						},
					});
				});
				var partnersAllowUpdate = false;
				var partnersSwiper = new Swiper(".swiper-container", {
					watchSlidesProgress: true,
					slidesPerView: "auto",
					keyboard: { enabled: true },
					spaceBetween: 30,
					allowTouchMove: TOUCH_DEVICE ? true : false,
					width: 337,
					navigation: {
						nextEl: ".pager.next",
						prevEl: ".pager.prev",
						disabledClass: "swiper-button-disabled",
					},
					on: {
						slideChange: function () {
							var slideLength = this.slides.length;
							var nextEl = document.querySelector("#partners .pager.next");
							if (!TOUCH_DEVICE && this.slides[slideLength - 3].progress >= 0) {
								this.allowSlideNext = false;
								nextEl.classList.add("swiper-button-disabled");
							} else {
								this.allowSlideNext = true;
								nextEl.classList.remove("swiper-button-disabled");
							}
							for (var i = slideLength - 3; i < slideLength; i++) {
								var slide = this.slides[i];
								var progress = slide.progress;
								if (progress > -8) {
									gsap.set(slide, { visibility: "visible" });
								} else {
									gsap.set(slide, { visibility: "hidden" });
								}
							}
						},
						progress: function () {
							if (!partnersAllowUpdate) return;
							for (var i = 0; i < this.slides.length; i++) {
								var slide = this.slides[i];
								var progress = slide.progress;
								if (progress <= -3) {
									var n = -progress - 2;
									var offset = -15 * (3 * Math.pow(n, 2) + n + 2);
									gsap.set(slide, { x: offset });
								} else {
									gsap.set(slide, { x: 0 });
								}
							}
						},
					},
					breakpoints: {
						768: { spaceBetween: 20, width: 300 },
						0: { spaceBetween: 20, width: 264 },
					},
				});
				var time = 0;
				var delay = 0.05;
				var cardStaggerTimeline = gsap.timeline({
					defaults: { duration: 0.3, ease: "power4.in" },
					onComplete: function () {
						partnersAllowUpdate = true;
					},
				});
				cardStaggerTimeline.add("begin");
				var partnersCard = document.querySelectorAll("#partners .swiper-slide");
				partnersCard.forEach(function (card, index) {
					var cardWidth = card.offsetWidth;
					gsap.set(card, { x: -index * cardWidth });
				});
				partnersCard.forEach(function (card, index) {
					var n = index - 2;
					var staggerOffset = "begin+=" + time;
					if (index < 3) {
						cardStaggerTimeline.to(card, { x: 0 }, staggerOffset);
					} else {
						cardStaggerTimeline.to(
							card,
							{ x: -15 * (3 * Math.pow(n, 2) + n + 2) },
							staggerOffset
						);
					}
					if (index > 0) time += delay;
				});
				ScrollTrigger.create({
					animation: cardStaggerTimeline,
					trigger: "#partners",
					start: "top 55%",
				});
				document
					.querySelector("#trevor")
					.addEventListener("click", function () {
						if (!TOUCH_DEVICE) {
							window.location = "/case-studies/thetrevorproject";
						}
					});
				lazyLoadImage("#trevor");
				var trevorTimeline = gsap.timeline({ delay: 0.3 });
				trevorTimeline
					.from("#trevor figcaption", {
						opacity: 0,
						yPercent: 170,
						duration: 0.3,
					})
					.from("#trevor video", { opacity: 0, xPercent: -140, duration: 0.2 });
				ScrollTrigger.create({
					animation: trevorTimeline,
					trigger: "#trevor",
					start: "top center",
				});
				document
					.querySelector("#departures")
					.addEventListener("click", function () {
						if (!TOUCH_DEVICE) {
							window.open("https://www.departures.com/");
						}
					});
				var departuresTimeline = gsap.timeline({ delay: 0.3 });
				departuresTimeline
					.from("#departures figcaption", {
						opacity: 0,
						yPercent: 170,
						duration: 0.3,
					})
					.from("#departures video", {
						yPercent: 110,
						xPercent: -140,
						rotation: -10,
						duration: 0.2,
					});
				ScrollTrigger.create({
					animation: departuresTimeline,
					trigger: "#departures",
					start: "top center",
				});
				document
					.querySelector("#korres")
					.addEventListener("click", function () {
						if (!TOUCH_DEVICE) {
							window.location = "/case-studies/korres";
						}
					});
				lazyLoadImage("#korres");
				var korresTimeline = gsap.timeline({ delay: 0.3 });
				korresTimeline
					.from("#korres figcaption", {
						opacity: 0,
						yPercent: 170,
						duration: 0.3,
					})
					.from("#korres img", {
						yPercent: 110,
						xPercent: 140,
						rotation: 10,
						duration: 0.2,
					});
				ScrollTrigger.create({
					animation: korresTimeline,
					trigger: "#korres",
					start: "top center",
				});
				document.querySelector("#urby").addEventListener("click", function () {
					if (!TOUCH_DEVICE) {
						window.open(
							"https://www.urby.com/",
							"_blank",
							"noopener,noreferrer"
						);
					}
				});
				lazyLoadImage("#urby");
				var urbyTimeline = gsap.timeline({ delay: 0.3 });
				urbyTimeline
					.from("#urby figcaption", {
						opacity: 0,
						yPercent: 170,
						duration: 0.3,
					})
					.from("#urby img", { opacity: 0, xPercent: -140, duration: 0.2 });
				ScrollTrigger.create({
					animation: urbyTimeline,
					trigger: "#urby",
					start: "top center",
				});
				document.querySelector("#babe").addEventListener("click", function () {
					if (!TOUCH_DEVICE) {
						window.open(
							"http://babebyhatch.com",
							"_blank",
							"noopener,noreferrer"
						);
					}
				});
				lazyLoadImage("#babe");
				var babeTimeline = gsap.timeline({ delay: 0.3 });
				babeTimeline
					.from("#babe figcaption", {
						opacity: 0,
						yPercent: 170,
						duration: 0.3,
					})
					.from("#babe img", {
						yPercent: 110,
						xPercent: -140,
						rotation: -10,
						duration: 0.2,
					});
				ScrollTrigger.create({
					animation: babeTimeline,
					trigger: "#babe",
					start: "top center",
				});
				document
					.querySelector("#discover")
					.addEventListener("click", function () {
						if (!TOUCH_DEVICE) {
							window.open(
								"https://vimeo.com/showcase/8476804",
								"_blank",
								"noopener,noreferrer"
							);
						}
					});
				var discoverTimeline = gsap.timeline({ delay: 0.3 });
				discoverTimeline
					.from("#discover figcaption", {
						opacity: 0,
						y: "100vh",
						duration: 0.4,
					})
					.from("#discover video", { yPercent: 140, duration: 0.3 }, 0.3);
				ScrollTrigger.create({
					animation: discoverTimeline,
					trigger: "#discover",
					start: "top center",
				});
				document.querySelector("#ind").addEventListener("click", function () {
					if (!TOUCH_DEVICE) {
						window.location = "/our-action-plan-for-inclusion-and-diversity";
					}
				});
				var indTimeline = gsap.timeline({ delay: 0.3 });
				indTimeline.from("#ind figcaption", {
					opacity: 0,
					y: "50vh",
					duration: 0.4,
				});
				ScrollTrigger.create({
					animation: indTimeline,
					trigger: "#ind",
					start: "top center",
				});
				document.querySelectorAll("#news .item").forEach(function (el) {
					el.addEventListener("click", function (e) {
						if (e.target.classList.contains("cta")) {
							return true;
						}
						const link = el.querySelector("a").href;
						const newTab =
							el.querySelector("a").target === "_blank" ? "_blank" : "_self";
						const windowFeatures =
							newTab === "_blank" ? "noopener,noreferrer" : undefined;
						window.open(link, newTab, windowFeatures);
					});
				});
				var teamBgTimeline = gsap.timeline();
				teamBgTimeline
					.to("#team", { backgroundColor: "white", duration: 0.4 })
					.to("#news", { backgroundColor: "white", duration: 0.4 }, 0);
				ScrollTrigger.create({
					animation: teamBgTimeline,
					trigger: "#team",
					start: "top center",
					end: "top top",
					scrub: true,
				});
				const imageTypes = ["office"];
				const selectedType = sample(imageTypes);
				document.querySelectorAll("#team .team").forEach(function (img, index) {
					img.classList.add(selectedType);
				});
				ScrollTrigger.create({
					trigger: ".home footer",
					onToggle: function (scrollTrigger) {
						if (scrollTrigger.isActive) {
							wfhTicker.start();
						} else {
							wfhTicker.destroy();
						}
					},
				});
			},
			{
				"./WFHTicker": 61,
				"gsap/dist/ScrollToPlugin": 4,
				"gsap/dist/ScrollTrigger": 5,
				"gsap/dist/gsap": 7,
				"lodash/sample": 50,
				swiper: 56,
			},
		],
		66: [
			function (require, module, exports) {
				var gsap = require("gsap/dist/gsap").gsap;
				var ScrollToPlugin = require("gsap/dist/ScrollToPlugin").ScrollToPlugin;
				const SectionSnap = function () {
					const cachedSessionIndex = sessionStorage.getItem("hpSectionIndex");
					this.allowScroll = true;
					this.xDown = null;
					this.yDown = null;
					this.sectionIndex =
						cachedSessionIndex !== undefined ? cachedSessionIndex : 0;
					this.sectionsId = [
						"#hero",
						"#partners",
						"#trevor",
						"#departures",
						"#discover",
						"#korres",
						"#urby",
						"#babe",
						"#ind",
						"#news",
						"#team",
					];
					if (
						window.matchMedia(
							"(max-width: 766.98px) and (max-height: 799.98px)"
						).matches
					) {
						this.sectionsId.push(
							"#footer .contact-us",
							"#footer .footer-content"
						);
					} else {
						this.sectionsId.push("#footer");
					}
					this._init();
				};
				SectionSnap.prototype._init = function () {
					gsap.registerPlugin(ScrollToPlugin);
					var self = this;
					var supportsPassive = false;
					try {
						window.addEventListener(
							"test",
							null,
							Object.defineProperty({}, "passive", {
								get: function () {
									supportsPassive = true;
								},
							})
						);
					} catch (e) {}
					var wheelOpt = supportsPassive ? { passive: false } : false;
					window.addEventListener(
						"wheel",
						this._handleWheel.bind(this),
						wheelOpt
					);
					window.addEventListener(
						"touchstart",
						this._handleTouchStart.bind(this),
						wheelOpt
					);
					window.addEventListener(
						"touchmove",
						this._handleTouchMove.bind(this),
						wheelOpt
					);
					document
						.querySelectorAll(".next-section")
						.forEach(function (section) {
							section.addEventListener("click", function (e) {
								e.stopPropagation();
								self._goToSection("down");
							});
						});
					document.querySelectorAll("#hero video").forEach(function (video) {
						video.addEventListener(
							"ended",
							function () {
								if (self.sectionIndex === 0) self._goToSection("down");
							},
							false
						);
					});
					if ("scrollRestoration" in history) {
						history.scrollRestoration = "manual";
					}
					if (self.sectionIndex > 0) self._goToSection(self.sectionIndex);
					const heroArrow = document.querySelector("#hero .down-caret");
					if (heroArrow) {
						heroArrow.addEventListener("click", function (e) {
							e.stopPropagation();
							self._goToSection("down");
						});
					}
				};
				SectionSnap.prototype._goToSection = function (scrollDirection) {
					var self = this;
					if (
						(self.sectionIndex === self.sectionsId.length - 1 &&
							scrollDirection === "down") ||
						(self.sectionIndex < 1 && scrollDirection === "up")
					) {
						return;
					}
					var scrollDestination;
					if (scrollDirection === "up") {
						scrollDestination = self.sectionsId[--self.sectionIndex];
					} else if (scrollDirection === "down") {
						scrollDestination = self.sectionsId[++self.sectionIndex];
					} else {
						scrollDestination = self.sectionsId[self.sectionIndex];
					}
					self.allowScroll = false;
					gsap.to(document.body, {
						duration: 1.2,
						ease: "power3.inOut",
						scrollTo: scrollDestination,
						onComplete: function () {
							self.allowScroll = true;
						},
					});
					sessionStorage.setItem("hpSectionIndex", self.sectionIndex);
				};
				SectionSnap.prototype._handleWheel = function (e) {
					if (document.documentElement.classList.contains("nav-open")) return;
					e.preventDefault();
					if (e.deltaY < 0 && this.allowScroll) {
						this._goToSection("up");
					} else if (e.deltaY > 0 && this.allowScroll) {
						this._goToSection("down");
					}
				};
				SectionSnap.prototype._handleTouchStart = function (e) {
					const firstTouch = e.touches[0];
					this.xDown = firstTouch.clientX;
					this.yDown = firstTouch.clientY;
				};
				SectionSnap.prototype._handleTouchMove = function (e) {
					if (document.documentElement.classList.contains("nav-open")) return;
					e.preventDefault();
					if (!this.xDown || !this.yDown) return;
					const xUp = e.touches[0].clientX;
					const yUp = e.touches[0].clientY;
					const xDiff = this.xDown - xUp;
					const yDiff = this.yDown - yUp;
					if (Math.abs(yDiff) > Math.abs(xDiff) && this.allowScroll) {
						if (yDiff > 0) {
							this._goToSection("down");
						} else {
							this._goToSection("up");
						}
					}
					this.xDown = null;
					this.yDown = null;
				};
				const sectionSnap = new SectionSnap();
			},
			{ "gsap/dist/ScrollToPlugin": 4, "gsap/dist/gsap": 7 },
		],
		67: [
			function (require, module, exports) {
				var gsap = require("gsap/dist/gsap").gsap;
				var ScrollTrigger = require("gsap/dist/ScrollTrigger").ScrollTrigger;
				gsap.registerPlugin(ScrollTrigger);
				const recent_slack_reactions = window.recent_slack_reactions || [
					"",
					"",
					"",
					"",
					"",
					"",
					"",
					"",
				];
				const container_el = document.querySelector(".js-slack-reactions");
				if (container_el === null) {
					return;
				}
				function getRandomInt(min, max) {
					min = Math.ceil(min);
					max = Math.floor(max);
					return Math.floor(Math.random() * (max - min)) + min;
				}
				recent_slack_reactions.forEach(function (el, i) {
					var random_x = getRandomInt(10, 90);
					var random_y = getRandomInt(40, 100);
					var emoji = document.createElement("div");
					emoji.className = "reaction";
					emoji.style.top = random_y + "%";
					emoji.style.left = random_x + "%";
					emoji.innerHTML = el;
					container_el.appendChild(emoji);
				});
				ScrollTrigger.batch(".reaction", {
					interval: 0.3,
					once: true,
					onEnter: function (elements, triggers) {
						var tl = gsap.timeline();
						gsap.set(elements, { opacity: 1, stagger: 0.5 });
						tl.add("begin")
							.to(
								elements,
								{
									y: -500,
									rotation: "random(-180, 180, 90)",
									z: 0,
									duration: "random(4, 9)",
									stagger: 0.5,
								},
								"begin"
							)
							.to(
								elements,
								{ opacity: 0, duration: 1, stagger: 0.5 },
								"begin+=4"
							);
					},
				});
			},
			{ "gsap/dist/ScrollTrigger": 5, "gsap/dist/gsap": 7 },
		],
		68: [
			function (require, module, exports) {
				var Hls = require("hls.js");
				var toArray = require("to-array");
				const VideoSet = function (videos) {
					if (Object.getPrototypeOf(videos) !== NodeList.prototype) {
						throw Error("videos argument expects NodeList");
					}
					if (videos.length < 1) {
						throw Error(
							"videos argument expects NodeList with one or more nodes"
						);
					}
					videos.forEach(function (video) {
						if (Object.getPrototypeOf(video) !== HTMLVideoElement.prototype) {
							throw Error("videos argument expects HTMLVideoElement");
						}
					});
					this.videos = toArray(videos);
					const windowWidth = window.innerWidth;
					const windowHeight = window.innerHeight;
					const windowAspectRatio = windowWidth / windowHeight;
					this.videos.forEach(function (video) {
						const aspectRatioParts = video.dataset.aspectRatio.split(":");
						const aspectRatio =
							parseInt(aspectRatioParts[0], 10) /
							parseInt(aspectRatioParts[1], 10);
						video.aspectRatioDifference = Math.abs(
							windowAspectRatio - aspectRatio
						);
					});
					this.videos.sort(function (a, b) {
						return a.aspectRatioDifference - b.aspectRatioDifference;
					});
					this.chosenVideo = this.videos[0];
					this.chosenVideo.removeAttribute("hidden");
					window.addEventListener("resize", this.size.bind(this));
				};
				VideoSet.prototype.start = function (onPlay) {
					const video = this.chosenVideo;
					const src = video.dataset.hlsSrc;
					if (Hls.isSupported()) {
						const hls = new Hls();
						hls.loadSource(src);
						hls.attachMedia(video);
						hls.on(Hls.Events.MANIFEST_PARSED, function () {
							video.play();
							onPlay();
						});
					} else if (video.canPlayType("application/vnd.apple.mpegurl")) {
						video.src = src;
						video.addEventListener("loadedmetadata", function () {
							video.play();
							onPlay();
						});
					}
					return this;
				};
				VideoSet.prototype.size = function () {
					const windowWidth = window.innerWidth;
					const windowHeight = window.innerHeight;
					const windowAspectRatio = windowWidth / windowHeight;
					this.videos.forEach(function (video) {
						const aspectRatioParts = video.dataset.aspectRatio.split(":");
						const aspectRatio =
							parseInt(aspectRatioParts[0], 10) /
							parseInt(aspectRatioParts[1], 10);
						if (aspectRatio < windowAspectRatio) {
							const containerHeight = Math.ceil(windowWidth / aspectRatio);
							video.style.removeProperty("width");
							video.style.removeProperty("left");
							video.style.height = containerHeight + "px";
						} else if (aspectRatio > windowAspectRatio) {
							const containerWidth = Math.ceil(windowHeight * aspectRatio);
							video.style.removeProperty("height");
							video.style.removeProperty("top");
							video.style.width = containerWidth + "px";
						}
					});
					return this;
				};
				module.exports = VideoSet;
			},
			{ "hls.js": 8, "to-array": 57 },
		],
		69: [
			function (require, module, exports) {
				"use strict";
				const detectIt = require("detect-it");
				const debounce = require("lodash/debounce");
				function DetectDevice() {
					this._init();
					this.handleWindowResize;
				}
				DetectDevice.prototype._init = function () {
					this._detectDeviceType();
					this.handleWindowResize = debounce(this._detectDeviceType, 300);
					window.addEventListener("resize", this.handleWindowResize);
				};
				DetectDevice.prototype._detectDeviceType = function () {
					var className;
					if (detectIt.deviceType === "touchOnly") {
						className = "device-touch";
					} else if (detectIt.deviceType === "mouseOnly") {
						className = "device-mouse";
					} else if (detectIt.deviceType === "hybrid") {
						className = "device-hybrid";
					}
					document.documentElement.classList.add(className);
				};
				DetectDevice.prototype.destroy = function () {
					if (this.handleWindowResize) {
						window.removeEventListener("resize", this.handleWindowResize);
					}
				};
				module.exports = DetectDevice;
			},
			{ "detect-it": 2, "lodash/debounce": 37 },
		],
		70: [
			function (require, module, exports) {
				(function (global) {
					(function () {
						var _gsScope =
							typeof module !== "undefined" &&
							module.exports &&
							typeof global !== "undefined"
								? global
								: this || window;
						(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {
							"use strict";
							_gsScope._gsDefine(
								"TimelineLite",
								["core.Animation", "core.SimpleTimeline", "TweenLite"],
								function (Animation, SimpleTimeline, TweenLite) {
									var TimelineLite = function (vars) {
											SimpleTimeline.call(this, vars);
											this._labels = {};
											this.autoRemoveChildren =
												this.vars.autoRemoveChildren === true;
											this.smoothChildTiming =
												this.vars.smoothChildTiming === true;
											this._sortChildren = true;
											this._onUpdate = this.vars.onUpdate;
											var v = this.vars,
												val,
												p;
											for (p in v) {
												val = v[p];
												if (_isArray(val))
													if (val.join("").indexOf("{self}") !== -1) {
														v[p] = this._swapSelfInParams(val);
													}
											}
											if (_isArray(v.tweens)) {
												this.add(v.tweens, 0, v.align, v.stagger);
											}
										},
										_tinyNum = 1e-10,
										TweenLiteInternals = TweenLite._internals,
										_internals = (TimelineLite._internals = {}),
										_isSelector = TweenLiteInternals.isSelector,
										_isArray = TweenLiteInternals.isArray,
										_lazyTweens = TweenLiteInternals.lazyTweens,
										_lazyRender = TweenLiteInternals.lazyRender,
										_globals = _gsScope._gsDefine.globals,
										_copy = function (vars) {
											var copy = {},
												p;
											for (p in vars) {
												copy[p] = vars[p];
											}
											return copy;
										},
										_applyCycle = function (vars, targets, i) {
											var alt = vars.cycle,
												p,
												val;
											for (p in alt) {
												val = alt[p];
												vars[p] =
													typeof val === "function"
														? val(i, targets[i])
														: val[i % val.length];
											}
											delete vars.cycle;
										},
										_pauseCallback = (_internals.pauseCallback =
											function () {}),
										_slice = function (a) {
											var b = [],
												l = a.length,
												i;
											for (i = 0; i !== l; b.push(a[i++]));
											return b;
										},
										p = (TimelineLite.prototype = new SimpleTimeline());
									TimelineLite.version = "2.0.1";
									p.constructor = TimelineLite;
									p.kill()._gc = p._forcingPlayhead = p._hasPause = false;
									p.to = function (target, duration, vars, position) {
										var Engine =
											(vars.repeat && _globals.TweenMax) || TweenLite;
										return duration
											? this.add(new Engine(target, duration, vars), position)
											: this.set(target, vars, position);
									};
									p.from = function (target, duration, vars, position) {
										return this.add(
											((vars.repeat && _globals.TweenMax) || TweenLite).from(
												target,
												duration,
												vars
											),
											position
										);
									};
									p.fromTo = function (
										target,
										duration,
										fromVars,
										toVars,
										position
									) {
										var Engine =
											(toVars.repeat && _globals.TweenMax) || TweenLite;
										return duration
											? this.add(
													Engine.fromTo(target, duration, fromVars, toVars),
													position
											  )
											: this.set(target, toVars, position);
									};
									p.staggerTo = function (
										targets,
										duration,
										vars,
										stagger,
										position,
										onCompleteAll,
										onCompleteAllParams,
										onCompleteAllScope
									) {
										var tl = new TimelineLite({
												onComplete: onCompleteAll,
												onCompleteParams: onCompleteAllParams,
												callbackScope: onCompleteAllScope,
												smoothChildTiming: this.smoothChildTiming,
											}),
											cycle = vars.cycle,
											copy,
											i;
										if (typeof targets === "string") {
											targets = TweenLite.selector(targets) || targets;
										}
										targets = targets || [];
										if (_isSelector(targets)) {
											targets = _slice(targets);
										}
										stagger = stagger || 0;
										if (stagger < 0) {
											targets = _slice(targets);
											targets.reverse();
											stagger *= -1;
										}
										for (i = 0; i < targets.length; i++) {
											copy = _copy(vars);
											if (copy.startAt) {
												copy.startAt = _copy(copy.startAt);
												if (copy.startAt.cycle) {
													_applyCycle(copy.startAt, targets, i);
												}
											}
											if (cycle) {
												_applyCycle(copy, targets, i);
												if (copy.duration != null) {
													duration = copy.duration;
													delete copy.duration;
												}
											}
											tl.to(targets[i], duration, copy, i * stagger);
										}
										return this.add(tl, position);
									};
									p.staggerFrom = function (
										targets,
										duration,
										vars,
										stagger,
										position,
										onCompleteAll,
										onCompleteAllParams,
										onCompleteAllScope
									) {
										vars.immediateRender = vars.immediateRender != false;
										vars.runBackwards = true;
										return this.staggerTo(
											targets,
											duration,
											vars,
											stagger,
											position,
											onCompleteAll,
											onCompleteAllParams,
											onCompleteAllScope
										);
									};
									p.staggerFromTo = function (
										targets,
										duration,
										fromVars,
										toVars,
										stagger,
										position,
										onCompleteAll,
										onCompleteAllParams,
										onCompleteAllScope
									) {
										toVars.startAt = fromVars;
										toVars.immediateRender =
											toVars.immediateRender != false &&
											fromVars.immediateRender != false;
										return this.staggerTo(
											targets,
											duration,
											toVars,
											stagger,
											position,
											onCompleteAll,
											onCompleteAllParams,
											onCompleteAllScope
										);
									};
									p.call = function (callback, params, scope, position) {
										return this.add(
											TweenLite.delayedCall(0, callback, params, scope),
											position
										);
									};
									p.set = function (target, vars, position) {
										position = this._parseTimeOrLabel(position, 0, true);
										if (vars.immediateRender == null) {
											vars.immediateRender =
												position === this._time && !this._paused;
										}
										return this.add(new TweenLite(target, 0, vars), position);
									};
									TimelineLite.exportRoot = function (
										vars,
										ignoreDelayedCalls
									) {
										vars = vars || {};
										if (vars.smoothChildTiming == null) {
											vars.smoothChildTiming = true;
										}
										var tl = new TimelineLite(vars),
											root = tl._timeline,
											hasNegativeStart,
											time,
											tween,
											next;
										if (ignoreDelayedCalls == null) {
											ignoreDelayedCalls = true;
										}
										root._remove(tl, true);
										tl._startTime = 0;
										tl._rawPrevTime = tl._time = tl._totalTime = root._time;
										tween = root._first;
										while (tween) {
											next = tween._next;
											if (
												!ignoreDelayedCalls ||
												!(
													tween instanceof TweenLite &&
													tween.target === tween.vars.onComplete
												)
											) {
												time = tween._startTime - tween._delay;
												if (time < 0) {
													hasNegativeStart = 1;
												}
												tl.add(tween, time);
											}
											tween = next;
										}
										root.add(tl, 0);
										if (hasNegativeStart) {
											tl.totalDuration();
										}
										return tl;
									};
									p.add = function (value, position, align, stagger) {
										var curTime, l, i, child, tl, beforeRawTime;
										if (typeof position !== "number") {
											position = this._parseTimeOrLabel(
												position,
												0,
												true,
												value
											);
										}
										if (!(value instanceof Animation)) {
											if (
												value instanceof Array ||
												(value && value.push && _isArray(value))
											) {
												align = align || "normal";
												stagger = stagger || 0;
												curTime = position;
												l = value.length;
												for (i = 0; i < l; i++) {
													if (_isArray((child = value[i]))) {
														child = new TimelineLite({ tweens: child });
													}
													this.add(child, curTime);
													if (
														typeof child !== "string" &&
														typeof child !== "function"
													) {
														if (align === "sequence") {
															curTime =
																child._startTime +
																child.totalDuration() / child._timeScale;
														} else if (align === "start") {
															child._startTime -= child.delay();
														}
													}
													curTime += stagger;
												}
												return this._uncache(true);
											} else if (typeof value === "string") {
												return this.addLabel(value, position);
											} else if (typeof value === "function") {
												value = TweenLite.delayedCall(0, value);
											} else {
												throw (
													"Cannot add " +
													value +
													" into the timeline; it is not a tween, timeline, function, or string."
												);
											}
										}
										SimpleTimeline.prototype.add.call(this, value, position);
										if (value._time) {
											value.render(
												(this.rawTime() - value._startTime) * value._timeScale,
												false,
												false
											);
										}
										if (this._gc || this._time === this._duration)
											if (!this._paused)
												if (this._duration < this.duration()) {
													tl = this;
													beforeRawTime = tl.rawTime() > value._startTime;
													while (tl._timeline) {
														if (
															beforeRawTime &&
															tl._timeline.smoothChildTiming
														) {
															tl.totalTime(tl._totalTime, true);
														} else if (tl._gc) {
															tl._enabled(true, false);
														}
														tl = tl._timeline;
													}
												}
										return this;
									};
									p.remove = function (value) {
										if (value instanceof Animation) {
											this._remove(value, false);
											var tl = (value._timeline = value.vars.useFrames
												? Animation._rootFramesTimeline
												: Animation._rootTimeline);
											value._startTime =
												(value._paused ? value._pauseTime : tl._time) -
												(!value._reversed
													? value._totalTime
													: value.totalDuration() - value._totalTime) /
													value._timeScale;
											return this;
										} else if (
											value instanceof Array ||
											(value && value.push && _isArray(value))
										) {
											var i = value.length;
											while (--i > -1) {
												this.remove(value[i]);
											}
											return this;
										} else if (typeof value === "string") {
											return this.removeLabel(value);
										}
										return this.kill(null, value);
									};
									p._remove = function (tween, skipDisable) {
										SimpleTimeline.prototype._remove.call(
											this,
											tween,
											skipDisable
										);
										var last = this._last;
										if (!last) {
											this._time =
												this._totalTime =
												this._duration =
												this._totalDuration =
													0;
										} else if (this._time > this.duration()) {
											this._time = this._duration;
											this._totalTime = this._totalDuration;
										}
										return this;
									};
									p.append = function (value, offsetOrLabel) {
										return this.add(
											value,
											this._parseTimeOrLabel(null, offsetOrLabel, true, value)
										);
									};
									p.insert = p.insertMultiple = function (
										value,
										position,
										align,
										stagger
									) {
										return this.add(value, position || 0, align, stagger);
									};
									p.appendMultiple = function (
										tweens,
										offsetOrLabel,
										align,
										stagger
									) {
										return this.add(
											tweens,
											this._parseTimeOrLabel(null, offsetOrLabel, true, tweens),
											align,
											stagger
										);
									};
									p.addLabel = function (label, position) {
										this._labels[label] = this._parseTimeOrLabel(position);
										return this;
									};
									p.addPause = function (position, callback, params, scope) {
										var t = TweenLite.delayedCall(
											0,
											_pauseCallback,
											params,
											scope || this
										);
										t.vars.onComplete = t.vars.onReverseComplete = callback;
										t.data = "isPause";
										this._hasPause = true;
										return this.add(t, position);
									};
									p.removeLabel = function (label) {
										delete this._labels[label];
										return this;
									};
									p.getLabelTime = function (label) {
										return this._labels[label] != null
											? this._labels[label]
											: -1;
									};
									p._parseTimeOrLabel = function (
										timeOrLabel,
										offsetOrLabel,
										appendIfAbsent,
										ignore
									) {
										var clippedDuration, i;
										if (
											ignore instanceof Animation &&
											ignore.timeline === this
										) {
											this.remove(ignore);
										} else if (
											ignore &&
											(ignore instanceof Array ||
												(ignore.push && _isArray(ignore)))
										) {
											i = ignore.length;
											while (--i > -1) {
												if (
													ignore[i] instanceof Animation &&
													ignore[i].timeline === this
												) {
													this.remove(ignore[i]);
												}
											}
										}
										clippedDuration =
											typeof timeOrLabel === "number" && !offsetOrLabel
												? 0
												: this.duration() > 99999999999
												? this.recent().endTime(false)
												: this._duration;
										if (typeof offsetOrLabel === "string") {
											return this._parseTimeOrLabel(
												offsetOrLabel,
												appendIfAbsent &&
													typeof timeOrLabel === "number" &&
													this._labels[offsetOrLabel] == null
													? timeOrLabel - clippedDuration
													: 0,
												appendIfAbsent
											);
										}
										offsetOrLabel = offsetOrLabel || 0;
										if (
											typeof timeOrLabel === "string" &&
											(isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)
										) {
											i = timeOrLabel.indexOf("=");
											if (i === -1) {
												if (this._labels[timeOrLabel] == null) {
													return appendIfAbsent
														? (this._labels[timeOrLabel] =
																clippedDuration + offsetOrLabel)
														: offsetOrLabel;
												}
												return this._labels[timeOrLabel] + offsetOrLabel;
											}
											offsetOrLabel =
												parseInt(timeOrLabel.charAt(i - 1) + "1", 10) *
												Number(timeOrLabel.substr(i + 1));
											timeOrLabel =
												i > 1
													? this._parseTimeOrLabel(
															timeOrLabel.substr(0, i - 1),
															0,
															appendIfAbsent
													  )
													: clippedDuration;
										} else if (timeOrLabel == null) {
											timeOrLabel = clippedDuration;
										}
										return Number(timeOrLabel) + offsetOrLabel;
									};
									p.seek = function (position, suppressEvents) {
										return this.totalTime(
											typeof position === "number"
												? position
												: this._parseTimeOrLabel(position),
											suppressEvents !== false
										);
									};
									p.stop = function () {
										return this.paused(true);
									};
									p.gotoAndPlay = function (position, suppressEvents) {
										return this.play(position, suppressEvents);
									};
									p.gotoAndStop = function (position, suppressEvents) {
										return this.pause(position, suppressEvents);
									};
									p.render = function (time, suppressEvents, force) {
										if (this._gc) {
											this._enabled(true, false);
										}
										var prevTime = this._time,
											totalDur = !this._dirty
												? this._totalDuration
												: this.totalDuration(),
											prevStart = this._startTime,
											prevTimeScale = this._timeScale,
											prevPaused = this._paused,
											tween,
											isComplete,
											next,
											callback,
											internalForce,
											pauseTween,
											curTime;
										if (prevTime !== this._time) {
											time += this._time - prevTime;
										}
										if (time >= totalDur - 1e-7 && time >= 0) {
											this._totalTime = this._time = totalDur;
											if (!this._reversed)
												if (!this._hasPausedChild()) {
													isComplete = true;
													callback = "onComplete";
													internalForce = !!this._timeline.autoRemoveChildren;
													if (this._duration === 0)
														if (
															(time <= 0 && time >= -1e-7) ||
															this._rawPrevTime < 0 ||
															this._rawPrevTime === _tinyNum
														)
															if (this._rawPrevTime !== time && this._first) {
																internalForce = true;
																if (this._rawPrevTime > _tinyNum) {
																	callback = "onReverseComplete";
																}
															}
												}
											this._rawPrevTime =
												this._duration ||
												!suppressEvents ||
												time ||
												this._rawPrevTime === time
													? time
													: _tinyNum;
											time = totalDur + 1e-4;
										} else if (time < 1e-7) {
											this._totalTime = this._time = 0;
											if (
												prevTime !== 0 ||
												(this._duration === 0 &&
													this._rawPrevTime !== _tinyNum &&
													(this._rawPrevTime > 0 ||
														(time < 0 && this._rawPrevTime >= 0)))
											) {
												callback = "onReverseComplete";
												isComplete = this._reversed;
											}
											if (time < 0) {
												this._active = false;
												if (
													this._timeline.autoRemoveChildren &&
													this._reversed
												) {
													internalForce = isComplete = true;
													callback = "onReverseComplete";
												} else if (this._rawPrevTime >= 0 && this._first) {
													internalForce = true;
												}
												this._rawPrevTime = time;
											} else {
												this._rawPrevTime =
													this._duration ||
													!suppressEvents ||
													time ||
													this._rawPrevTime === time
														? time
														: _tinyNum;
												if (time === 0 && isComplete) {
													tween = this._first;
													while (tween && tween._startTime === 0) {
														if (!tween._duration) {
															isComplete = false;
														}
														tween = tween._next;
													}
												}
												time = 0;
												if (!this._initted) {
													internalForce = true;
												}
											}
										} else {
											if (
												this._hasPause &&
												!this._forcingPlayhead &&
												!suppressEvents
											) {
												if (time >= prevTime) {
													tween = this._first;
													while (
														tween &&
														tween._startTime <= time &&
														!pauseTween
													) {
														if (!tween._duration)
															if (
																tween.data === "isPause" &&
																!tween.ratio &&
																!(
																	tween._startTime === 0 &&
																	this._rawPrevTime === 0
																)
															) {
																pauseTween = tween;
															}
														tween = tween._next;
													}
												} else {
													tween = this._last;
													while (
														tween &&
														tween._startTime >= time &&
														!pauseTween
													) {
														if (!tween._duration)
															if (
																tween.data === "isPause" &&
																tween._rawPrevTime > 0
															) {
																pauseTween = tween;
															}
														tween = tween._prev;
													}
												}
												if (pauseTween) {
													this._time = time = pauseTween._startTime;
													this._totalTime =
														time +
														this._cycle *
															(this._totalDuration + this._repeatDelay);
												}
											}
											this._totalTime = this._time = this._rawPrevTime = time;
										}
										if (
											(this._time === prevTime || !this._first) &&
											!force &&
											!internalForce &&
											!pauseTween
										) {
											return;
										} else if (!this._initted) {
											this._initted = true;
										}
										if (!this._active)
											if (
												!this._paused &&
												this._time !== prevTime &&
												time > 0
											) {
												this._active = true;
											}
										if (prevTime === 0)
											if (this.vars.onStart)
												if (this._time !== 0 || !this._duration)
													if (!suppressEvents) {
														this._callback("onStart");
													}
										curTime = this._time;
										if (curTime >= prevTime) {
											tween = this._first;
											while (tween) {
												next = tween._next;
												if (
													curTime !== this._time ||
													(this._paused && !prevPaused)
												) {
													break;
												} else if (
													tween._active ||
													(tween._startTime <= curTime &&
														!tween._paused &&
														!tween._gc)
												) {
													if (pauseTween === tween) {
														this.pause();
													}
													if (!tween._reversed) {
														tween.render(
															(time - tween._startTime) * tween._timeScale,
															suppressEvents,
															force
														);
													} else {
														tween.render(
															(!tween._dirty
																? tween._totalDuration
																: tween.totalDuration()) -
																(time - tween._startTime) * tween._timeScale,
															suppressEvents,
															force
														);
													}
												}
												tween = next;
											}
										} else {
											tween = this._last;
											while (tween) {
												next = tween._prev;
												if (
													curTime !== this._time ||
													(this._paused && !prevPaused)
												) {
													break;
												} else if (
													tween._active ||
													(tween._startTime <= prevTime &&
														!tween._paused &&
														!tween._gc)
												) {
													if (pauseTween === tween) {
														pauseTween = tween._prev;
														while (
															pauseTween &&
															pauseTween.endTime() > this._time
														) {
															pauseTween.render(
																pauseTween._reversed
																	? pauseTween.totalDuration() -
																			(time - pauseTween._startTime) *
																				pauseTween._timeScale
																	: (time - pauseTween._startTime) *
																			pauseTween._timeScale,
																suppressEvents,
																force
															);
															pauseTween = pauseTween._prev;
														}
														pauseTween = null;
														this.pause();
													}
													if (!tween._reversed) {
														tween.render(
															(time - tween._startTime) * tween._timeScale,
															suppressEvents,
															force
														);
													} else {
														tween.render(
															(!tween._dirty
																? tween._totalDuration
																: tween.totalDuration()) -
																(time - tween._startTime) * tween._timeScale,
															suppressEvents,
															force
														);
													}
												}
												tween = next;
											}
										}
										if (this._onUpdate)
											if (!suppressEvents) {
												if (_lazyTweens.length) {
													_lazyRender();
												}
												this._callback("onUpdate");
											}
										if (callback)
											if (!this._gc)
												if (
													prevStart === this._startTime ||
													prevTimeScale !== this._timeScale
												)
													if (
														this._time === 0 ||
														totalDur >= this.totalDuration()
													) {
														if (isComplete) {
															if (_lazyTweens.length) {
																_lazyRender();
															}
															if (this._timeline.autoRemoveChildren) {
																this._enabled(false, false);
															}
															this._active = false;
														}
														if (!suppressEvents && this.vars[callback]) {
															this._callback(callback);
														}
													}
									};
									p._hasPausedChild = function () {
										var tween = this._first;
										while (tween) {
											if (
												tween._paused ||
												(tween instanceof TimelineLite &&
													tween._hasPausedChild())
											) {
												return true;
											}
											tween = tween._next;
										}
										return false;
									};
									p.getChildren = function (
										nested,
										tweens,
										timelines,
										ignoreBeforeTime
									) {
										ignoreBeforeTime = ignoreBeforeTime || -9999999999;
										var a = [],
											tween = this._first,
											cnt = 0;
										while (tween) {
											if (tween._startTime < ignoreBeforeTime) {
											} else if (tween instanceof TweenLite) {
												if (tweens !== false) {
													a[cnt++] = tween;
												}
											} else {
												if (timelines !== false) {
													a[cnt++] = tween;
												}
												if (nested !== false) {
													a = a.concat(
														tween.getChildren(true, tweens, timelines)
													);
													cnt = a.length;
												}
											}
											tween = tween._next;
										}
										return a;
									};
									p.getTweensOf = function (target, nested) {
										var disabled = this._gc,
											a = [],
											cnt = 0,
											tweens,
											i;
										if (disabled) {
											this._enabled(true, true);
										}
										tweens = TweenLite.getTweensOf(target);
										i = tweens.length;
										while (--i > -1) {
											if (
												tweens[i].timeline === this ||
												(nested && this._contains(tweens[i]))
											) {
												a[cnt++] = tweens[i];
											}
										}
										if (disabled) {
											this._enabled(false, true);
										}
										return a;
									};
									p.recent = function () {
										return this._recent;
									};
									p._contains = function (tween) {
										var tl = tween.timeline;
										while (tl) {
											if (tl === this) {
												return true;
											}
											tl = tl.timeline;
										}
										return false;
									};
									p.shiftChildren = function (
										amount,
										adjustLabels,
										ignoreBeforeTime
									) {
										ignoreBeforeTime = ignoreBeforeTime || 0;
										var tween = this._first,
											labels = this._labels,
											p;
										while (tween) {
											if (tween._startTime >= ignoreBeforeTime) {
												tween._startTime += amount;
											}
											tween = tween._next;
										}
										if (adjustLabels) {
											for (p in labels) {
												if (labels[p] >= ignoreBeforeTime) {
													labels[p] += amount;
												}
											}
										}
										return this._uncache(true);
									};
									p._kill = function (vars, target) {
										if (!vars && !target) {
											return this._enabled(false, false);
										}
										var tweens = !target
												? this.getChildren(true, true, false)
												: this.getTweensOf(target),
											i = tweens.length,
											changed = false;
										while (--i > -1) {
											if (tweens[i]._kill(vars, target)) {
												changed = true;
											}
										}
										return changed;
									};
									p.clear = function (labels) {
										var tweens = this.getChildren(false, true, true),
											i = tweens.length;
										this._time = this._totalTime = 0;
										while (--i > -1) {
											tweens[i]._enabled(false, false);
										}
										if (labels !== false) {
											this._labels = {};
										}
										return this._uncache(true);
									};
									p.invalidate = function () {
										var tween = this._first;
										while (tween) {
											tween.invalidate();
											tween = tween._next;
										}
										return Animation.prototype.invalidate.call(this);
									};
									p._enabled = function (enabled, ignoreTimeline) {
										if (enabled === this._gc) {
											var tween = this._first;
											while (tween) {
												tween._enabled(enabled, true);
												tween = tween._next;
											}
										}
										return SimpleTimeline.prototype._enabled.call(
											this,
											enabled,
											ignoreTimeline
										);
									};
									p.totalTime = function (time, suppressEvents, uncapped) {
										this._forcingPlayhead = true;
										var val = Animation.prototype.totalTime.apply(
											this,
											arguments
										);
										this._forcingPlayhead = false;
										return val;
									};
									p.duration = function (value) {
										if (!arguments.length) {
											if (this._dirty) {
												this.totalDuration();
											}
											return this._duration;
										}
										if (this.duration() !== 0 && value !== 0) {
											this.timeScale(this._duration / value);
										}
										return this;
									};
									p.totalDuration = function (value) {
										if (!arguments.length) {
											if (this._dirty) {
												var max = 0,
													tween = this._last,
													prevStart = 999999999999,
													prev,
													end;
												while (tween) {
													prev = tween._prev;
													if (tween._dirty) {
														tween.totalDuration();
													}
													if (
														tween._startTime > prevStart &&
														this._sortChildren &&
														!tween._paused &&
														!this._calculatingDuration
													) {
														this._calculatingDuration = 1;
														this.add(tween, tween._startTime - tween._delay);
														this._calculatingDuration = 0;
													} else {
														prevStart = tween._startTime;
													}
													if (tween._startTime < 0 && !tween._paused) {
														max -= tween._startTime;
														if (this._timeline.smoothChildTiming) {
															this._startTime +=
																tween._startTime / this._timeScale;
															this._time -= tween._startTime;
															this._totalTime -= tween._startTime;
															this._rawPrevTime -= tween._startTime;
														}
														this.shiftChildren(
															-tween._startTime,
															false,
															-9999999999
														);
														prevStart = 0;
													}
													end =
														tween._startTime +
														tween._totalDuration / tween._timeScale;
													if (end > max) {
														max = end;
													}
													tween = prev;
												}
												this._duration = this._totalDuration = max;
												this._dirty = false;
											}
											return this._totalDuration;
										}
										return value && this.totalDuration()
											? this.timeScale(this._totalDuration / value)
											: this;
									};
									p.paused = function (value) {
										if (!value) {
											var tween = this._first,
												time = this._time;
											while (tween) {
												if (
													tween._startTime === time &&
													tween.data === "isPause"
												) {
													tween._rawPrevTime = 0;
												}
												tween = tween._next;
											}
										}
										return Animation.prototype.paused.apply(this, arguments);
									};
									p.usesFrames = function () {
										var tl = this._timeline;
										while (tl._timeline) {
											tl = tl._timeline;
										}
										return tl === Animation._rootFramesTimeline;
									};
									p.rawTime = function (wrapRepeats) {
										return wrapRepeats &&
											(this._paused ||
												(this._repeat &&
													this.time() > 0 &&
													this.totalProgress() < 1))
											? this._totalTime % (this._duration + this._repeatDelay)
											: this._paused
											? this._totalTime
											: (this._timeline.rawTime(wrapRepeats) -
													this._startTime) *
											  this._timeScale;
									};
									return TimelineLite;
								},
								true
							);
						});
						if (_gsScope._gsDefine) {
							_gsScope._gsQueue.pop()();
						}
						(function (name) {
							"use strict";
							var getGlobal = function () {
								return (_gsScope.GreenSockGlobals || _gsScope)[name];
							};
							if (typeof module !== "undefined" && module.exports) {
								require("./TweenLite.js");
								module.exports = getGlobal();
							} else if (typeof define === "function" && define.amd) {
								define(["TweenLite"], getGlobal);
							}
						})("TimelineLite");
					}.call(this));
				}.call(
					this,
					typeof global !== "undefined"
						? global
						: typeof self !== "undefined"
						? self
						: typeof window !== "undefined"
						? window
						: {}
				));
			},
			{ "./TweenLite.js": 71 },
		],
		71: [
			function (require, module, exports) {
				(function (global) {
					(function () {
						(function (window, moduleName) {
							"use strict";
							var _exports = {},
								_doc = window.document,
								_globals = (window.GreenSockGlobals =
									window.GreenSockGlobals || window),
								existingModule = _globals[moduleName];
							if (existingModule) {
								if (typeof module !== "undefined" && module.exports) {
									module.exports = existingModule;
								}
								return existingModule;
							}
							var _namespace = function (ns) {
									var a = ns.split("."),
										p = _globals,
										i;
									for (i = 0; i < a.length; i++) {
										p[a[i]] = p = p[a[i]] || {};
									}
									return p;
								},
								gs = _namespace("com.greensock"),
								_tinyNum = 1e-10,
								_slice = function (a) {
									var b = [],
										l = a.length,
										i;
									for (i = 0; i !== l; b.push(a[i++])) {}
									return b;
								},
								_emptyFunc = function () {},
								_isArray = (function () {
									var toString = Object.prototype.toString,
										array = toString.call([]);
									return function (obj) {
										return (
											obj != null &&
											(obj instanceof Array ||
												(typeof obj === "object" &&
													!!obj.push &&
													toString.call(obj) === array))
										);
									};
								})(),
								a,
								i,
								p,
								_ticker,
								_tickerActive,
								_defLookup = {},
								Definition = function (ns, dependencies, func, global) {
									this.sc = _defLookup[ns] ? _defLookup[ns].sc : [];
									_defLookup[ns] = this;
									this.gsClass = null;
									this.func = func;
									var _classes = [];
									this.check = function (init) {
										var i = dependencies.length,
											missing = i,
											cur,
											a,
											n,
											cl;
										while (--i > -1) {
											if (
												(cur =
													_defLookup[dependencies[i]] ||
													new Definition(dependencies[i], [])).gsClass
											) {
												_classes[i] = cur.gsClass;
												missing--;
											} else if (init) {
												cur.sc.push(this);
											}
										}
										if (missing === 0 && func) {
											a = ("com.greensock." + ns).split(".");
											n = a.pop();
											cl =
												_namespace(a.join("."))[n] =
												this.gsClass =
													func.apply(func, _classes);
											if (global) {
												_globals[n] = _exports[n] = cl;
												if (typeof module !== "undefined" && module.exports) {
													if (ns === moduleName) {
														module.exports = _exports[moduleName] = cl;
														for (i in _exports) {
															cl[i] = _exports[i];
														}
													} else if (_exports[moduleName]) {
														_exports[moduleName][n] = cl;
													}
												} else if (typeof define === "function" && define.amd) {
													define(
														(window.GreenSockAMDPath
															? window.GreenSockAMDPath + "/"
															: "") + ns.split(".").pop(),
														[],
														function () {
															return cl;
														}
													);
												}
											}
											for (i = 0; i < this.sc.length; i++) {
												this.sc[i].check();
											}
										}
									};
									this.check(true);
								},
								_gsDefine = (window._gsDefine = function (
									ns,
									dependencies,
									func,
									global
								) {
									return new Definition(ns, dependencies, func, global);
								}),
								_class = (gs._class = function (ns, func, global) {
									func = func || function () {};
									_gsDefine(
										ns,
										[],
										function () {
											return func;
										},
										global
									);
									return func;
								});
							_gsDefine.globals = _globals;
							var _baseParams = [0, 0, 1, 1],
								Ease = _class(
									"easing.Ease",
									function (func, extraParams, type, power) {
										this._func = func;
										this._type = type || 0;
										this._power = power || 0;
										this._params = extraParams
											? _baseParams.concat(extraParams)
											: _baseParams;
									},
									true
								),
								_easeMap = (Ease.map = {}),
								_easeReg = (Ease.register = function (
									ease,
									names,
									types,
									create
								) {
									var na = names.split(","),
										i = na.length,
										ta = (types || "easeIn,easeOut,easeInOut").split(","),
										e,
										name,
										j,
										type;
									while (--i > -1) {
										name = na[i];
										e = create
											? _class("easing." + name, null, true)
											: gs.easing[name] || {};
										j = ta.length;
										while (--j > -1) {
											type = ta[j];
											_easeMap[name + "." + type] =
												_easeMap[type + name] =
												e[type] =
													ease.getRatio ? ease : ease[type] || new ease();
										}
									}
								});
							p = Ease.prototype;
							p._calcEnd = false;
							p.getRatio = function (p) {
								if (this._func) {
									this._params[0] = p;
									return this._func.apply(null, this._params);
								}
								var t = this._type,
									pw = this._power,
									r =
										t === 1
											? 1 - p
											: t === 2
											? p
											: p < 0.5
											? p * 2
											: (1 - p) * 2;
								if (pw === 1) {
									r *= r;
								} else if (pw === 2) {
									r *= r * r;
								} else if (pw === 3) {
									r *= r * r * r;
								} else if (pw === 4) {
									r *= r * r * r * r;
								}
								return t === 1
									? 1 - r
									: t === 2
									? r
									: p < 0.5
									? r / 2
									: 1 - r / 2;
							};
							a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"];
							i = a.length;
							while (--i > -1) {
								p = a[i] + ",Power" + i;
								_easeReg(new Ease(null, null, 1, i), p, "easeOut", true);
								_easeReg(
									new Ease(null, null, 2, i),
									p,
									"easeIn" + (i === 0 ? ",easeNone" : "")
								);
								_easeReg(new Ease(null, null, 3, i), p, "easeInOut");
							}
							_easeMap.linear = gs.easing.Linear.easeIn;
							_easeMap.swing = gs.easing.Quad.easeInOut;
							var EventDispatcher = _class(
								"events.EventDispatcher",
								function (target) {
									this._listeners = {};
									this._eventTarget = target || this;
								}
							);
							p = EventDispatcher.prototype;
							p.addEventListener = function (
								type,
								callback,
								scope,
								useParam,
								priority
							) {
								priority = priority || 0;
								var list = this._listeners[type],
									index = 0,
									listener,
									i;
								if (this === _ticker && !_tickerActive) {
									_ticker.wake();
								}
								if (list == null) {
									this._listeners[type] = list = [];
								}
								i = list.length;
								while (--i > -1) {
									listener = list[i];
									if (listener.c === callback && listener.s === scope) {
										list.splice(i, 1);
									} else if (index === 0 && listener.pr < priority) {
										index = i + 1;
									}
								}
								list.splice(index, 0, {
									c: callback,
									s: scope,
									up: useParam,
									pr: priority,
								});
							};
							p.removeEventListener = function (type, callback) {
								var list = this._listeners[type],
									i;
								if (list) {
									i = list.length;
									while (--i > -1) {
										if (list[i].c === callback) {
											list.splice(i, 1);
											return;
										}
									}
								}
							};
							p.dispatchEvent = function (type) {
								var list = this._listeners[type],
									i,
									t,
									listener;
								if (list) {
									i = list.length;
									if (i > 1) {
										list = list.slice(0);
									}
									t = this._eventTarget;
									while (--i > -1) {
										listener = list[i];
										if (listener) {
											if (listener.up) {
												listener.c.call(listener.s || t, {
													type: type,
													target: t,
												});
											} else {
												listener.c.call(listener.s || t);
											}
										}
									}
								}
							};
							var _reqAnimFrame = window.requestAnimationFrame,
								_cancelAnimFrame = window.cancelAnimationFrame,
								_getTime =
									Date.now ||
									function () {
										return new Date().getTime();
									},
								_lastUpdate = _getTime();
							a = ["ms", "moz", "webkit", "o"];
							i = a.length;
							while (--i > -1 && !_reqAnimFrame) {
								_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
								_cancelAnimFrame =
									window[a[i] + "CancelAnimationFrame"] ||
									window[a[i] + "CancelRequestAnimationFrame"];
							}
							_class("Ticker", function (fps, useRAF) {
								var _self = this,
									_startTime = _getTime(),
									_useRAF = useRAF !== false && _reqAnimFrame ? "auto" : false,
									_lagThreshold = 500,
									_adjustedLag = 33,
									_tickWord = "tick",
									_fps,
									_req,
									_id,
									_gap,
									_nextTime,
									_tick = function (manual) {
										var elapsed = _getTime() - _lastUpdate,
											overlap,
											dispatch;
										if (elapsed > _lagThreshold) {
											_startTime += elapsed - _adjustedLag;
										}
										_lastUpdate += elapsed;
										_self.time = (_lastUpdate - _startTime) / 1e3;
										overlap = _self.time - _nextTime;
										if (!_fps || overlap > 0 || manual === true) {
											_self.frame++;
											_nextTime +=
												overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
											dispatch = true;
										}
										if (manual !== true) {
											_id = _req(_tick);
										}
										if (dispatch) {
											_self.dispatchEvent(_tickWord);
										}
									};
								EventDispatcher.call(_self);
								_self.time = _self.frame = 0;
								_self.tick = function () {
									_tick(true);
								};
								_self.lagSmoothing = function (threshold, adjustedLag) {
									if (!arguments.length) {
										return _lagThreshold < 1 / _tinyNum;
									}
									_lagThreshold = threshold || 1 / _tinyNum;
									_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
								};
								_self.sleep = function () {
									if (_id == null) {
										return;
									}
									if (!_useRAF || !_cancelAnimFrame) {
										clearTimeout(_id);
									} else {
										_cancelAnimFrame(_id);
									}
									_req = _emptyFunc;
									_id = null;
									if (_self === _ticker) {
										_tickerActive = false;
									}
								};
								_self.wake = function (seamless) {
									if (_id !== null) {
										_self.sleep();
									} else if (seamless) {
										_startTime += -_lastUpdate + (_lastUpdate = _getTime());
									} else if (_self.frame > 10) {
										_lastUpdate = _getTime() - _lagThreshold + 5;
									}
									_req =
										_fps === 0
											? _emptyFunc
											: !_useRAF || !_reqAnimFrame
											? function (f) {
													return setTimeout(
														f,
														((_nextTime - _self.time) * 1e3 + 1) | 0
													);
											  }
											: _reqAnimFrame;
									if (_self === _ticker) {
										_tickerActive = true;
									}
									_tick(2);
								};
								_self.fps = function (value) {
									if (!arguments.length) {
										return _fps;
									}
									_fps = value;
									_gap = 1 / (_fps || 60);
									_nextTime = this.time + _gap;
									_self.wake();
								};
								_self.useRAF = function (value) {
									if (!arguments.length) {
										return _useRAF;
									}
									_self.sleep();
									_useRAF = value;
									_self.fps(_fps);
								};
								_self.fps(fps);
								setTimeout(function () {
									if (
										_useRAF === "auto" &&
										_self.frame < 5 &&
										(_doc || {}).visibilityState !== "hidden"
									) {
										_self.useRAF(false);
									}
								}, 1500);
							});
							p = gs.Ticker.prototype = new gs.events.EventDispatcher();
							p.constructor = gs.Ticker;
							var Animation = _class(
								"core.Animation",
								function (duration, vars) {
									this.vars = vars = vars || {};
									this._duration = this._totalDuration = duration || 0;
									this._delay = Number(vars.delay) || 0;
									this._timeScale = 1;
									this._active = vars.immediateRender === true;
									this.data = vars.data;
									this._reversed = vars.reversed === true;
									if (!_rootTimeline) {
										return;
									}
									if (!_tickerActive) {
										_ticker.wake();
									}
									var tl = this.vars.useFrames
										? _rootFramesTimeline
										: _rootTimeline;
									tl.add(this, tl._time);
									if (this.vars.paused) {
										this.paused(true);
									}
								}
							);
							_ticker = Animation.ticker = new gs.Ticker();
							p = Animation.prototype;
							p._dirty = p._gc = p._initted = p._paused = false;
							p._totalTime = p._time = 0;
							p._rawPrevTime = -1;
							p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
							p._paused = false;
							var _checkTimeout = function () {
								if (
									_tickerActive &&
									_getTime() - _lastUpdate > 2e3 &&
									((_doc || {}).visibilityState !== "hidden" ||
										!_ticker.lagSmoothing())
								) {
									_ticker.wake();
								}
								var t = setTimeout(_checkTimeout, 2e3);
								if (t.unref) {
									t.unref();
								}
							};
							_checkTimeout();
							p.play = function (from, suppressEvents) {
								if (from != null) {
									this.seek(from, suppressEvents);
								}
								return this.reversed(false).paused(false);
							};
							p.pause = function (atTime, suppressEvents) {
								if (atTime != null) {
									this.seek(atTime, suppressEvents);
								}
								return this.paused(true);
							};
							p.resume = function (from, suppressEvents) {
								if (from != null) {
									this.seek(from, suppressEvents);
								}
								return this.paused(false);
							};
							p.seek = function (time, suppressEvents) {
								return this.totalTime(Number(time), suppressEvents !== false);
							};
							p.restart = function (includeDelay, suppressEvents) {
								return this.reversed(false)
									.paused(false)
									.totalTime(
										includeDelay ? -this._delay : 0,
										suppressEvents !== false,
										true
									);
							};
							p.reverse = function (from, suppressEvents) {
								if (from != null) {
									this.seek(from || this.totalDuration(), suppressEvents);
								}
								return this.reversed(true).paused(false);
							};
							p.render = function (time, suppressEvents, force) {};
							p.invalidate = function () {
								this._time = this._totalTime = 0;
								this._initted = this._gc = false;
								this._rawPrevTime = -1;
								if (this._gc || !this.timeline) {
									this._enabled(true);
								}
								return this;
							};
							p.isActive = function () {
								var tl = this._timeline,
									startTime = this._startTime,
									rawTime;
								return (
									!tl ||
									(!this._gc &&
										!this._paused &&
										tl.isActive() &&
										(rawTime = tl.rawTime(true)) >= startTime &&
										rawTime <
											startTime + this.totalDuration() / this._timeScale - 1e-7)
								);
							};
							p._enabled = function (enabled, ignoreTimeline) {
								if (!_tickerActive) {
									_ticker.wake();
								}
								this._gc = !enabled;
								this._active = this.isActive();
								if (ignoreTimeline !== true) {
									if (enabled && !this.timeline) {
										this._timeline.add(this, this._startTime - this._delay);
									} else if (!enabled && this.timeline) {
										this._timeline._remove(this, true);
									}
								}
								return false;
							};
							p._kill = function (vars, target) {
								return this._enabled(false, false);
							};
							p.kill = function (vars, target) {
								this._kill(vars, target);
								return this;
							};
							p._uncache = function (includeSelf) {
								var tween = includeSelf ? this : this.timeline;
								while (tween) {
									tween._dirty = true;
									tween = tween.timeline;
								}
								return this;
							};
							p._swapSelfInParams = function (params) {
								var i = params.length,
									copy = params.concat();
								while (--i > -1) {
									if (params[i] === "{self}") {
										copy[i] = this;
									}
								}
								return copy;
							};
							p._callback = function (type) {
								var v = this.vars,
									callback = v[type],
									params = v[type + "Params"],
									scope = v[type + "Scope"] || v.callbackScope || this,
									l = params ? params.length : 0;
								switch (l) {
									case 0:
										callback.call(scope);
										break;
									case 1:
										callback.call(scope, params[0]);
										break;
									case 2:
										callback.call(scope, params[0], params[1]);
										break;
									default:
										callback.apply(scope, params);
								}
							};
							p.eventCallback = function (type, callback, params, scope) {
								if ((type || "").substr(0, 2) === "on") {
									var v = this.vars;
									if (arguments.length === 1) {
										return v[type];
									}
									if (callback == null) {
										delete v[type];
									} else {
										v[type] = callback;
										v[type + "Params"] =
											_isArray(params) &&
											params.join("").indexOf("{self}") !== -1
												? this._swapSelfInParams(params)
												: params;
										v[type + "Scope"] = scope;
									}
									if (type === "onUpdate") {
										this._onUpdate = callback;
									}
								}
								return this;
							};
							p.delay = function (value) {
								if (!arguments.length) {
									return this._delay;
								}
								if (this._timeline.smoothChildTiming) {
									this.startTime(this._startTime + value - this._delay);
								}
								this._delay = value;
								return this;
							};
							p.duration = function (value) {
								if (!arguments.length) {
									this._dirty = false;
									return this._duration;
								}
								this._duration = this._totalDuration = value;
								this._uncache(true);
								if (this._timeline.smoothChildTiming)
									if (this._time > 0)
										if (this._time < this._duration)
											if (value !== 0) {
												this.totalTime(
													this._totalTime * (value / this._duration),
													true
												);
											}
								return this;
							};
							p.totalDuration = function (value) {
								this._dirty = false;
								return !arguments.length
									? this._totalDuration
									: this.duration(value);
							};
							p.time = function (value, suppressEvents) {
								if (!arguments.length) {
									return this._time;
								}
								if (this._dirty) {
									this.totalDuration();
								}
								return this.totalTime(
									value > this._duration ? this._duration : value,
									suppressEvents
								);
							};
							p.totalTime = function (time, suppressEvents, uncapped) {
								if (!_tickerActive) {
									_ticker.wake();
								}
								if (!arguments.length) {
									return this._totalTime;
								}
								if (this._timeline) {
									if (time < 0 && !uncapped) {
										time += this.totalDuration();
									}
									if (this._timeline.smoothChildTiming) {
										if (this._dirty) {
											this.totalDuration();
										}
										var totalDuration = this._totalDuration,
											tl = this._timeline;
										if (time > totalDuration && !uncapped) {
											time = totalDuration;
										}
										this._startTime =
											(this._paused ? this._pauseTime : tl._time) -
											(!this._reversed ? time : totalDuration - time) /
												this._timeScale;
										if (!tl._dirty) {
											this._uncache(false);
										}
										if (tl._timeline) {
											while (tl._timeline) {
												if (
													tl._timeline._time !==
													(tl._startTime + tl._totalTime) / tl._timeScale
												) {
													tl.totalTime(tl._totalTime, true);
												}
												tl = tl._timeline;
											}
										}
									}
									if (this._gc) {
										this._enabled(true, false);
									}
									if (this._totalTime !== time || this._duration === 0) {
										if (_lazyTweens.length) {
											_lazyRender();
										}
										this.render(time, suppressEvents, false);
										if (_lazyTweens.length) {
											_lazyRender();
										}
									}
								}
								return this;
							};
							p.progress = p.totalProgress = function (value, suppressEvents) {
								var duration = this.duration();
								return !arguments.length
									? duration
										? this._time / duration
										: this.ratio
									: this.totalTime(duration * value, suppressEvents);
							};
							p.startTime = function (value) {
								if (!arguments.length) {
									return this._startTime;
								}
								if (value !== this._startTime) {
									this._startTime = value;
									if (this.timeline)
										if (this.timeline._sortChildren) {
											this.timeline.add(this, value - this._delay);
										}
								}
								return this;
							};
							p.endTime = function (includeRepeats) {
								return (
									this._startTime +
									(includeRepeats != false
										? this.totalDuration()
										: this.duration()) /
										this._timeScale
								);
							};
							p.timeScale = function (value) {
								if (!arguments.length) {
									return this._timeScale;
								}
								var pauseTime, t;
								value = value || _tinyNum;
								if (this._timeline && this._timeline.smoothChildTiming) {
									pauseTime = this._pauseTime;
									t =
										pauseTime || pauseTime === 0
											? pauseTime
											: this._timeline.totalTime();
									this._startTime =
										t - ((t - this._startTime) * this._timeScale) / value;
								}
								this._timeScale = value;
								t = this.timeline;
								while (t && t.timeline) {
									t._dirty = true;
									t.totalDuration();
									t = t.timeline;
								}
								return this;
							};
							p.reversed = function (value) {
								if (!arguments.length) {
									return this._reversed;
								}
								if (value != this._reversed) {
									this._reversed = value;
									this.totalTime(
										this._timeline && !this._timeline.smoothChildTiming
											? this.totalDuration() - this._totalTime
											: this._totalTime,
										true
									);
								}
								return this;
							};
							p.paused = function (value) {
								if (!arguments.length) {
									return this._paused;
								}
								var tl = this._timeline,
									raw,
									elapsed;
								if (value != this._paused)
									if (tl) {
										if (!_tickerActive && !value) {
											_ticker.wake();
										}
										raw = tl.rawTime();
										elapsed = raw - this._pauseTime;
										if (!value && tl.smoothChildTiming) {
											this._startTime += elapsed;
											this._uncache(false);
										}
										this._pauseTime = value ? raw : null;
										this._paused = value;
										this._active = this.isActive();
										if (
											!value &&
											elapsed !== 0 &&
											this._initted &&
											this.duration()
										) {
											raw = tl.smoothChildTiming
												? this._totalTime
												: (raw - this._startTime) / this._timeScale;
											this.render(raw, raw === this._totalTime, true);
										}
									}
								if (this._gc && !value) {
									this._enabled(true, false);
								}
								return this;
							};
							var SimpleTimeline = _class(
								"core.SimpleTimeline",
								function (vars) {
									Animation.call(this, 0, vars);
									this.autoRemoveChildren = this.smoothChildTiming = true;
								}
							);
							p = SimpleTimeline.prototype = new Animation();
							p.constructor = SimpleTimeline;
							p.kill()._gc = false;
							p._first = p._last = p._recent = null;
							p._sortChildren = false;
							p.add = p.insert = function (child, position, align, stagger) {
								var prevTween, st;
								child._startTime = Number(position || 0) + child._delay;
								if (child._paused)
									if (this !== child._timeline) {
										child._pauseTime =
											this.rawTime() -
											(child._timeline.rawTime() - child._pauseTime);
									}
								if (child.timeline) {
									child.timeline._remove(child, true);
								}
								child.timeline = child._timeline = this;
								if (child._gc) {
									child._enabled(true, true);
								}
								prevTween = this._last;
								if (this._sortChildren) {
									st = child._startTime;
									while (prevTween && prevTween._startTime > st) {
										prevTween = prevTween._prev;
									}
								}
								if (prevTween) {
									child._next = prevTween._next;
									prevTween._next = child;
								} else {
									child._next = this._first;
									this._first = child;
								}
								if (child._next) {
									child._next._prev = child;
								} else {
									this._last = child;
								}
								child._prev = prevTween;
								this._recent = child;
								if (this._timeline) {
									this._uncache(true);
								}
								return this;
							};
							p._remove = function (tween, skipDisable) {
								if (tween.timeline === this) {
									if (!skipDisable) {
										tween._enabled(false, true);
									}
									if (tween._prev) {
										tween._prev._next = tween._next;
									} else if (this._first === tween) {
										this._first = tween._next;
									}
									if (tween._next) {
										tween._next._prev = tween._prev;
									} else if (this._last === tween) {
										this._last = tween._prev;
									}
									tween._next = tween._prev = tween.timeline = null;
									if (tween === this._recent) {
										this._recent = this._last;
									}
									if (this._timeline) {
										this._uncache(true);
									}
								}
								return this;
							};
							p.render = function (time, suppressEvents, force) {
								var tween = this._first,
									next;
								this._totalTime = this._time = this._rawPrevTime = time;
								while (tween) {
									next = tween._next;
									if (
										tween._active ||
										(time >= tween._startTime && !tween._paused && !tween._gc)
									) {
										if (!tween._reversed) {
											tween.render(
												(time - tween._startTime) * tween._timeScale,
												suppressEvents,
												force
											);
										} else {
											tween.render(
												(!tween._dirty
													? tween._totalDuration
													: tween.totalDuration()) -
													(time - tween._startTime) * tween._timeScale,
												suppressEvents,
												force
											);
										}
									}
									tween = next;
								}
							};
							p.rawTime = function () {
								if (!_tickerActive) {
									_ticker.wake();
								}
								return this._totalTime;
							};
							var TweenLite = _class(
									"TweenLite",
									function (target, duration, vars) {
										Animation.call(this, duration, vars);
										this.render = TweenLite.prototype.render;
										if (target == null) {
											throw "Cannot tween a null target.";
										}
										this.target = target =
											typeof target !== "string"
												? target
												: TweenLite.selector(target) || target;
										var isSelector =
												target.jquery ||
												(target.length &&
													target !== window &&
													target[0] &&
													(target[0] === window ||
														(target[0].nodeType &&
															target[0].style &&
															!target.nodeType))),
											overwrite = this.vars.overwrite,
											i,
											targ,
											targets;
										this._overwrite = overwrite =
											overwrite == null
												? _overwriteLookup[TweenLite.defaultOverwrite]
												: typeof overwrite === "number"
												? overwrite >> 0
												: _overwriteLookup[overwrite];
										if (
											(isSelector ||
												target instanceof Array ||
												(target.push && _isArray(target))) &&
											typeof target[0] !== "number"
										) {
											this._targets = targets = _slice(target);
											this._propLookup = [];
											this._siblings = [];
											for (i = 0; i < targets.length; i++) {
												targ = targets[i];
												if (!targ) {
													targets.splice(i--, 1);
													continue;
												} else if (typeof targ === "string") {
													targ = targets[i--] = TweenLite.selector(targ);
													if (typeof targ === "string") {
														targets.splice(i + 1, 1);
													}
													continue;
												} else if (
													targ.length &&
													targ !== window &&
													targ[0] &&
													(targ[0] === window ||
														(targ[0].nodeType &&
															targ[0].style &&
															!targ.nodeType))
												) {
													targets.splice(i--, 1);
													this._targets = targets = targets.concat(
														_slice(targ)
													);
													continue;
												}
												this._siblings[i] = _register(targ, this, false);
												if (overwrite === 1)
													if (this._siblings[i].length > 1) {
														_applyOverwrite(
															targ,
															this,
															null,
															1,
															this._siblings[i]
														);
													}
											}
										} else {
											this._propLookup = {};
											this._siblings = _register(target, this, false);
											if (overwrite === 1)
												if (this._siblings.length > 1) {
													_applyOverwrite(
														target,
														this,
														null,
														1,
														this._siblings
													);
												}
										}
										if (
											this.vars.immediateRender ||
											(duration === 0 &&
												this._delay === 0 &&
												this.vars.immediateRender !== false)
										) {
											this._time = -_tinyNum;
											this.render(Math.min(0, -this._delay));
										}
									},
									true
								),
								_isSelector = function (v) {
									return (
										v &&
										v.length &&
										v !== window &&
										v[0] &&
										(v[0] === window ||
											(v[0].nodeType && v[0].style && !v.nodeType))
									);
								},
								_autoCSS = function (vars, target) {
									var css = {},
										p;
									for (p in vars) {
										if (
											!_reservedProps[p] &&
											(!(p in target) ||
												p === "transform" ||
												p === "x" ||
												p === "y" ||
												p === "width" ||
												p === "height" ||
												p === "className" ||
												p === "border") &&
											(!_plugins[p] || (_plugins[p] && _plugins[p]._autoCSS))
										) {
											css[p] = vars[p];
											delete vars[p];
										}
									}
									vars.css = css;
								};
							p = TweenLite.prototype = new Animation();
							p.constructor = TweenLite;
							p.kill()._gc = false;
							p.ratio = 0;
							p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
							p._notifyPluginsOfEnabled = p._lazy = false;
							TweenLite.version = "2.0.1";
							TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
							TweenLite.defaultOverwrite = "auto";
							TweenLite.ticker = _ticker;
							TweenLite.autoSleep = 120;
							TweenLite.lagSmoothing = function (threshold, adjustedLag) {
								_ticker.lagSmoothing(threshold, adjustedLag);
							};
							TweenLite.selector =
								window.$ ||
								window.jQuery ||
								function (e) {
									var selector = window.$ || window.jQuery;
									if (selector) {
										TweenLite.selector = selector;
										return selector(e);
									}
									if (!_doc) {
										_doc = window.document;
									}
									return !_doc
										? e
										: _doc.querySelectorAll
										? _doc.querySelectorAll(e)
										: _doc.getElementById(
												e.charAt(0) === "#" ? e.substr(1) : e
										  );
								};
							var _lazyTweens = [],
								_lazyLookup = {},
								_numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
								_relExp = /[\+-]=-?[\.\d]/,
								_setRatio = function (v) {
									var pt = this._firstPT,
										min = 1e-6,
										val;
									while (pt) {
										val = !pt.blob
											? pt.c * v + pt.s
											: v === 1 && this.end != null
											? this.end
											: v
											? this.join("")
											: this.start;
										if (pt.m) {
											val = pt.m.call(
												this._tween,
												val,
												this._target || pt.t,
												this._tween
											);
										} else if (val < min)
											if (val > -min && !pt.blob) {
												val = 0;
											}
										if (!pt.f) {
											pt.t[pt.p] = val;
										} else if (pt.fp) {
											pt.t[pt.p](pt.fp, val);
										} else {
											pt.t[pt.p](val);
										}
										pt = pt._next;
									}
								},
								_blobDif = function (start, end, filter, pt) {
									var a = [],
										charIndex = 0,
										s = "",
										color = 0,
										startNums,
										endNums,
										num,
										i,
										l,
										nonNumbers,
										currentNum;
									a.start = start;
									a.end = end;
									start = a[0] = start + "";
									end = a[1] = end + "";
									if (filter) {
										filter(a);
										start = a[0];
										end = a[1];
									}
									a.length = 0;
									startNums = start.match(_numbersExp) || [];
									endNums = end.match(_numbersExp) || [];
									if (pt) {
										pt._next = null;
										pt.blob = 1;
										a._firstPT = a._applyPT = pt;
									}
									l = endNums.length;
									for (i = 0; i < l; i++) {
										currentNum = endNums[i];
										nonNumbers = end.substr(
											charIndex,
											end.indexOf(currentNum, charIndex) - charIndex
										);
										s += nonNumbers || !i ? nonNumbers : ",";
										charIndex += nonNumbers.length;
										if (color) {
											color = (color + 1) % 5;
										} else if (nonNumbers.substr(-5) === "rgba(") {
											color = 1;
										}
										if (currentNum === startNums[i] || startNums.length <= i) {
											s += currentNum;
										} else {
											if (s) {
												a.push(s);
												s = "";
											}
											num = parseFloat(startNums[i]);
											a.push(num);
											a._firstPT = {
												_next: a._firstPT,
												t: a,
												p: a.length - 1,
												s: num,
												c:
													(currentNum.charAt(1) === "="
														? parseInt(currentNum.charAt(0) + "1", 10) *
														  parseFloat(currentNum.substr(2))
														: parseFloat(currentNum) - num) || 0,
												f: 0,
												m: color && color < 4 ? Math.round : 0,
											};
										}
										charIndex += currentNum.length;
									}
									s += end.substr(charIndex);
									if (s) {
										a.push(s);
									}
									a.setRatio = _setRatio;
									if (_relExp.test(end)) {
										a.end = null;
									}
									return a;
								},
								_addPropTween = function (
									target,
									prop,
									start,
									end,
									overwriteProp,
									mod,
									funcParam,
									stringFilter,
									index
								) {
									if (typeof end === "function") {
										end = end(index || 0, target);
									}
									var type = typeof target[prop],
										getterName =
											type !== "function"
												? ""
												: prop.indexOf("set") ||
												  typeof target["get" + prop.substr(3)] !== "function"
												? prop
												: "get" + prop.substr(3),
										s =
											start !== "get"
												? start
												: !getterName
												? target[prop]
												: funcParam
												? target[getterName](funcParam)
												: target[getterName](),
										isRelative =
											typeof end === "string" && end.charAt(1) === "=",
										pt = {
											t: target,
											p: prop,
											s: s,
											f: type === "function",
											pg: 0,
											n: overwriteProp || prop,
											m: !mod
												? 0
												: typeof mod === "function"
												? mod
												: Math.round,
											pr: 0,
											c: isRelative
												? parseInt(end.charAt(0) + "1", 10) *
												  parseFloat(end.substr(2))
												: parseFloat(end) - s || 0,
										},
										blob;
									if (
										typeof s !== "number" ||
										(typeof end !== "number" && !isRelative)
									) {
										if (
											funcParam ||
											isNaN(s) ||
											(!isRelative && isNaN(end)) ||
											typeof s === "boolean" ||
											typeof end === "boolean"
										) {
											pt.fp = funcParam;
											blob = _blobDif(
												s,
												isRelative
													? parseFloat(pt.s) +
															pt.c +
															(pt.s + "").replace(/[0-9\-\.]/g, "")
													: end,
												stringFilter || TweenLite.defaultStringFilter,
												pt
											);
											pt = {
												t: blob,
												p: "setRatio",
												s: 0,
												c: 1,
												f: 2,
												pg: 0,
												n: overwriteProp || prop,
												pr: 0,
												m: 0,
											};
										} else {
											pt.s = parseFloat(s);
											if (!isRelative) {
												pt.c = parseFloat(end) - pt.s || 0;
											}
										}
									}
									if (pt.c) {
										if ((pt._next = this._firstPT)) {
											pt._next._prev = pt;
										}
										this._firstPT = pt;
										return pt;
									}
								},
								_internals = (TweenLite._internals = {
									isArray: _isArray,
									isSelector: _isSelector,
									lazyTweens: _lazyTweens,
									blobDif: _blobDif,
								}),
								_plugins = (TweenLite._plugins = {}),
								_tweenLookup = (_internals.tweenLookup = {}),
								_tweenLookupNum = 0,
								_reservedProps = (_internals.reservedProps = {
									ease: 1,
									delay: 1,
									overwrite: 1,
									onComplete: 1,
									onCompleteParams: 1,
									onCompleteScope: 1,
									useFrames: 1,
									runBackwards: 1,
									startAt: 1,
									onUpdate: 1,
									onUpdateParams: 1,
									onUpdateScope: 1,
									onStart: 1,
									onStartParams: 1,
									onStartScope: 1,
									onReverseComplete: 1,
									onReverseCompleteParams: 1,
									onReverseCompleteScope: 1,
									onRepeat: 1,
									onRepeatParams: 1,
									onRepeatScope: 1,
									easeParams: 1,
									yoyo: 1,
									immediateRender: 1,
									repeat: 1,
									repeatDelay: 1,
									data: 1,
									paused: 1,
									reversed: 1,
									autoCSS: 1,
									lazy: 1,
									onOverwrite: 1,
									callbackScope: 1,
									stringFilter: 1,
									id: 1,
									yoyoEase: 1,
								}),
								_overwriteLookup = {
									none: 0,
									all: 1,
									auto: 2,
									concurrent: 3,
									allOnStart: 4,
									preexisting: 5,
									true: 1,
									false: 0,
								},
								_rootFramesTimeline = (Animation._rootFramesTimeline =
									new SimpleTimeline()),
								_rootTimeline = (Animation._rootTimeline =
									new SimpleTimeline()),
								_nextGCFrame = 30,
								_lazyRender = (_internals.lazyRender = function () {
									var i = _lazyTweens.length,
										tween;
									_lazyLookup = {};
									while (--i > -1) {
										tween = _lazyTweens[i];
										if (tween && tween._lazy !== false) {
											tween.render(tween._lazy[0], tween._lazy[1], true);
											tween._lazy = false;
										}
									}
									_lazyTweens.length = 0;
								});
							_rootTimeline._startTime = _ticker.time;
							_rootFramesTimeline._startTime = _ticker.frame;
							_rootTimeline._active = _rootFramesTimeline._active = true;
							setTimeout(_lazyRender, 1);
							Animation._updateRoot = TweenLite.render = function () {
								var i, a, p;
								if (_lazyTweens.length) {
									_lazyRender();
								}
								_rootTimeline.render(
									(_ticker.time - _rootTimeline._startTime) *
										_rootTimeline._timeScale,
									false,
									false
								);
								_rootFramesTimeline.render(
									(_ticker.frame - _rootFramesTimeline._startTime) *
										_rootFramesTimeline._timeScale,
									false,
									false
								);
								if (_lazyTweens.length) {
									_lazyRender();
								}
								if (_ticker.frame >= _nextGCFrame) {
									_nextGCFrame =
										_ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
									for (p in _tweenLookup) {
										a = _tweenLookup[p].tweens;
										i = a.length;
										while (--i > -1) {
											if (a[i]._gc) {
												a.splice(i, 1);
											}
										}
										if (a.length === 0) {
											delete _tweenLookup[p];
										}
									}
									p = _rootTimeline._first;
									if (!p || p._paused)
										if (
											TweenLite.autoSleep &&
											!_rootFramesTimeline._first &&
											_ticker._listeners.tick.length === 1
										) {
											while (p && p._paused) {
												p = p._next;
											}
											if (!p) {
												_ticker.sleep();
											}
										}
								}
							};
							_ticker.addEventListener("tick", Animation._updateRoot);
							var _register = function (target, tween, scrub) {
									var id = target._gsTweenID,
										a,
										i;
									if (
										!_tweenLookup[
											id || (target._gsTweenID = id = "t" + _tweenLookupNum++)
										]
									) {
										_tweenLookup[id] = { target: target, tweens: [] };
									}
									if (tween) {
										a = _tweenLookup[id].tweens;
										a[(i = a.length)] = tween;
										if (scrub) {
											while (--i > -1) {
												if (a[i] === tween) {
													a.splice(i, 1);
												}
											}
										}
									}
									return _tweenLookup[id].tweens;
								},
								_onOverwrite = function (
									overwrittenTween,
									overwritingTween,
									target,
									killedProps
								) {
									var func = overwrittenTween.vars.onOverwrite,
										r1,
										r2;
									if (func) {
										r1 = func(
											overwrittenTween,
											overwritingTween,
											target,
											killedProps
										);
									}
									func = TweenLite.onOverwrite;
									if (func) {
										r2 = func(
											overwrittenTween,
											overwritingTween,
											target,
											killedProps
										);
									}
									return r1 !== false && r2 !== false;
								},
								_applyOverwrite = function (
									target,
									tween,
									props,
									mode,
									siblings
								) {
									var i, changed, curTween, l;
									if (mode === 1 || mode >= 4) {
										l = siblings.length;
										for (i = 0; i < l; i++) {
											if ((curTween = siblings[i]) !== tween) {
												if (!curTween._gc) {
													if (curTween._kill(null, target, tween)) {
														changed = true;
													}
												}
											} else if (mode === 5) {
												break;
											}
										}
										return changed;
									}
									var startTime = tween._startTime + _tinyNum,
										overlaps = [],
										oCount = 0,
										zeroDur = tween._duration === 0,
										globalStart;
									i = siblings.length;
									while (--i > -1) {
										if (
											(curTween = siblings[i]) === tween ||
											curTween._gc ||
											curTween._paused
										) {
										} else if (curTween._timeline !== tween._timeline) {
											globalStart =
												globalStart || _checkOverlap(tween, 0, zeroDur);
											if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
												overlaps[oCount++] = curTween;
											}
										} else if (curTween._startTime <= startTime)
											if (
												curTween._startTime +
													curTween.totalDuration() / curTween._timeScale >
												startTime
											)
												if (
													!(
														(zeroDur || !curTween._initted) &&
														startTime - curTween._startTime <= 2e-10
													)
												) {
													overlaps[oCount++] = curTween;
												}
									}
									i = oCount;
									while (--i > -1) {
										curTween = overlaps[i];
										if (mode === 2)
											if (curTween._kill(props, target, tween)) {
												changed = true;
											}
										if (
											mode !== 2 ||
											(!curTween._firstPT && curTween._initted)
										) {
											if (mode !== 2 && !_onOverwrite(curTween, tween)) {
												continue;
											}
											if (curTween._enabled(false, false)) {
												changed = true;
											}
										}
									}
									return changed;
								},
								_checkOverlap = function (tween, reference, zeroDur) {
									var tl = tween._timeline,
										ts = tl._timeScale,
										t = tween._startTime;
									while (tl._timeline) {
										t += tl._startTime;
										ts *= tl._timeScale;
										if (tl._paused) {
											return -100;
										}
										tl = tl._timeline;
									}
									t /= ts;
									return t > reference
										? t - reference
										: (zeroDur && t === reference) ||
										  (!tween._initted && t - reference < 2 * _tinyNum)
										? _tinyNum
										: (t += tween.totalDuration() / tween._timeScale / ts) >
										  reference + _tinyNum
										? 0
										: t - reference - _tinyNum;
								};
							p._init = function () {
								var v = this.vars,
									op = this._overwrittenProps,
									dur = this._duration,
									immediate = !!v.immediateRender,
									ease = v.ease,
									i,
									initPlugins,
									pt,
									p,
									startVars,
									l;
								if (v.startAt) {
									if (this._startAt) {
										this._startAt.render(-1, true);
										this._startAt.kill();
									}
									startVars = {};
									for (p in v.startAt) {
										startVars[p] = v.startAt[p];
									}
									startVars.data = "isStart";
									startVars.overwrite = false;
									startVars.immediateRender = true;
									startVars.lazy = immediate && v.lazy !== false;
									startVars.startAt = startVars.delay = null;
									startVars.onUpdate = v.onUpdate;
									startVars.onUpdateParams = v.onUpdateParams;
									startVars.onUpdateScope =
										v.onUpdateScope || v.callbackScope || this;
									this._startAt = TweenLite.to(this.target || {}, 0, startVars);
									if (immediate) {
										if (this._time > 0) {
											this._startAt = null;
										} else if (dur !== 0) {
											return;
										}
									}
								} else if (v.runBackwards && dur !== 0) {
									if (this._startAt) {
										this._startAt.render(-1, true);
										this._startAt.kill();
										this._startAt = null;
									} else {
										if (this._time !== 0) {
											immediate = false;
										}
										pt = {};
										for (p in v) {
											if (!_reservedProps[p] || p === "autoCSS") {
												pt[p] = v[p];
											}
										}
										pt.overwrite = 0;
										pt.data = "isFromStart";
										pt.lazy = immediate && v.lazy !== false;
										pt.immediateRender = immediate;
										this._startAt = TweenLite.to(this.target, 0, pt);
										if (!immediate) {
											this._startAt._init();
											this._startAt._enabled(false);
											if (this.vars.immediateRender) {
												this._startAt = null;
											}
										} else if (this._time === 0) {
											return;
										}
									}
								}
								this._ease = ease = !ease
									? TweenLite.defaultEase
									: ease instanceof Ease
									? ease
									: typeof ease === "function"
									? new Ease(ease, v.easeParams)
									: _easeMap[ease] || TweenLite.defaultEase;
								if (v.easeParams instanceof Array && ease.config) {
									this._ease = ease.config.apply(ease, v.easeParams);
								}
								this._easeType = this._ease._type;
								this._easePower = this._ease._power;
								this._firstPT = null;
								if (this._targets) {
									l = this._targets.length;
									for (i = 0; i < l; i++) {
										if (
											this._initProps(
												this._targets[i],
												(this._propLookup[i] = {}),
												this._siblings[i],
												op ? op[i] : null,
												i
											)
										) {
											initPlugins = true;
										}
									}
								} else {
									initPlugins = this._initProps(
										this.target,
										this._propLookup,
										this._siblings,
										op,
										0
									);
								}
								if (initPlugins) {
									TweenLite._onPluginEvent("_onInitAllProps", this);
								}
								if (op)
									if (!this._firstPT)
										if (typeof this.target !== "function") {
											this._enabled(false, false);
										}
								if (v.runBackwards) {
									pt = this._firstPT;
									while (pt) {
										pt.s += pt.c;
										pt.c = -pt.c;
										pt = pt._next;
									}
								}
								this._onUpdate = v.onUpdate;
								this._initted = true;
							};
							p._initProps = function (
								target,
								propLookup,
								siblings,
								overwrittenProps,
								index
							) {
								var p, i, initPlugins, plugin, pt, v;
								if (target == null) {
									return false;
								}
								if (_lazyLookup[target._gsTweenID]) {
									_lazyRender();
								}
								if (!this.vars.css)
									if (target.style)
										if (target !== window && target.nodeType)
											if (_plugins.css)
												if (this.vars.autoCSS !== false) {
													_autoCSS(this.vars, target);
												}
								for (p in this.vars) {
									v = this.vars[p];
									if (_reservedProps[p]) {
										if (v)
											if (v instanceof Array || (v.push && _isArray(v)))
												if (v.join("").indexOf("{self}") !== -1) {
													this.vars[p] = v = this._swapSelfInParams(v, this);
												}
									} else if (
										_plugins[p] &&
										(plugin = new _plugins[p]())._onInitTween(
											target,
											this.vars[p],
											this,
											index
										)
									) {
										this._firstPT = pt = {
											_next: this._firstPT,
											t: plugin,
											p: "setRatio",
											s: 0,
											c: 1,
											f: 1,
											n: p,
											pg: 1,
											pr: plugin._priority,
											m: 0,
										};
										i = plugin._overwriteProps.length;
										while (--i > -1) {
											propLookup[plugin._overwriteProps[i]] = this._firstPT;
										}
										if (plugin._priority || plugin._onInitAllProps) {
											initPlugins = true;
										}
										if (plugin._onDisable || plugin._onEnable) {
											this._notifyPluginsOfEnabled = true;
										}
										if (pt._next) {
											pt._next._prev = pt;
										}
									} else {
										propLookup[p] = _addPropTween.call(
											this,
											target,
											p,
											"get",
											v,
											p,
											0,
											null,
											this.vars.stringFilter,
											index
										);
									}
								}
								if (overwrittenProps)
									if (this._kill(overwrittenProps, target)) {
										return this._initProps(
											target,
											propLookup,
											siblings,
											overwrittenProps,
											index
										);
									}
								if (this._overwrite > 1)
									if (this._firstPT)
										if (siblings.length > 1)
											if (
												_applyOverwrite(
													target,
													this,
													propLookup,
													this._overwrite,
													siblings
												)
											) {
												this._kill(propLookup, target);
												return this._initProps(
													target,
													propLookup,
													siblings,
													overwrittenProps,
													index
												);
											}
								if (this._firstPT)
									if (
										(this.vars.lazy !== false && this._duration) ||
										(this.vars.lazy && !this._duration)
									) {
										_lazyLookup[target._gsTweenID] = true;
									}
								return initPlugins;
							};
							p.render = function (time, suppressEvents, force) {
								var prevTime = this._time,
									duration = this._duration,
									prevRawPrevTime = this._rawPrevTime,
									isComplete,
									callback,
									pt,
									rawPrevTime;
								if (time >= duration - 1e-7 && time >= 0) {
									this._totalTime = this._time = duration;
									this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
									if (!this._reversed) {
										isComplete = true;
										callback = "onComplete";
										force = force || this._timeline.autoRemoveChildren;
									}
									if (duration === 0)
										if (this._initted || !this.vars.lazy || force) {
											if (this._startTime === this._timeline._duration) {
												time = 0;
											}
											if (
												prevRawPrevTime < 0 ||
												(time <= 0 && time >= -1e-7) ||
												(prevRawPrevTime === _tinyNum &&
													this.data !== "isPause")
											)
												if (prevRawPrevTime !== time) {
													force = true;
													if (prevRawPrevTime > _tinyNum) {
														callback = "onReverseComplete";
													}
												}
											this._rawPrevTime = rawPrevTime =
												!suppressEvents || time || prevRawPrevTime === time
													? time
													: _tinyNum;
										}
								} else if (time < 1e-7) {
									this._totalTime = this._time = 0;
									this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
									if (
										prevTime !== 0 ||
										(duration === 0 && prevRawPrevTime > 0)
									) {
										callback = "onReverseComplete";
										isComplete = this._reversed;
									}
									if (time < 0) {
										this._active = false;
										if (duration === 0)
											if (this._initted || !this.vars.lazy || force) {
												if (
													prevRawPrevTime >= 0 &&
													!(
														prevRawPrevTime === _tinyNum &&
														this.data === "isPause"
													)
												) {
													force = true;
												}
												this._rawPrevTime = rawPrevTime =
													!suppressEvents || time || prevRawPrevTime === time
														? time
														: _tinyNum;
											}
									}
									if (
										!this._initted ||
										(this._startAt && this._startAt.progress())
									) {
										force = true;
									}
								} else {
									this._totalTime = this._time = time;
									if (this._easeType) {
										var r = time / duration,
											type = this._easeType,
											pow = this._easePower;
										if (type === 1 || (type === 3 && r >= 0.5)) {
											r = 1 - r;
										}
										if (type === 3) {
											r *= 2;
										}
										if (pow === 1) {
											r *= r;
										} else if (pow === 2) {
											r *= r * r;
										} else if (pow === 3) {
											r *= r * r * r;
										} else if (pow === 4) {
											r *= r * r * r * r;
										}
										if (type === 1) {
											this.ratio = 1 - r;
										} else if (type === 2) {
											this.ratio = r;
										} else if (time / duration < 0.5) {
											this.ratio = r / 2;
										} else {
											this.ratio = 1 - r / 2;
										}
									} else {
										this.ratio = this._ease.getRatio(time / duration);
									}
								}
								if (this._time === prevTime && !force) {
									return;
								} else if (!this._initted) {
									this._init();
									if (!this._initted || this._gc) {
										return;
									} else if (
										!force &&
										this._firstPT &&
										((this.vars.lazy !== false && this._duration) ||
											(this.vars.lazy && !this._duration))
									) {
										this._time = this._totalTime = prevTime;
										this._rawPrevTime = prevRawPrevTime;
										_lazyTweens.push(this);
										this._lazy = [time, suppressEvents];
										return;
									}
									if (this._time && !isComplete) {
										this.ratio = this._ease.getRatio(this._time / duration);
									} else if (isComplete && this._ease._calcEnd) {
										this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1);
									}
								}
								if (this._lazy !== false) {
									this._lazy = false;
								}
								if (!this._active)
									if (!this._paused && this._time !== prevTime && time >= 0) {
										this._active = true;
									}
								if (prevTime === 0) {
									if (this._startAt) {
										if (time >= 0) {
											this._startAt.render(time, true, force);
										} else if (!callback) {
											callback = "_dummyGS";
										}
									}
									if (this.vars.onStart)
										if (this._time !== 0 || duration === 0)
											if (!suppressEvents) {
												this._callback("onStart");
											}
								}
								pt = this._firstPT;
								while (pt) {
									if (pt.f) {
										pt.t[pt.p](pt.c * this.ratio + pt.s);
									} else {
										pt.t[pt.p] = pt.c * this.ratio + pt.s;
									}
									pt = pt._next;
								}
								if (this._onUpdate) {
									if (time < 0)
										if (this._startAt && time !== -1e-4) {
											this._startAt.render(time, true, force);
										}
									if (!suppressEvents)
										if (this._time !== prevTime || isComplete || force) {
											this._callback("onUpdate");
										}
								}
								if (callback)
									if (!this._gc || force) {
										if (
											time < 0 &&
											this._startAt &&
											!this._onUpdate &&
											time !== -1e-4
										) {
											this._startAt.render(time, true, force);
										}
										if (isComplete) {
											if (this._timeline.autoRemoveChildren) {
												this._enabled(false, false);
											}
											this._active = false;
										}
										if (!suppressEvents && this.vars[callback]) {
											this._callback(callback);
										}
										if (
											duration === 0 &&
											this._rawPrevTime === _tinyNum &&
											rawPrevTime !== _tinyNum
										) {
											this._rawPrevTime = 0;
										}
									}
							};
							p._kill = function (vars, target, overwritingTween) {
								if (vars === "all") {
									vars = null;
								}
								if (vars == null)
									if (target == null || target === this.target) {
										this._lazy = false;
										return this._enabled(false, false);
									}
								target =
									typeof target !== "string"
										? target || this._targets || this.target
										: TweenLite.selector(target) || target;
								var simultaneousOverwrite =
										overwritingTween &&
										this._time &&
										overwritingTween._startTime === this._startTime &&
										this._timeline === overwritingTween._timeline,
									i,
									overwrittenProps,
									p,
									pt,
									propLookup,
									changed,
									killProps,
									record,
									killed;
								if (
									(_isArray(target) || _isSelector(target)) &&
									typeof target[0] !== "number"
								) {
									i = target.length;
									while (--i > -1) {
										if (this._kill(vars, target[i], overwritingTween)) {
											changed = true;
										}
									}
								} else {
									if (this._targets) {
										i = this._targets.length;
										while (--i > -1) {
											if (target === this._targets[i]) {
												propLookup = this._propLookup[i] || {};
												this._overwrittenProps = this._overwrittenProps || [];
												overwrittenProps = this._overwrittenProps[i] = vars
													? this._overwrittenProps[i] || {}
													: "all";
												break;
											}
										}
									} else if (target !== this.target) {
										return false;
									} else {
										propLookup = this._propLookup;
										overwrittenProps = this._overwrittenProps = vars
											? this._overwrittenProps || {}
											: "all";
									}
									if (propLookup) {
										killProps = vars || propLookup;
										record =
											vars !== overwrittenProps &&
											overwrittenProps !== "all" &&
											vars !== propLookup &&
											(typeof vars !== "object" || !vars._tempKill);
										if (
											overwritingTween &&
											(TweenLite.onOverwrite || this.vars.onOverwrite)
										) {
											for (p in killProps) {
												if (propLookup[p]) {
													if (!killed) {
														killed = [];
													}
													killed.push(p);
												}
											}
											if (
												(killed || !vars) &&
												!_onOverwrite(this, overwritingTween, target, killed)
											) {
												return false;
											}
										}
										for (p in killProps) {
											if ((pt = propLookup[p])) {
												if (simultaneousOverwrite) {
													if (pt.f) {
														pt.t[pt.p](pt.s);
													} else {
														pt.t[pt.p] = pt.s;
													}
													changed = true;
												}
												if (pt.pg && pt.t._kill(killProps)) {
													changed = true;
												}
												if (!pt.pg || pt.t._overwriteProps.length === 0) {
													if (pt._prev) {
														pt._prev._next = pt._next;
													} else if (pt === this._firstPT) {
														this._firstPT = pt._next;
													}
													if (pt._next) {
														pt._next._prev = pt._prev;
													}
													pt._next = pt._prev = null;
												}
												delete propLookup[p];
											}
											if (record) {
												overwrittenProps[p] = 1;
											}
										}
										if (!this._firstPT && this._initted) {
											this._enabled(false, false);
										}
									}
								}
								return changed;
							};
							p.invalidate = function () {
								if (this._notifyPluginsOfEnabled) {
									TweenLite._onPluginEvent("_onDisable", this);
								}
								this._firstPT =
									this._overwrittenProps =
									this._startAt =
									this._onUpdate =
										null;
								this._notifyPluginsOfEnabled =
									this._active =
									this._lazy =
										false;
								this._propLookup = this._targets ? {} : [];
								Animation.prototype.invalidate.call(this);
								if (this.vars.immediateRender) {
									this._time = -_tinyNum;
									this.render(Math.min(0, -this._delay));
								}
								return this;
							};
							p._enabled = function (enabled, ignoreTimeline) {
								if (!_tickerActive) {
									_ticker.wake();
								}
								if (enabled && this._gc) {
									var targets = this._targets,
										i;
									if (targets) {
										i = targets.length;
										while (--i > -1) {
											this._siblings[i] = _register(targets[i], this, true);
										}
									} else {
										this._siblings = _register(this.target, this, true);
									}
								}
								Animation.prototype._enabled.call(
									this,
									enabled,
									ignoreTimeline
								);
								if (this._notifyPluginsOfEnabled)
									if (this._firstPT) {
										return TweenLite._onPluginEvent(
											enabled ? "_onEnable" : "_onDisable",
											this
										);
									}
								return false;
							};
							TweenLite.to = function (target, duration, vars) {
								return new TweenLite(target, duration, vars);
							};
							TweenLite.from = function (target, duration, vars) {
								vars.runBackwards = true;
								vars.immediateRender = vars.immediateRender != false;
								return new TweenLite(target, duration, vars);
							};
							TweenLite.fromTo = function (target, duration, fromVars, toVars) {
								toVars.startAt = fromVars;
								toVars.immediateRender =
									toVars.immediateRender != false &&
									fromVars.immediateRender != false;
								return new TweenLite(target, duration, toVars);
							};
							TweenLite.delayedCall = function (
								delay,
								callback,
								params,
								scope,
								useFrames
							) {
								return new TweenLite(callback, 0, {
									delay: delay,
									onComplete: callback,
									onCompleteParams: params,
									callbackScope: scope,
									onReverseComplete: callback,
									onReverseCompleteParams: params,
									immediateRender: false,
									lazy: false,
									useFrames: useFrames,
									overwrite: 0,
								});
							};
							TweenLite.set = function (target, vars) {
								return new TweenLite(target, 0, vars);
							};
							TweenLite.getTweensOf = function (target, onlyActive) {
								if (target == null) {
									return [];
								}
								target =
									typeof target !== "string"
										? target
										: TweenLite.selector(target) || target;
								var i, a, j, t;
								if (
									(_isArray(target) || _isSelector(target)) &&
									typeof target[0] !== "number"
								) {
									i = target.length;
									a = [];
									while (--i > -1) {
										a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
									}
									i = a.length;
									while (--i > -1) {
										t = a[i];
										j = i;
										while (--j > -1) {
											if (t === a[j]) {
												a.splice(i, 1);
											}
										}
									}
								} else if (target._gsTweenID) {
									a = _register(target).concat();
									i = a.length;
									while (--i > -1) {
										if (a[i]._gc || (onlyActive && !a[i].isActive())) {
											a.splice(i, 1);
										}
									}
								}
								return a || [];
							};
							TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function (
								target,
								onlyActive,
								vars
							) {
								if (typeof onlyActive === "object") {
									vars = onlyActive;
									onlyActive = false;
								}
								var a = TweenLite.getTweensOf(target, onlyActive),
									i = a.length;
								while (--i > -1) {
									a[i]._kill(vars, target);
								}
							};
							var TweenPlugin = _class(
								"plugins.TweenPlugin",
								function (props, priority) {
									this._overwriteProps = (props || "").split(",");
									this._propName = this._overwriteProps[0];
									this._priority = priority || 0;
									this._super = TweenPlugin.prototype;
								},
								true
							);
							p = TweenPlugin.prototype;
							TweenPlugin.version = "1.19.0";
							TweenPlugin.API = 2;
							p._firstPT = null;
							p._addTween = _addPropTween;
							p.setRatio = _setRatio;
							p._kill = function (lookup) {
								var a = this._overwriteProps,
									pt = this._firstPT,
									i;
								if (lookup[this._propName] != null) {
									this._overwriteProps = [];
								} else {
									i = a.length;
									while (--i > -1) {
										if (lookup[a[i]] != null) {
											a.splice(i, 1);
										}
									}
								}
								while (pt) {
									if (lookup[pt.n] != null) {
										if (pt._next) {
											pt._next._prev = pt._prev;
										}
										if (pt._prev) {
											pt._prev._next = pt._next;
											pt._prev = null;
										} else if (this._firstPT === pt) {
											this._firstPT = pt._next;
										}
									}
									pt = pt._next;
								}
								return false;
							};
							p._mod = p._roundProps = function (lookup) {
								var pt = this._firstPT,
									val;
								while (pt) {
									val =
										lookup[this._propName] ||
										(pt.n != null &&
											lookup[pt.n.split(this._propName + "_").join("")]);
									if (val && typeof val === "function") {
										if (pt.f === 2) {
											pt.t._applyPT.m = val;
										} else {
											pt.m = val;
										}
									}
									pt = pt._next;
								}
							};
							TweenLite._onPluginEvent = function (type, tween) {
								var pt = tween._firstPT,
									changed,
									pt2,
									first,
									last,
									next;
								if (type === "_onInitAllProps") {
									while (pt) {
										next = pt._next;
										pt2 = first;
										while (pt2 && pt2.pr > pt.pr) {
											pt2 = pt2._next;
										}
										if ((pt._prev = pt2 ? pt2._prev : last)) {
											pt._prev._next = pt;
										} else {
											first = pt;
										}
										if ((pt._next = pt2)) {
											pt2._prev = pt;
										} else {
											last = pt;
										}
										pt = next;
									}
									pt = tween._firstPT = first;
								}
								while (pt) {
									if (pt.pg)
										if (typeof pt.t[type] === "function")
											if (pt.t[type]()) {
												changed = true;
											}
									pt = pt._next;
								}
								return changed;
							};
							TweenPlugin.activate = function (plugins) {
								var i = plugins.length;
								while (--i > -1) {
									if (plugins[i].API === TweenPlugin.API) {
										_plugins[new plugins[i]()._propName] = plugins[i];
									}
								}
								return true;
							};
							_gsDefine.plugin = function (config) {
								if (
									!config ||
									!config.propName ||
									!config.init ||
									!config.API
								) {
									throw "illegal plugin definition.";
								}
								var propName = config.propName,
									priority = config.priority || 0,
									overwriteProps = config.overwriteProps,
									map = {
										init: "_onInitTween",
										set: "setRatio",
										kill: "_kill",
										round: "_mod",
										mod: "_mod",
										initAll: "_onInitAllProps",
									},
									Plugin = _class(
										"plugins." +
											propName.charAt(0).toUpperCase() +
											propName.substr(1) +
											"Plugin",
										function () {
											TweenPlugin.call(this, propName, priority);
											this._overwriteProps = overwriteProps || [];
										},
										config.global === true
									),
									p = (Plugin.prototype = new TweenPlugin(propName)),
									prop;
								p.constructor = Plugin;
								Plugin.API = config.API;
								for (prop in map) {
									if (typeof config[prop] === "function") {
										p[map[prop]] = config[prop];
									}
								}
								Plugin.version = config.version;
								TweenPlugin.activate([Plugin]);
								return Plugin;
							};
							a = window._gsQueue;
							if (a) {
								for (i = 0; i < a.length; i++) {
									a[i]();
								}
								for (p in _defLookup) {
									if (!_defLookup[p].func) {
										window.console.log(
											"GSAP encountered missing dependency: " + p
										);
									}
								}
							}
							_tickerActive = false;
						})(
							typeof module !== "undefined" &&
								module.exports &&
								typeof global !== "undefined"
								? global
								: this || window,
							"TweenLite"
						);
					}.call(this));
				}.call(
					this,
					typeof global !== "undefined"
						? global
						: typeof self !== "undefined"
						? self
						: typeof window !== "undefined"
						? window
						: {}
				));
			},
			{},
		],
		72: [
			function (require, module, exports) {
				(function (global) {
					(function () {
						var _gsScope =
							typeof module !== "undefined" &&
							module.exports &&
							typeof global !== "undefined"
								? global
								: this || window;
						(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {
							"use strict";
							var _doc = _gsScope.document,
								_getComputedStyle = _doc.defaultView
									? _doc.defaultView.getComputedStyle
									: function () {},
								_numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
								_isEdge =
									((_gsScope.navigator || {}).userAgent || "").indexOf(
										"Edge"
									) !== -1,
								DrawSVGPlugin;
							function getDistance(x1, y1, x2, y2, scaleX, scaleY) {
								x2 = (parseFloat(x2 || 0) - parseFloat(x1 || 0)) * scaleX;
								y2 = (parseFloat(y2 || 0) - parseFloat(y1 || 0)) * scaleY;
								return Math.sqrt(x2 * x2 + y2 * y2);
							}
							function unwrap(element) {
								if (typeof element === "string" || !element.nodeType) {
									element = _gsScope.TweenLite.selector(element);
									if (element.length) {
										element = element[0];
									}
								}
								return element;
							}
							function parse(value, length, defaultStart) {
								var i = value.indexOf(" "),
									s,
									e;
								if (i === -1) {
									s = defaultStart !== undefined ? defaultStart + "" : value;
									e = value;
								} else {
									s = value.substr(0, i);
									e = value.substr(i + 1);
								}
								s =
									s.indexOf("%") !== -1
										? (parseFloat(s) / 100) * length
										: parseFloat(s);
								e =
									e.indexOf("%") !== -1
										? (parseFloat(e) / 100) * length
										: parseFloat(e);
								return s > e ? [e, s] : [s, e];
							}
							function getLength(element) {
								if (!element) {
									return 0;
								}
								element = unwrap(element);
								var type = element.tagName.toLowerCase(),
									scaleX = 1,
									scaleY = 1,
									length,
									bbox,
									points,
									prevPoint,
									i,
									rx,
									ry;
								if (
									element.getAttribute("vector-effect") === "non-scaling-stroke"
								) {
									scaleY = element.getScreenCTM();
									scaleX = scaleY.a;
									scaleY = scaleY.d;
								}
								try {
									bbox = element.getBBox();
								} catch (e) {
									console.log(
										"Error: Some browsers like Firefox won't report measurements of invisible elements (like display:none)."
									);
								}
								if (
									(!bbox || (!bbox.width && !bbox.height)) &&
									(type === "rect" || type === "circle" || type === "ellipse")
								) {
									bbox = {
										width: parseFloat(
											element.getAttribute(
												type === "rect"
													? "width"
													: type === "circle"
													? "r"
													: "rx"
											)
										),
										height: parseFloat(
											element.getAttribute(
												type === "rect"
													? "height"
													: type === "circle"
													? "r"
													: "ry"
											)
										),
									};
									if (type !== "rect") {
										bbox.width *= 2;
										bbox.height *= 2;
									}
								}
								if (type === "path") {
									prevPoint = element.style.strokeDasharray;
									element.style.strokeDasharray = "none";
									length = element.getTotalLength() || 0;
									if (scaleX !== scaleY) {
										console.log(
											"Warning: <path> length cannot be measured accurately when vector-effect is non-scaling-stroke and the element isn't proportionally scaled."
										);
									}
									length *= (scaleX + scaleY) / 2;
									element.style.strokeDasharray = prevPoint;
								} else if (type === "rect") {
									length = bbox.width * 2 * scaleX + bbox.height * 2 * scaleY;
								} else if (type === "line") {
									length = getDistance(
										bbox.x,
										bbox.y,
										bbox.x + bbox.width,
										bbox.y + bbox.height,
										scaleX,
										scaleY
									);
								} else if (type === "polyline" || type === "polygon") {
									points =
										element.getAttribute("points").match(_numbersExp) || [];
									if (type === "polygon") {
										points.push(points[0], points[1]);
									}
									length = 0;
									for (i = 2; i < points.length; i += 2) {
										length +=
											getDistance(
												points[i - 2],
												points[i - 1],
												points[i],
												points[i + 1],
												scaleX,
												scaleY
											) || 0;
									}
								} else if (type === "circle" || type === "ellipse") {
									rx = (bbox.width / 2) * scaleX;
									ry = (bbox.height / 2) * scaleY;
									length =
										Math.PI *
										(3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
								}
								return length || 0;
							}
							function getPosition(element, length) {
								if (!element) {
									return [0, 0];
								}
								element = unwrap(element);
								length = length || getLength(element) + 1;
								var cs = _getComputedStyle(element),
									dash = cs.strokeDasharray || "",
									offset = parseFloat(cs.strokeDashoffset),
									i = dash.indexOf(",");
								if (i < 0) {
									i = dash.indexOf(" ");
								}
								dash = i < 0 ? length : parseFloat(dash.substr(0, i)) || 1e-5;
								if (dash > length) {
									dash = length;
								}
								return [Math.max(0, -offset), Math.max(0, dash - offset)];
							}
							DrawSVGPlugin = _gsScope._gsDefine.plugin({
								propName: "drawSVG",
								API: 2,
								version: "0.1.6",
								global: true,
								overwriteProps: ["drawSVG"],
								init: function (target, value, tween, index) {
									if (!target.getBBox) {
										return false;
									}
									var length = getLength(target) + 1,
										start,
										end,
										overage,
										cs;
									this._style = target.style;
									if (typeof value === "function") {
										value = value(index, target);
									}
									if (value === true || value === "true") {
										value = "0 100%";
									} else if (!value) {
										value = "0 0";
									} else if ((value + "").indexOf(" ") === -1) {
										value = "0 " + value;
									}
									start = getPosition(target, length);
									end = parse(value, length, start[0]);
									this._length = length + 10;
									if (start[0] === 0 && end[0] === 0) {
										overage = Math.max(1e-5, end[1] - length);
										this._dash = length + overage;
										this._offset = length - start[1] + overage;
										this._addTween(
											this,
											"_offset",
											this._offset,
											length - end[1] + overage,
											"drawSVG"
										);
									} else {
										this._dash = start[1] - start[0] || 1e-6;
										this._offset = -start[0];
										this._addTween(
											this,
											"_dash",
											this._dash,
											end[1] - end[0] || 1e-5,
											"drawSVG"
										);
										this._addTween(
											this,
											"_offset",
											this._offset,
											-end[0],
											"drawSVG"
										);
									}
									if (_isEdge) {
										cs = _getComputedStyle(target);
										if (cs.strokeLinecap !== cs.strokeLinejoin) {
											end = parseFloat(cs.strokeMiterlimit);
											this._addTween(
												target.style,
												"strokeMiterlimit",
												end,
												end + 1e-4,
												"strokeMiterlimit"
											);
										}
									}
									return true;
								},
								set: function (ratio) {
									if (this._firstPT) {
										this._super.setRatio.call(this, ratio);
										this._style.strokeDashoffset = this._offset;
										if (ratio === 1 || ratio === 0) {
											this._style.strokeDasharray =
												this._offset < 0.001 && this._length - this._dash <= 10
													? "none"
													: this._offset === this._dash
													? "0px, 999999px"
													: this._dash + "px," + this._length + "px";
										} else {
											this._style.strokeDasharray =
												this._dash + "px," + this._length + "px";
										}
									}
								},
							});
							DrawSVGPlugin.getLength = getLength;
							DrawSVGPlugin.getPosition = getPosition;
						});
						if (_gsScope._gsDefine) {
							_gsScope._gsQueue.pop()();
						}
						(function (name) {
							"use strict";
							var getGlobal = function () {
								return (_gsScope.GreenSockGlobals || _gsScope)[name];
							};
							if (typeof module !== "undefined" && module.exports) {
								require("../TweenLite.js");
								module.exports = getGlobal();
							} else if (typeof define === "function" && define.amd) {
								define(["TweenLite"], getGlobal);
							}
						})("DrawSVGPlugin");
					}.call(this));
				}.call(
					this,
					typeof global !== "undefined"
						? global
						: typeof self !== "undefined"
						? self
						: typeof window !== "undefined"
						? window
						: {}
				));
			},
			{ "../TweenLite.js": 71 },
		],
	},
	{},
	[60]
);
